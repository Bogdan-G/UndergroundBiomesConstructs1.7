diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/Accessor.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Accessor.java
index 8a4293c..759c457 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/Accessor.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Accessor.java
@@ -9,7 +9,7 @@ public class Accessor<ObjectType, FieldType>{
     private Field field;
     private final Class FieldTypeVar;
     public Accessor(Class _FieldType) {
-    	FieldTypeVar = _FieldType;
+        FieldTypeVar = _FieldType;
     }
 
     private Field field(ObjectType example) {
@@ -42,7 +42,7 @@ public class Accessor<ObjectType, FieldType>{
 
     public FieldType get(ObjectType object) {
         try {
-             return (FieldType)(field(object).get(object));
+            return (FieldType)(field(object).get(object));
         } catch (IllegalArgumentException ex) {
             throw new RuntimeException(ex);
         } catch (IllegalAccessException ex) {
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Bomb.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Bomb.java
new file mode 100644
index 0000000..28fdee4
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Bomb.java
@@ -0,0 +1,15 @@
+
+package Zeno410Utils;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class Bomb extends RuntimeException {
+
+    public Bomb() {super();}
+
+
+    public Bomb(Exception e) {super(e);}
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/ConfigManager.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/ConfigManager.java
index e9a5f7f..6ce9c2f 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/ConfigManager.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/ConfigManager.java
@@ -3,16 +3,92 @@ package Zeno410Utils;
 
 import java.io.File;
 import java.io.IOException;
+import java.net.URI;
+import java.net.URISyntaxException;
 import java.util.logging.Level;
 import java.util.logging.Logger;
 import java.util.regex.PatternSyntaxException;
+import net.minecraft.world.WorldServer;
 import net.minecraftforge.common.config.Configuration;
 
+public class ConfigManager<Type extends Settings> {
+    static Logger logger = new Zeno410Logger("ConfigManager").logger();
+    public final static String CONFIG_DIRECTORY = "worldSpecificConfig";
+    private Configuration general;
+    private File generalConfigFile;
+    private Type settings;
+    private File worldConfigFile;
+    private Configuration worldSpecific;
+
+    public ConfigManager(Configuration general, Type settings, File generalFile) {
+        this.general = general;
+        this.settings = settings;
+        this.generalConfigFile  = generalFile;
+    }
+
+    private boolean usable(File tested) {
+        return tested != null;
+    }
+
+    public void saveWorldSpecific() {
+        worldSpecific.save();
+    }
+
+    private void setWorldConfigFile(File newFile) {
+        if ((worldConfigFile== null)||(!newFile.getAbsolutePath().equals(worldConfigFile.getAbsolutePath()))) {
+            worldConfigFile = newFile;
+            if (usable(worldConfigFile)) {
+                // usable world
+                    logger.info(worldConfigFile.getPath());
+                if (newFile.exists()) {
+                    worldSpecific = new Configuration(worldConfigFile);
+                    logger.info("exists ");
+                    worldSpecific.load();
+                    settings.readFrom(worldSpecific);
+                } else {
+                    logger.info("doesn't exist");
+                    worldSpecific = new Configuration(worldConfigFile);
+                    // else we use the default;
+                    settings.readFrom(general);
+                    settings.copyTo(worldSpecific);
+                }
+                worldSpecific.save();
+            } else {
+                logger.info("null file");
+                worldSpecific = null;
+                settings.readFrom(general);
+            }
+        }
+    }
+
+    public void setWorldFile(File newFile) {
+        // this is the world save directory
+        File configDirectory = new File(newFile,CONFIG_DIRECTORY);
+        configDirectory.mkdir();
+
+        String configName = generalConfigFile.getPath();
+        String generalConfigDirectoryName = generalConfigFile.getParentFile().getPath();
+        String detailName = configName.substring(generalConfigDirectoryName.length()+1);
+        logger.info("Filename "+detailName);
+        File localConfigFile = new File(configDirectory,detailName);
+        setWorldConfigFile(localConfigFile);
+    }
+
+    public void clearWorldFile() {
+        worldConfigFile = null;
+        worldSpecific = null;
+        logger.info("clearing ");
+    }
+
+    public void setWorldFile(WorldServer server) {
+        setWorldFile(server.getChunkSaveLocation());
+    }
+
 /**
  * This class manages overall and world-specific configs
  * @author Zeno410
  */
-public class ConfigManager<Type extends Settings> {
+/*public class ConfigManager<Type extends Settings> {
     static Logger logger = new Zeno410Logger("ConfigManager").logger();
     public final static String CONFIG_DIRECTORY = "worldSpecificConfig";
     private Configuration general;
@@ -61,20 +137,53 @@ public class ConfigManager<Type extends Settings> {
 
     public void setWorldFile(File newFile) {
         // this is the world save directory
-        // String configDirectoryName = newFile.getAbsoluteFile()+File.separator+CONFIG_DIRECTORY;
-        File configDirectory = new File(newFile,CONFIG_DIRECTORY);
+        String configDirectoryName = newFile.getAbsoluteFile()+File.separator+CONFIG_DIRECTORY;
+        logger.info("Directory name "+configDirectoryName);
+        File configDirectory = fileNamed(configDirectoryName);
         configDirectory.mkdir();
 
         String configName = generalConfigFile.getPath();
         String generalConfigDirectoryName = generalConfigFile.getParentFile().getPath();
         String detailName = configName.substring(generalConfigDirectoryName.length()+1);
-        logger.info("Filename " + detailName);
-        File localConfigFile = new File(configDirectory,detailName);
+        logger.info("Filename "+detailName);
+        String localConfigFileName = configDirectoryName + File.separator+ detailName;
+        File localConfigFile = fileNamed(localConfigFileName);
         setWorldConfigFile(localConfigFile);
     }
 
     public String lastFile(String multipath) {
         String [] parts = multipath.split(File.separator);
-        return parts[parts.length - 1];
+        return parts[parts.length -1];
+    }
+
+    public static File fileNamed(String output) {
+        try {
+                URI outputURI = new URI(("file:///"+ output.replaceAll(" ", "%20")));
+                File outputFile = new File(outputURI);
+
+                if (!outputFile.exists()) {
+                    createParents(outputFile);
+                    outputFile.createNewFile();
+
+                }
+                return outputFile;
+            } catch (URISyntaxException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+                throw new RuntimeException(e);
+            } catch (IOException e) {
+                // TODO Auto-generated catch block
+                e.printStackTrace();
+                throw new RuntimeException(e);
+            }
+    }
+
+    private static void createParents(File outputFile) {
+        File parent = outputFile.getParentFile();
+        if(!parent.exists()){
+            parent.mkdirs();
+        }
+
     }
+}*/
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/GenLayerSpy.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/GenLayerSpy.java
index e05e44d..1c959b7 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/GenLayerSpy.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/GenLayerSpy.java
@@ -22,7 +22,7 @@ public class GenLayerSpy extends GenLayer {
             //logger.info( "fieldcount "+fields.length);
             for (int i = 0; i < fields.length;i ++) {
                 //logger.info( fields[i].getName());
-                if (GenLayer.class.isAssignableFrom(fields[i].getClass())) {
+                if (fields[i].getName().contains("field_75909_a")) {
                     parentField = fields[i];
                     parentField.setAccessible(true);
                 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/Maybe.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Maybe.java
index 69137d7..9d3dca1 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/Maybe.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Maybe.java
@@ -100,7 +100,7 @@ public abstract class Maybe<T> implements Iterable<T> {
 
         @Override
         public <U> Maybe<U> to(Function<? super T, ? extends U> mapping) {
-            return (Maybe<U>) definitely(mapping.apply(theValue));
+            return definitely(mapping.apply(theValue));
         }
 
         @Override
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/MinecraftName.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/MinecraftName.java
new file mode 100644
index 0000000..4f59415
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/MinecraftName.java
@@ -0,0 +1,24 @@
+
+package Zeno410Utils;
+
+import net.minecraft.util.StatCollector;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class MinecraftName {
+    private final String unlocalized;
+    public MinecraftName(String unlocalized) {
+        this.unlocalized = unlocalized;
+    }
+    public String localized() {
+        return StatCollector.translateToLocal(this.unlocalized() + ".name");
+        //return unlocalized();
+    }
+    public String unlocalized() {return unlocalized;}
+
+    public boolean legit() {
+        return StatCollector.canTranslate(unlocalized+".name");
+    }
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/Settings.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Settings.java
index ccfe726..76f1f0e 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/Zeno410Utils/Settings.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Settings.java
@@ -284,6 +284,9 @@ abstract public class Settings implements Streamable {
         public String description() {
            return description;
         }
+        public void setDescription(String newDescription) {
+            description = newDescription;
+        }
         public Mutable<Boolean> booleanSetting(String key,String comment, boolean defaultValue){
             return new BooleanSetting(this,key,comment,defaultValue);
         }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Valued.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Valued.java
new file mode 100644
index 0000000..43e6016
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/Zeno410Utils/Valued.java
@@ -0,0 +1,26 @@
+
+package Zeno410Utils;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class Valued<Type> implements Comparable<Valued<Type>> {
+    private double value;
+    private Type item;
+
+    public Valued(double _count,Type _item) {
+        value = _count;
+        item  = _item;
+    }
+
+    public double vanlue() {return value;}
+    public Type item() {return item;}
+
+    public int compareTo(Valued<Type> arg0) {
+        if (this.value > arg0.value) return 1;
+        if (this.value == arg0.value) return 0;
+        return -1;
+    }
+
+}
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/BiomeGenUndergroundBase.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/BiomeGenUndergroundBase.java
new file mode 100644
index 0000000..9f40be3
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/BiomeGenUndergroundBase.java
@@ -0,0 +1,59 @@
+package exterminatorJeff.undergroundBiomes.api;
+
+public class BiomeGenUndergroundBase {
+    
+    
+    public String biomeName = "";
+    
+    public final int biomeID;
+    
+    public boolean hasStrata = false;
+    
+    public StrataLayer[] strata;
+    
+    public final PerlinNoiseGenerator strataNoise;
+    
+    //public int fillerBlock = 0;
+    //public byte fillerBlockMetadata;
+
+    public final UBStoneCodes fillerBlockCodes;
+    
+    public BiomeGenUndergroundBase(int ID, NamedBlock filler, int metadataValue, BiomeGenUndergroundBase [] biomeList){
+        this.biomeID = ID;
+        this.fillerBlockCodes = new UBStoneCodes(filler,metadataValue);
+        strataNoise = new PerlinNoiseGenerator(1);
+        biomeList[ID] = this;
+    }
+
+    public BiomeGenUndergroundBase(int ID, NamedBlock filler, int metadataValue, BiomeGenUndergroundBase [] biomeList,
+            StrataLayer [] strataLayers){
+        this.biomeID = ID;
+        this.fillerBlockCodes = new UBStoneCodes(filler,metadataValue);
+        strataNoise = new PerlinNoiseGenerator(1);
+        biomeList[ID] = this;
+        AddStrataLayers(strataLayers);
+    }
+    
+    public BiomeGenUndergroundBase AddStrataLayers(StrataLayer[] strata){
+        hasStrata = true;
+        this.strata = strata;    
+        return this;
+    }
+    
+    public UBStoneCodes getStrataBlockAtLayer(int y){
+        for(int i = 0; i < strata.length; i++){
+            if(strata[i].valueIsInLayer(y) == true){
+                return strata[i].codes;
+            }
+        }
+        return fillerBlockCodes;
+    }
+    
+    public BiomeGenUndergroundBase setName(String name){
+        this.biomeName = name;
+        return this;
+    }
+    
+}
+
+
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/BlockCodes.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/BlockCodes.java
index 756810c..2e33db5 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/BlockCodes.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/BlockCodes.java
@@ -9,46 +9,43 @@ import Zeno410Utils.*;
 import net.minecraft.block.Block;
 
 public class BlockCodes extends BlockState {
-	public final NamedBlock name;
-	public final BlockCodes onDrop;
-	private final int metadataHashCode;
-	
-	public BlockCodes(Block block, int metadata) {
-		super(block, metadata);
-		name = null;
-		onDrop = this;
-		metadataHashCode = new Integer(metadata).hashCode();
-	}
-	
-	public BlockCodes(NamedBlock namer, int metadata) {
-		super(namer.block(), metadata);
-		name = namer;
-		if (block == null) {
-			throw new RuntimeException("couldn't find block for " + namer.internal());
-		}
-		onDrop = this;
-		metadataHashCode = new Integer(metadata).hashCode();
-	}
-	
-	public BlockCodes(NamedBlock namer, int metadata, BlockCodes onDrop) {
-		super(namer.block(), metadata);
-		name = namer;
-		this.onDrop = onDrop;
-		metadataHashCode = new Integer(metadata).hashCode();
-	}
-	
-	@Override
-	public int hashCode() {
-		return block.hashCode() + metadataHashCode;
-	}
-	
-	@Override
-	public boolean equals(Object compared) {
-		if (compared instanceof BlockCodes) {
-			BlockCodes comparedCodes = (BlockCodes) compared;
-			if ((block == comparedCodes.block) && (metadata == comparedCodes.metadata))
-				return true;
-		}
-		return false;
-	}
+    public final NamedBlock name;
+    public final BlockCodes onDrop;
+    private final int metadataHashcode;
+
+    public BlockCodes(Block block, int metadata) {
+        super(block,metadata);
+        name = null;
+        onDrop = this;
+        metadataHashcode = new Integer(metadata).hashCode();
+    }
+    
+    public BlockCodes(NamedBlock namer, int metadata) {
+        super(namer.block(),metadata);
+        name = namer;
+        if (block == null) {
+            throw new RuntimeException("couldn't find block for "+namer.internal());
+        }
+        onDrop = this;
+        metadataHashcode = new Integer(metadata).hashCode();
+    }
+
+    public BlockCodes(NamedBlock namer, int metadata, BlockCodes onDrop) {
+        super(namer.block(),metadata);
+        name = namer;
+        this.onDrop = onDrop;
+        metadataHashcode = new Integer(metadata).hashCode();
+    }
+
+    public int hashcode() {
+        return block.hashCode()+metadataHashcode;
+    }
+
+    public boolean equals(Object compared) {
+        if (compared instanceof BlockCodes) {
+            BlockCodes comparedCodes = (BlockCodes)compared;
+            if ((block==comparedCodes.block)&&(metadata == comparedCodes.metadata)) return true;
+        }
+        return false;
+    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/NamedSlabPair.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/NamedSlabPair.java
index c716209..ffd4166 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/NamedSlabPair.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/NamedSlabPair.java
@@ -1,33 +1,34 @@
 package exterminatorJeff.undergroundBiomes.api;
-
+import Zeno410Utils.*;
 import net.minecraft.block.Block;
+import java.util.logging.Logger;
 
 /**
  *
  * @author Zeno410
  */
 public class NamedSlabPair {
-	public final NamedBlock half;
-	public final NamedBlock full;
+    public static final Logger logger = new Zeno410Logger("NamedSlabPair").logger();
+    public final NamedBlock half;
+    public final NamedBlock full;
+
+    public NamedSlabPair(NamedBlock material) {
+        half = new NamedSlab(material.internal()+"HalfSlab");
+        full = new NamedSlab(material.internal()+"FullSlab");
+    }
+
+    public static class NamedSlab extends NamedBlock {
+        public NamedSlab(String name) {super(name);}
 
-	public NamedSlabPair(NamedBlock material) {
-		half = new NamedSlab(material.internal() + "HalfSlab");
-		full = new NamedSlab(material.internal() + "FullSlab");
-	}
+        public Block block() {
+            // this doesn't register its own items so it doesn't have the block
+            Block result =  Block.getBlockFromName(internal());
+            if (result == null) {
+                result =  Block.getBlockFromName(external());
+            }
+            return result;
+        }
 
-	public static class NamedSlab extends NamedBlock {
-		public NamedSlab(String name) {
-			super(name);
-		}
+    }
 
-		@Override
-		public Block block() {
-			// this doesn't register its own items so it doesn't have the block
-			Block result = Block.getBlockFromName(internal());
-			if (result == null) {
-				result = Block.getBlockFromName(external());
-			}
-			return result;
-		}
-	}
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/NoiseGenerator.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/NoiseGenerator.java
new file mode 100644
index 0000000..1e2b85a
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/NoiseGenerator.java
@@ -0,0 +1,170 @@
+package exterminatorJeff.undergroundBiomes.api;
+
+/**
+ * Base class for all noise generators
+ */
+public abstract class NoiseGenerator {
+    protected final int perm[] = new int[512];
+    protected double offsetX;
+    protected double offsetY;
+    protected double offsetZ;
+
+    /**
+     * Speedy floor, faster than (int)Math.floor(x)
+     *
+     * @param x Value to floor
+     * @return Floored value
+     */
+    public static int floor(double x) {
+        return x >= 0 ? (int) x : (int) x - 1;
+    }
+
+    protected static double fade(double x) {
+        return x * x * x * (x * (x * 6 - 15) + 10);
+    }
+
+    protected static double lerp(double x, double y, double z) {
+        return y + x * (z - y);
+    }
+
+    protected static double grad(int hash, double x, double y, double z) {
+        hash &= 15;
+        double u = hash < 8 ? x : y;
+        double v = hash < 4 ? y : hash == 12 || hash == 14 ? x : z;
+        return ((hash & 1) == 0 ? u : -u) + ((hash & 2) == 0 ? v : -v);
+    }
+
+    /**
+     * Computes and returns the 1D noise for the given coordinate in 1D space
+     *
+     * @param x X coordinate
+     * @return Noise at given location, from range -1 to 1
+     */
+    public double noise(double x) {
+        return noise(x, 0, 0);
+    }
+
+    /**
+     * Computes and returns the 2D noise for the given coordinates in 2D space
+     *
+     * @param x X coordinate
+     * @param y Y coordinate
+     * @return Noise at given location, from range -1 to 1
+     */
+    public double noise(double x, double y) {
+        return noise(x, y, 0);
+    }
+
+    /**
+     * Computes and returns the 3D noise for the given coordinates in 3D space
+     *
+     * @param x X coordinate
+     * @param y Y coordinate
+     * @param z Z coordinate
+     * @return Noise at given location, from range -1 to 1
+     */
+    public abstract double noise(double x, double y, double z);
+
+    /**
+     * Generates noise for the 1D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @return Resulting noise
+     */
+    public double noise(double x, int octaves, double frequency, double amplitude) {
+        return noise(x, 0, 0, octaves, frequency, amplitude);
+    }
+
+    /**
+     * Generates noise for the 1D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @param normalized If true, normalize the value to [-1, 1]
+     * @return Resulting noise
+     */
+    public double noise(double x, int octaves, double frequency, double amplitude, boolean normalized) {
+        return noise(x, 0, 0, octaves, frequency, amplitude, normalized);
+    }
+
+    /**
+     * Generates noise for the 2D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param y Y-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @return Resulting noise
+     */
+    public double noise(double x, double y, int octaves, double frequency, double amplitude) {
+        return noise(x, y, 0, octaves, frequency, amplitude);
+    }
+
+    /**
+     * Generates noise for the 2D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param y Y-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @param normalized If true, normalize the value to [-1, 1]
+     * @return Resulting noise
+     */
+    public double noise(double x, double y, int octaves, double frequency, double amplitude, boolean normalized) {
+        return noise(x, y, 0, octaves, frequency, amplitude, normalized);
+    }
+
+    /**
+     * Generates noise for the 3D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param y Y-coordinate
+     * @param z Z-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @return Resulting noise
+     */
+    public double noise(double x, double y, double z, int octaves, double frequency, double amplitude) {
+        return noise(x, y, z, octaves, frequency, amplitude, false);
+    }
+
+    /**
+     * Generates noise for the 3D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param y Y-coordinate
+     * @param z Z-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @param normalized If true, normalize the value to [-1, 1]
+     * @return Resulting noise
+     */
+    public double noise(double x, double y, double z, int octaves, double frequency, double amplitude, boolean normalized) {
+        double result = 0;
+        double amp = 1;
+        double freq = 1;
+        double max = 0;
+
+        for (int i = 0; i < octaves; i++) {
+            result += noise(x * freq, y * freq, z * freq) * amp;
+            max += amp;
+            freq *= frequency;
+            amp *= amplitude;
+        }
+
+        if (normalized) {
+            result /= max;
+        }
+
+        return result;
+    }
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/PerlinNoiseGenerator.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/PerlinNoiseGenerator.java
new file mode 100644
index 0000000..b3d03c2
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/PerlinNoiseGenerator.java
@@ -0,0 +1,200 @@
+package exterminatorJeff.undergroundBiomes.api;
+
+import java.util.Random;
+
+/**
+ * Generates noise using the "classic" perlin generator
+ *
+ * @see SimplexNoiseGenerator "Improved" and faster version with slighly different results
+ */
+public class PerlinNoiseGenerator extends NoiseGenerator {
+    protected static final int grad3[][] = {{1, 1, 0}, {-1, 1, 0}, {1, -1, 0}, {-1, -1, 0},
+        {1, 0, 1}, {-1, 0, 1}, {1, 0, -1}, {-1, 0, -1},
+        {0, 1, 1}, {0, -1, 1}, {0, 1, -1}, {0, -1, -1}};
+    private static final PerlinNoiseGenerator instance = new PerlinNoiseGenerator();
+
+    protected PerlinNoiseGenerator() {
+        int p[] = {151, 160, 137, 91, 90, 15, 131, 13, 201,
+            95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37,
+            240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
+            94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56,
+            87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139,
+            48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
+            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25,
+            63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200,
+            196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3,
+            64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255,
+            82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
+            223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
+            101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79,
+            113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242,
+            193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249,
+            14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204,
+            176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222,
+            114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180};
+
+        for (int i = 0; i < 512; i++) {
+            perm[i] = p[i & 255];
+        }
+    }
+
+    /**
+     * Creates a seeded perlin noise generator for the given seed
+     *
+     * @param seed Seed to construct this generator for
+     */
+    public PerlinNoiseGenerator(long seed) {
+        this(new Random(seed));
+    }
+
+    /**
+     * Creates a seeded perlin noise generator with the given Random
+     *
+     * @param rand Random to construct with
+     */
+    public PerlinNoiseGenerator(Random rand) {
+        offsetX = rand.nextDouble() * 256;
+        offsetY = rand.nextDouble() * 256;
+        offsetZ = rand.nextDouble() * 256;
+
+        for (int i = 0; i < 256; i++) {
+            perm[i] = rand.nextInt(256);
+        }
+
+        for (int i = 0; i < 256; i++) {
+            int pos = rand.nextInt(256 - i) + i;
+            int old = perm[i];
+
+            perm[i] = perm[pos];
+            perm[pos] = old;
+            perm[i + 256] = perm[i];
+        }
+    }
+
+    /**
+     * Computes and returns the 1D unseeded perlin noise for the given coordinates in 1D space
+     *
+     * @param x X coordinate
+     * @return Noise at given location, from range -1 to 1
+     */
+    public static double getNoise(double x) {
+        return instance.noise(x);
+    }
+
+    /**
+     * Computes and returns the 2D unseeded perlin noise for the given coordinates in 2D space
+     *
+     * @param x X coordinate
+     * @param y Y coordinate
+     * @return Noise at given location, from range -1 to 1
+     */
+    public static double getNoise(double x, double y) {
+        return instance.noise(x, y);
+    }
+
+    /**
+     * Computes and returns the 3D unseeded perlin noise for the given coordinates in 3D space
+     *
+     * @param x X coordinate
+     * @param y Y coordinate
+     * @param z Z coordinate
+     * @return Noise at given location, from range -1 to 1
+     */
+    public static double getNoise(double x, double y, double z) {
+        return instance.noise(x, y, z);
+    }
+
+    /**
+     * Gets the singleton unseeded instance of this generator
+     *
+     * @return Singleton
+     */
+    public static PerlinNoiseGenerator getInstance() {
+        return instance;
+    }
+
+    @Override
+    public double noise(double x, double y, double z) {
+        x += offsetX;
+        y += offsetY;
+        z += offsetZ;
+
+        int floorX = floor(x);
+        int floorY = floor(y);
+        int floorZ = floor(z);
+
+        // Find unit cube containing the point
+        int X = floorX & 255;
+        int Y = floorY & 255;
+        int Z = floorZ & 255;
+
+        // Get relative xyz coordinates of the point within the cube
+        x -= floorX;
+        y -= floorY;
+        z -= floorZ;
+
+        // Compute fade curves for xyz
+        double fX = fade(x);
+        double fY = fade(y);
+        double fZ = fade(z);
+
+        // Hash coordinates of the cube corners
+        int A = perm[X] + Y;
+        int AA = perm[A] + Z;
+        int AB = perm[A + 1] + Z;
+        int B = perm[X + 1] + Y;
+        int BA = perm[B] + Z;
+        int BB = perm[B + 1] + Z;
+
+        return lerp(fZ, lerp(fY, lerp(fX, grad(perm[AA], x, y, z),
+                        grad(perm[BA], x - 1, y, z)),
+                    lerp(fX, grad(perm[AB], x, y - 1, z),
+                        grad(perm[BB], x - 1, y - 1, z))),
+                lerp(fY, lerp(fX, grad(perm[AA + 1], x, y, z - 1),
+                        grad(perm[BA + 1], x - 1, y, z - 1)),
+                    lerp(fX, grad(perm[AB + 1], x, y - 1, z - 1),
+                        grad(perm[BB + 1], x - 1, y - 1, z - 1))));
+    }
+
+    /**
+     * Generates noise for the 1D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @return Resulting noise
+     */
+    public static double getNoise(double x, int octaves, double frequency, double amplitude) {
+        return instance.noise(x, octaves, frequency, amplitude);
+    }
+
+    /**
+     * Generates noise for the 2D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param y Y-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @return Resulting noise
+     */
+    public static double getNoise(double x, double y, int octaves, double frequency, double amplitude) {
+        return instance.noise(x, y, octaves, frequency, amplitude);
+    }
+
+    /**
+     * Generates noise for the 3D coordinates using the specified number of octaves and parameters
+     *
+     * @param x X-coordinate
+     * @param y Y-coordinate
+     * @param z Z-coordinate
+     * @param octaves Number of octaves to use
+     * @param frequency How much to alter the frequency by each octave
+     * @param amplitude How much to alter the amplitude by each octave
+     * @return Resulting noise
+     */
+    public static double getNoise(double x, double y, double z, int octaves, double frequency, double amplitude) {
+        return instance.noise(x, y, z, octaves, frequency, amplitude);
+    }
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/StrataLayer.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/StrataLayer.java
new file mode 100644
index 0000000..35f2dd1
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/StrataLayer.java
@@ -0,0 +1,24 @@
+package exterminatorJeff.undergroundBiomes.api;
+
+public class StrataLayer{
+    public final NamedBlock layerBlock;
+    public final int layerMetadataID, layerMin, layerMax;
+    public final UBStoneCodes codes;
+    
+    public StrataLayer(NamedBlock layerBlock, int layerMetadataID, int layerMin, int layerMax){
+        this.layerBlock = layerBlock;
+        this.layerMetadataID = layerMetadataID;
+        this.layerMin = layerMin;
+        this.layerMax = layerMax;
+        this.codes = new UBStoneCodes(layerBlock, layerMetadataID);
+    }
+    
+    public boolean valueIsInLayer(int y){
+        if(y >= layerMin && y <= layerMax){
+            return true;
+        }else{
+            return false;
+        }
+    }
+    
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/UBAPIHook.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBAPIHook.java
index 3ca49a8..1001160 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/UBAPIHook.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBAPIHook.java
@@ -8,4 +8,5 @@ public class UBAPIHook {
     public static final UBAPIHook ubAPIHook = new UBAPIHook();
     public UBDimensionalStrataColumnProvider dimensionalStrataColumnProvider; // set in the main Underground Biomes
     public UBOreTexturizer ubOreTexturizer;
+    public UBSetProviderRegistry ubSetProviderRegistry;
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/UBIDs.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBIDs.java
index dff90cf..a3ec073 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/UBIDs.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBIDs.java
@@ -5,125 +4,97 @@ import net.minecraft.item.Item;
 
 /**
  * A shell for various constants
- * 
  * @author Zeno410
  */
 public class UBIDs {
 
-	public final static int version = 3;
-	
-	public final static NamedBlock igneousStoneName = new NamedBlock("igneousStone");
-	public final static NamedBlock igneousCobblestoneName = new NamedBlock("igneousCobblestone");
-	public final static NamedBlock igneousStoneBrickName = new NamedBlock("igneousStoneBrick");
-	public final static NamedBlock metamorphicStoneName = new NamedBlock("metamorphicStone");
-	public final static NamedBlock metamorphicCobblestoneName = new NamedBlock("metamorphicCobblestone");
-	public final static NamedBlock metamorphicStoneBrickName = new NamedBlock("metamorphicStoneBrick");
-	public final static NamedBlock sedimentaryStoneName = new NamedBlock("sedimentaryStone");
-	
-	public final static NamedItem ligniteCoalName = new NamedItem("ligniteCoal");
-	public final static NamedItem fossilPieceName = new NamedItem("fossilPiece");
-	
-	public final static NamedSlabPair igneousBrickSlabName = new NamedSlabPair(igneousStoneBrickName);
-	public final static NamedSlabPair metamorphicBrickSlabName = new NamedSlabPair(metamorphicStoneBrickName);
-	public final static NamedSlabPair igneousStoneSlabName = new NamedSlabPair(igneousStoneName);
-	public final static NamedSlabPair metamorphicStoneSlabName = new NamedSlabPair(metamorphicStoneName);
-	public final static NamedSlabPair igneousCobblestoneSlabName = new NamedSlabPair(igneousCobblestoneName);
-	public final static NamedSlabPair metamorphicCobblestoneSlabName = new NamedSlabPair(metamorphicCobblestoneName);
-	public final static NamedSlabPair sedimentaryStoneSlabName = new NamedSlabPair(sedimentaryStoneName);
-	
-	public final static NamedBlock UBButtonName = new NamedBlock("button");
-	public final static NamedBlock UBStairsName = new NamedBlock("stairs");
-	public final static NamedBlock UBWallsName = new NamedBlock("wall");
-	public final static NamedItem UBButtonItemName = new NamedItem(UBButtonName);
-	public final static NamedItem UBStairsItemName = new NamedItem(UBStairsName);
-	public final static NamedItem UBWallsItemName = new NamedItem(UBWallsName);
-	public final static NamedBlock IconTrap = new NamedBlock("iconTrap");
-	
-	public static final String ubPrefix() {
-		return "UndergroundBiomes:";
-	}
-	
-	public static final String ubIconPrefix() {
-		return "undergroundbiomes:";
-	}
-	
-	public static String publicName(String inModName) {
-		if (inModName.contains(ubPrefix()))
-			return inModName;
-		return ubPrefix() + inModName;
-	}
-	
-	public static String iconName(String inModName) {
-		if (inModName.contains(ubIconPrefix()))
-			return inModName;
-		return ubIconPrefix() + inModName;
-	}
-	
-	public static Item itemNamed(String name) {
-		return (Item) (Item.itemRegistry.getObject(name));
-	}
-	
-	public static Block blockNamed(String name) {
-		return Block.getBlockFromName(name);
-	}
-	
-	public static int itemID(String name) {
-		return Item.getIdFromItem(itemNamed(name));
-	}
-	
-	public static int blockID(String name) {
-		return Block.getIdFromBlock(Block.getBlockFromName(name));
-	}
-	
-	public static NamedBlock slabVersionID(NamedBlock ubStone) {
-		if (ubStone == igneousStoneName)
-			return igneousStoneSlabName.half;
-		if (ubStone == igneousCobblestoneName)
-			return igneousCobblestoneSlabName.half;
-		if (ubStone == igneousStoneBrickName)
-			return igneousBrickSlabName.half;
-		if (ubStone == metamorphicStoneName)
-			return metamorphicStoneSlabName.half;
-		if (ubStone == metamorphicCobblestoneName)
-			return metamorphicCobblestoneSlabName.half;
-		if (ubStone == metamorphicStoneBrickName)
-			return metamorphicBrickSlabName.half;
-		if (ubStone == sedimentaryStoneName)
-			return sedimentaryStoneSlabName.half;
-		if (ubStone == NamedVanillaBlock.sandstone)
-			return NamedVanillaBlock.stoneSingleSlab;
-		if (ubStone == NamedVanillaBlock.stone)
-			return NamedVanillaBlock.stoneSingleSlab;
-		if (ubStone == NamedVanillaBlock.cobblestone)
-			return NamedVanillaBlock.stoneSingleSlab;
-		if (ubStone == NamedVanillaBlock.sand)
-			return NamedVanillaBlock.stoneSingleSlab;
-		throw new RuntimeException("" + ubStone + " is not not usable as an Underground Biomes stone code");
-	}
-	
-	public static NamedBlock brickVersionID(NamedBlock ubStone) {
-		if (ubStone == igneousStoneName)
-			return igneousStoneBrickName;
-		if (ubStone == igneousCobblestoneName)
-			return igneousStoneBrickName;
-		if (ubStone == igneousStoneBrickName)
-			return igneousStoneBrickName;
-		if (ubStone == metamorphicStoneName)
-			return metamorphicStoneBrickName;
-		if (ubStone == metamorphicCobblestoneName)
-			return metamorphicStoneBrickName;
-		if (ubStone == metamorphicStoneBrickName)
-			return metamorphicStoneBrickName;
-		if (ubStone == sedimentaryStoneName)
-			return sedimentaryStoneName;
-		if (ubStone == NamedVanillaBlock.sandstone)
-			return NamedVanillaBlock.smoothSandstone;
-		if (ubStone == NamedVanillaBlock.stone)
-			return NamedVanillaBlock.stoneBrick;
-		if (ubStone == NamedVanillaBlock.cobblestone)
-			return NamedVanillaBlock.stoneBrick;
-		if (ubStone == NamedVanillaBlock.sand)
-			return NamedVanillaBlock.sandstone;
-		throw new RuntimeException("" + ubStone + " is not usable as an Underground Biomes stone code");
-	}
+    public final static int version = 3;
+
+    public final static NamedBlock igneousStoneName = new NamedBlock("igneousStone");
+    public final static NamedBlock igneousCobblestoneName = new NamedBlock("igneousCobblestone");
+    public final static NamedBlock igneousStoneBrickName= new NamedBlock("igneousStoneBrick");
+    public final static NamedBlock metamorphicStoneName= new NamedBlock("metamorphicStone");
+    public final static NamedBlock metamorphicCobblestoneName= new NamedBlock("metamorphicCobblestone");
+    public final static NamedBlock metamorphicStoneBrickName= new NamedBlock("metamorphicStoneBrick");
+    public final static NamedBlock sedimentaryStoneName = new NamedBlock("sedimentaryStone");
+
+    public final static NamedItem ligniteCoalName  = new NamedItem("ligniteCoal");
+    public final static NamedItem fossilPieceName = new NamedItem("fossilPiece");
+
+    public final static NamedSlabPair igneousBrickSlabName = new NamedSlabPair(igneousStoneBrickName);
+    public final static NamedSlabPair metamorphicBrickSlabName = new NamedSlabPair(metamorphicStoneBrickName);
+    public final static NamedSlabPair igneousStoneSlabName = new NamedSlabPair(igneousStoneName);
+    public final static NamedSlabPair metamorphicStoneSlabName = new NamedSlabPair(metamorphicStoneName);
+    public final static NamedSlabPair igneousCobblestoneSlabName = new NamedSlabPair(igneousCobblestoneName);
+    public final static NamedSlabPair metamorphicCobblestoneSlabName = new NamedSlabPair(metamorphicCobblestoneName);
+    public final static NamedSlabPair sedimentaryStoneSlabName = new NamedSlabPair(sedimentaryStoneName);
+    
+    public final static NamedBlock UBButtonName = new NamedBlock("button");
+    public final static NamedBlock UBStairsName = new NamedBlock("stairs");
+    public final static NamedBlock UBWallsName = new NamedBlock("wall");
+    public final static NamedBlock UBWallsBlockName = new NamedBlock("wallBlock");
+    public final static NamedItem UBButtonItemName = new NamedItem(UBButtonName);
+    public final static NamedItem UBStairsItemName = new NamedItem(UBStairsName);
+    public final static NamedItem UBWallsItemName = new NamedItem(UBWallsName);
+    public final static NamedBlock IconTrap = new NamedBlock("iconTrap");
+
+
+    public static final String ubPrefix() {return "UndergroundBiomes:";}
+    public static final String ubIconPrefix() {return "undergroundbiomes:";}
+
+    public static String publicName(String inModName) {
+        if (inModName.contains(ubPrefix())) return inModName;
+        return ubPrefix()+inModName;
+    }
+
+    public static String iconName(String inModName) {
+        if (inModName.contains(ubIconPrefix())) return inModName;
+        return ubIconPrefix()+inModName;
+    }
+
+    public static Item itemNamed(String name) {
+        return (Item)(Item.itemRegistry.getObject(name));
+    }
+
+    public static Block blockNamed(String name) {
+        return Block.getBlockFromName(name);
+    }
+
+    public static int itemID(String name) {
+        return Item.getIdFromItem(itemNamed(name));
+    }
+
+    public static int blockID(String name) {
+        return Block.getIdFromBlock(Block.getBlockFromName(name));
+    }
+
+    public static NamedBlock slabVersionID(NamedBlock ubStone) {
+        if (ubStone == igneousStoneName) return igneousStoneSlabName.half;
+        if (ubStone == igneousCobblestoneName) return igneousCobblestoneSlabName.half;
+        if (ubStone == igneousStoneBrickName) return igneousBrickSlabName.half;
+        if (ubStone == metamorphicStoneName) return metamorphicStoneSlabName.half;
+        if (ubStone == metamorphicCobblestoneName) return metamorphicCobblestoneSlabName.half;
+        if (ubStone == metamorphicStoneBrickName) return metamorphicBrickSlabName.half;
+        if (ubStone == sedimentaryStoneName) return sedimentaryStoneSlabName.half;
+        if (ubStone == NamedVanillaBlock.sandstone) return NamedVanillaBlock.stoneSingleSlab;
+        if (ubStone == NamedVanillaBlock.stone) return NamedVanillaBlock.stoneSingleSlab;
+        if (ubStone == NamedVanillaBlock.cobblestone) return NamedVanillaBlock.stoneSingleSlab;
+        if (ubStone == NamedVanillaBlock.sand) return NamedVanillaBlock.stoneSingleSlab;
+        throw new RuntimeException(""+ ubStone + " is not not usable as an Underground Biomes stone code");
+    }
+
+    public static NamedBlock brickVersionID(NamedBlock ubStone) {
+        if (ubStone == igneousStoneName) return igneousStoneBrickName;
+        if (ubStone == igneousCobblestoneName) return igneousStoneBrickName;
+        if (ubStone == igneousStoneBrickName) return igneousStoneBrickName;
+        if (ubStone == metamorphicStoneName) return metamorphicStoneBrickName;
+        if (ubStone == metamorphicCobblestoneName) return metamorphicStoneBrickName;
+        if (ubStone == metamorphicStoneBrickName) return metamorphicStoneBrickName;
+        if (ubStone == sedimentaryStoneName) return sedimentaryStoneName;
+        if (ubStone == NamedVanillaBlock.sandstone) return NamedVanillaBlock.smoothSandstone;
+        if (ubStone == NamedVanillaBlock.stone) return NamedVanillaBlock.stoneBrick;
+        if (ubStone == NamedVanillaBlock.cobblestone) return NamedVanillaBlock.stoneBrick;
+        if (ubStone == NamedVanillaBlock.sand) return NamedVanillaBlock.sandstone;
+        throw new RuntimeException(""+ ubStone + " is not usable as an Underground Biomes stone code");
+    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/UBOreTexturizer.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBOreTexturizer.java
index 5c2f185..fc4f8a9 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/UBOreTexturizer.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBOreTexturizer.java
@@ -30,51 +30,23 @@ public interface UBOreTexturizer {
     public void requestUBOreSetup(Block oreBlock, int metadata, String overlayName, String blockName) throws BlocksAreAlreadySet;
     public void redoOres(int xInBlockCoordinates, int zInBlockCoordinates, World serverSideWorld) ;
 
-    public static String no_overlay = "undergroundbiomes:no_overlay";
-    
-    public static String adamantium_overlay = "undergroundbiomes:adamantium_overlay";
-    public static String aluminium_overlay = "undergroundbiomes:aluminium_overlay";
     public static String amber_overlay = "undergroundbiomes:amber_overlay";
-    public static String amber2_overlay = "undergroundbiomes:amber2_overlay";
-    public static String bluetopaz_overlay = "undergroundbiomes:bluetopaz_overlay";
-    public static String bunginite_overlay = "undergroundbiomes:bunginite_overlay";
-    public static String carbon_overlay = "undergroundbiomes:carbon_overlay";
-    public static String carnelian_overlay = "undergroundbiomes:carnelian_overlay";
     public static String cinnabar_overlay = "undergroundbiomes:cinnabar_overlay";
-    public static String chimerite_overlay = "undergroundbiomes:chimerite_overlay";
     public static String coal_overlay = "undergroundbiomes:coal_overlay";
     public static String copper_overlay = "undergroundbiomes:copper_overlay";
     public static String diamond_overlay = "undergroundbiomes:diamond_overlay";
     public static String emerald_overlay = "undergroundbiomes:emerald_overlay";
-    public static String eridium_overlay = "undergroundbiomes:eridium_overlay";
-    public static String fossils_overlay = "undergroundbiomes:fossils_overlay";
     public static String gold_overlay = "undergroundbiomes:gold_overlay";
     public static String iron_overlay = "undergroundbiomes:iron_overlay";
     public static String lapis_overlay = "undergroundbiomes:lapis_overlay";
     public static String lead_overlay = "undergroundbiomes:lead_overlay";
-    public static String malachite_overlay = "undergroundbiomes:malachite_overlay";
-    public static String mimichite_overlay = "undergroundbiomes:mimichite_overlay";
-    public static String minicio_overlay = "undergroundbiomes:minicio_overlay";
-    public static String moonstone_overlay = "undergroundbiomes:moonstone_overlay";
-    public static String naquadah_overlay = "undergroundbiomes:naquadah_overlay";
-    public static String nickel_overlay = "undergroundbiomes:nickel_overlay";
     public static String olivine_peridot_overlay = "undergroundbiomes:olivine-peridot_overlay";
     public static String redstone_overlay = "undergroundbiomes:redstone_overlay";
     public static String ruby_overlay = "undergroundbiomes:ruby_overlay";
-    public static String salt_overlay = "undergroundbiomes:salt_overlay";
     public static String sapphire_overlay = "undergroundbiomes:sapphire_overlay";
     public static String silver_overlay = "undergroundbiomes:silver_overlay";
-    public static String sulfur_overlay = "undergroundbiomes:sulfur_overlay";
-    public static String sunstone_overlay = "undergroundbiomes:sunstone_overlay";
-    public static String talc_overlay = "undergroundbiomes:talc_overlay";
-    public static String tanzanite_overlay = "undergroundbiomes:tanzanite_overlay";
     public static String tin_overlay = "undergroundbiomes:tin_overlay";
-    public static String topaz_overlay = "undergroundbiomes:topaz_overlay";
-    public static String tourmaline_overlay = "undergroundbiomes:tourmaline_overlay";
     public static String uranium_overlay = "undergroundbiomes:uranium_overlay";
-    public static String vinteum_overlay = "undergroundbiomes:vinteum_overlay";
-    public static String zinc_overlay = "undergroundbiomes:zinc_overlay";
-    
 
     public class BlocksAreAlreadySet extends RuntimeException {
         // this is thrown if UB has already run its pre-initialization step and can no longer register blocks
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBSetProviderRegistry.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBSetProviderRegistry.java
new file mode 100644
index 0000000..759278b
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBSetProviderRegistry.java
@@ -0,0 +1,14 @@
+/*
+ * Available under the Lesser GPL License 3.0
+ */
+
+package exterminatorJeff.undergroundBiomes.api;
+
+/**
+ *
+ * @author Zeno410
+ */
+public interface UBSetProviderRegistry {
+    public void register(UndergroundBiomeSetProvider toRegister);
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBStoneCodes.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBStoneCodes.java
new file mode 100644
index 0000000..04e74e5
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UBStoneCodes.java
@@ -0,0 +1,100 @@
+package exterminatorJeff.undergroundBiomes.api;
+/**
+ *
+ * @author Zeno410
+ */
+public class UBStoneCodes extends BlockCodes {
+    // constructor is protected as it's intended to make master blocks to be passed by reference
+    // not fully implemented yet
+
+    public UBStoneCodes(NamedBlock name, int _metadata) {
+        super(name, _metadata,cobbleVersion(name, _metadata));
+    }
+    public final UBStoneCodes slabVersionEquivalent() {
+        return new UBStoneCodes(UBIDs.slabVersionID(name),metadata);
+    };
+    public final UBStoneCodes brickVersionEquivalent() {
+        return new UBStoneCodes(UBIDs.brickVersionID(name),metadata);
+    };
+
+    public static BlockCodes cobbleVersion(NamedBlock name, int metadata) {
+
+        if (name == UBIDs.igneousStoneName) {
+            return new BlockCodes(UBIDs.igneousCobblestoneName,metadata);
+        }
+        if (name == UBIDs.metamorphicStoneName) {
+            return new BlockCodes(UBIDs.metamorphicCobblestoneName,metadata);
+        }
+        if (name == UBIDs.sedimentaryStoneName) {
+           return new BlockCodes(UBIDs.sedimentaryStoneName, metadata);
+        }
+
+        if (name == NamedVanillaBlock.stone) {
+           if (metadata == 0) {
+               return new BlockCodes(NamedVanillaBlock.cobblestone, metadata);
+           }
+        }
+
+        if (name == NamedVanillaBlock.sandstone) {
+           if (metadata == 0) {
+               return new BlockCodes(NamedVanillaBlock.sandstone, metadata);
+           }
+        }
+        if (name == NamedVanillaBlock.sand) {
+           if (metadata == 0) {
+               return new BlockCodes(NamedVanillaBlock.sandstone, metadata);
+           }
+        }
+        
+        if (name == UBIDs.igneousCobblestoneName) {
+            return new BlockCodes(UBIDs.igneousCobblestoneName,metadata);
+        }
+        if (name == UBIDs.metamorphicCobblestoneName) {
+            return new BlockCodes(UBIDs.metamorphicCobblestoneName,metadata);
+        }
+
+        if (name == UBIDs.igneousStoneBrickName) {
+            return new BlockCodes(UBIDs.igneousStoneBrickName,metadata);
+        }
+        if (name == UBIDs.metamorphicStoneBrickName) {
+            return new BlockCodes(UBIDs.metamorphicStoneBrickName,metadata);
+        }
+
+        if (name == UBIDs.igneousStoneSlabName.half){
+           return new BlockCodes(UBIDs.igneousCobblestoneSlabName.half, metadata);
+        }
+        if (name == UBIDs.metamorphicStoneSlabName.half){
+           return new BlockCodes(UBIDs.metamorphicCobblestoneSlabName.half, metadata);
+        }
+        if (name == UBIDs.sedimentaryStoneSlabName.half){
+           return new BlockCodes(UBIDs.sedimentaryStoneSlabName.half, metadata);
+        }
+
+        if (name == UBIDs.igneousCobblestoneSlabName.half){
+           return new BlockCodes(UBIDs.igneousCobblestoneSlabName.half, metadata);
+        }
+        if (name == UBIDs.metamorphicCobblestoneSlabName.half){
+           return new BlockCodes(UBIDs.metamorphicCobblestoneSlabName.half, metadata);
+        }
+
+        if (name == UBIDs.igneousBrickSlabName.half){
+           return new BlockCodes(UBIDs.igneousBrickSlabName.half, metadata);
+        }
+        if (name == UBIDs.metamorphicBrickSlabName.half){
+           return new BlockCodes(UBIDs.metamorphicBrickSlabName.half, metadata);
+        }
+
+        if (name == NamedVanillaBlock.stoneBrick){
+           return new BlockCodes(NamedVanillaBlock.stoneBrick, metadata);
+        }
+
+        if (name == NamedVanillaBlock.stoneSingleSlab) {
+            return new BlockCodes(NamedVanillaBlock.stoneSingleSlab,metadata);
+        }
+
+        return new BlockCodes(NamedVanillaBlock.cobblestone, metadata);
+    }
+
+    public final BlockCodes cobblestoneEquivalent() {return this.onDrop;}
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomeSet.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomeSet.java
new file mode 100644
index 0000000..1ccbeb2
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomeSet.java
@@ -0,0 +1,18 @@
+
+package exterminatorJeff.undergroundBiomes.api;
+
+/**
+ *
+ * @author Zeno410
+ */
+abstract public class UndergroundBiomeSet {
+    public final StrataLayer [] [] strataLayers ;
+
+    public final BiomeGenUndergroundBase[] biomeList = new BiomeGenUndergroundBase[256];
+
+    public UndergroundBiomeSet(StrataLayer [] [] strataLayers) {
+        this.strataLayers = strataLayers;
+    }
+
+    abstract public BiomeGenUndergroundBase [] allowedBiomes();
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomeSetProvider.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomeSetProvider.java
new file mode 100644
index 0000000..f8ad6cf
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomeSetProvider.java
@@ -0,0 +1,12 @@
+
+package exterminatorJeff.undergroundBiomes.api;
+
+/**
+ *
+ * @author Zeno410
+ */
+abstract public interface UndergroundBiomeSetProvider {
+    // this function should return the new desired set
+    // if null is returned that signals no changes to the existing set
+     public UndergroundBiomeSet modifiedBiomeSet(int dimension, long worldSeed, UndergroundBiomeSet previous);
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomesSettings.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomesSettings.java
index 9ef86cd..870cf60 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomesSettings.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/api/UndergroundBiomesSettings.java
@@ -5,6 +5,7 @@ import Zeno410Utils.*;
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
+import java.util.HashMap;
 
 /**
  *
@@ -29,9 +30,36 @@ public final class UndergroundBiomesSettings extends Settings {
         };
     }
 
+    public UndergroundBiomesSettings(String [] igneousNames, String [] metamorphicNames, String [] sedimentaryNames) {
+        setActivations(UBIDs.igneousStoneName,"igneous stone",igneousNames);
+        setActivations(UBIDs.metamorphicStoneName,"metamorphic stone",metamorphicNames);
+        setActivations(UBIDs.sedimentaryStoneName,"sedimentary stone",sedimentaryNames);
+        setActivation(NamedVanillaBlock.sand,0);
+        setActivation(NamedVanillaBlock.sandstone,0);
+        setActivation(NamedVanillaBlock.stone,0);
+    }
+
     private final Category blockCategory = category("block");
     private final Category itemCategory = category("item");
+    private final Category generationCategory = category("generation");
+
+    private void setActivations(NamedBlock block, String type, String [] names) {
+        HashMap<Integer,Mutable<Boolean>> blockActivations = new HashMap<Integer,Mutable<Boolean>>();
+        this.stoneGenerationSettings.put(block, blockActivations);
+        for (int i = 0; i < names.length;i++) {
+            Mutable<Boolean> generationConfig = generationCategory.booleanSetting("Generate "+ type +
+                    " metadata " + i + ", " +names[i], true,"");
+            blockActivations.put(i, generationConfig);
+        }
+    }
 
+    private void setActivation(NamedBlock block, int metadata) {
+        HashMap<Integer,Mutable<Boolean>> blockActivations = new HashMap<Integer,Mutable<Boolean>>();
+        this.stoneGenerationSettings.put(block, blockActivations);
+       Mutable<Boolean> generationConfig = generationCategory.booleanSetting(
+               "Generate "+ block.internal() +", metadata " + metadata, true,"");
+        blockActivations.put(metadata, generationConfig);
+    }
     public final Mutable<Boolean> addOreDictRecipes = this.general().booleanSetting(
             "oreDictifyStone", true, "Modify all recipes to include Underground Biomes blocks");
     
@@ -86,9 +114,6 @@ public final class UndergroundBiomesSettings extends Settings {
     public final Mutable<Integer> vanillaStoneCrafting = this.general().intSetting(
             "vanillaStoneCrafting", 4, "0 = none; 1 = one rock; 2 = with redstone; 3 = 2x2 stone, lose 3; 4 = 2x2 stone");
 
-    public final Mutable<Boolean> slabOreDictionaryRegistering = this.general().booleanSetting(
-            "slabOreDictionaryRegistering", true, "false = register slabs in ore dictionnary");
-
     public final Mutable<Double>  hardnessModifier = this.general().doubleSetting(
             "hardnessModifier", 1.5, "Increase to make stone longer to mine. Normal is 1.5");
 
@@ -105,12 +130,21 @@ public final class UndergroundBiomesSettings extends Settings {
     public final Mutable<Boolean>  inChunkGeneration = this.general().booleanSetting(
             "InChunkGeneration", true,"Change stones during chunk generation");
 
+    public final Mutable<Boolean> newGeneration = this.general().booleanSetting(
+            "newGeneration", false,"Run generation as late as possible (slower but more compatible). Needs inChunk on");
+
     public final Mutable<String> inChunkGenerationExclude = this.general().stringSetting(
             "inChunkDimensionExclusions", "-1,1", "Comma-separated list of dimension to only use old decoration-phase generation, used only if inclusion list is *");
 
     public final Mutable<String> inChunkGenerationInclude = this.general().stringSetting(
             "inChunkDimensionInclusions", "0", "Comma-separated list of dimension IDs to allow new chunk-phase decoration, put * to use exclusion list");
 
+    public final Mutable<Double> brickHardnessMultiplier = this.general().doubleSetting("brickHardnessMultiplier",
+            1.0D, "UB brick hardness is this multiple of UB stone");
+
+    public final Mutable<Double> cobbleHardnessMultiplier = this.general().doubleSetting("cobbleHardnessMultiplier",
+            1.3333333D, "UB cobble hardness is this multiple of UB stone");
+
     public final Mutable<Integer> ligniteCoalID = this.blockCategory.intSetting("Lignite Item ID:", 5500);
     public final Mutable<Integer> fossilPieceID = this.itemCategory.intSetting("fossilPiece", 5501);
 
@@ -149,4 +183,13 @@ public final class UndergroundBiomesSettings extends Settings {
     public final Mutable<Integer> stoneStairID = this.blockCategory.intSetting("Universal Biomes Stairs ID:", 212);
     public final Mutable<Integer> stoneWallID = this.blockCategory.intSetting("Universal Biomes Wall ID:", 213);
     public final Mutable<Integer> stoneButtonID = this.blockCategory.intSetting("Universal Biomes Button ID:", 214);
+
+    private final HashMap<NamedBlock,HashMap<Integer,Mutable<Boolean>>> stoneGenerationSettings =
+            new HashMap<NamedBlock,HashMap<Integer,Mutable<Boolean>>>();
+
+    public final boolean generationAllowed(NamedBlock block, int metadata) {
+        HashMap<Integer,Mutable<Boolean>> info = stoneGenerationSettings.get(block);
+        if (info == null) return true;
+        return info.get(metadata).value();
+    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/client/RenderUBOre.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/client/RenderUBOre.java
index 95deb19..8320660 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/client/RenderUBOre.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/client/RenderUBOre.java
@@ -60,10 +61,14 @@ public class RenderUBOre implements ISimpleBlockRenderingHandler {
         int j = y;
         int k = z;
         Block renderedBlock = world.getBlock(x, y, z);
+        IIcon overlayTexture = renderer.overrideBlockTexture;
         IIcon self = ubifier.baseStone(renderedBlock).getIcon(0, metadata);
         renderer.renderBlockUsingTexture(ubifier.baseStone(renderedBlock), x, y, z, self);
         IIcon overlay = ubifier.overlayBlock(renderedBlock).getIcon(0, 0);
         renderer.renderBlockUsingTexture(ubifier.overlayBlock(renderedBlock), x, y, z, overlay);
+        if (overlayTexture != null) {
+            renderer.renderBlockUsingTexture(ubifier.baseStone(renderedBlock), x, y, z, overlayTexture);
+        }
 
         return true;
     }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/DimensionManager.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/DimensionManager.java
index 966e318..8cf34e1 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/DimensionManager.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/DimensionManager.java
@@ -1,6 +1,7 @@
 package exterminatorJeff.undergroundBiomes.common;
 
 import Zeno410Utils.Acceptor;
+import exterminatorJeff.undergroundBiomes.api.UndergroundBiomeSetProvider;
 import exterminatorJeff.undergroundBiomes.api.UndergroundBiomesSettings;
 import java.util.ArrayList;
 import java.util.Map;
@@ -8,9 +9,7 @@ import java.util.HashMap;
 import java.util.List;
 
 import net.minecraft.server.MinecraftServer;
-import net.minecraftforge.common.config.Configuration;
 import net.minecraftforge.event.terraingen.DecorateBiomeEvent;
-import net.minecraftforge.event.world.WorldEvent;
 
 
 import net.minecraftforge.event.terraingen.BiomeEvent.GetVillageBlockID;
@@ -28,8 +27,11 @@ import exterminatorJeff.undergroundBiomes.constructs.util.Consumable;
 import exterminatorJeff.undergroundBiomes.constructs.util.DimensionSet;
 import Zeno410Utils.Zeno410Logger;
 
+import cpw.mods.fml.common.IWorldGenerator;
+import exterminatorJeff.undergroundBiomes.api.UBSetProviderRegistry;
 import exterminatorJeff.undergroundBiomes.worldGen.OreUBifier;
-import exterminatorJeff.undergroundBiomes.worldGen.UndergroundBiomeSet;
+import exterminatorJeff.undergroundBiomes.worldGen.StandardUndergroundBiomeSet;
+import exterminatorJeff.undergroundBiomes.api.UndergroundBiomeSet;
 import java.util.logging.Logger;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
@@ -38,7 +40,7 @@ import net.minecraftforge.event.terraingen.PopulateChunkEvent;
  *
  * @author Zeno410
  */
-public class DimensionManager {
+public class DimensionManager implements UBSetProviderRegistry{
 
     public static Logger logger = new Zeno410Logger("DimensionManager").logger();
 
@@ -73,12 +75,25 @@ public class DimensionManager {
     private List<Integer> inChunkDimensionIDs = new ArrayList<Integer>();
 
     private UndergroundBiomeSet cachedBiomeSet;
-    private UndergroundBiomeSet biomeSet() {
-        if (cachedBiomeSet == null) cachedBiomeSet = new UndergroundBiomeSet();
-        return cachedBiomeSet;
+    private HashMap<Integer,UndergroundBiomeSet> dimensionalBiomeSets = new HashMap<Integer,UndergroundBiomeSet>();
+    private UndergroundBiomeSet biomeSet(int dimension) {
+        UndergroundBiomeSet result = dimensionalBiomeSets.get(dimension);
+        // set result to default if necessary
+        if (result == null) {
+            if (cachedBiomeSet == null) cachedBiomeSet = new StandardUndergroundBiomeSet(settings);
+            result = cachedBiomeSet;
+        }
+        // call the set providers to allow changes
+        for (UndergroundBiomeSetProvider provider: this.ubSetProviders) {
+            UndergroundBiomeSet changedResult =
+                    provider.modifiedBiomeSet(dimension, dimensionSeed(dimension), result);
+            if (changedResult != null) result = changedResult;
+        }
+        return result;
     }
 
     private final OreUBifier oreUBifier;
+    private final UndergroundBiomesSettings settings;
 
     private WorldGenManager villageWorldGenManager;  // has to be cached because not availabe for block call
 
@@ -91,13 +106,19 @@ public class DimensionManager {
         if (result == null) {
             // hasn't been made yet; make and store it
             oreUBifier.renewBlockReplacers();
-            result = new WorldGenManager(dimensionSeed(dimension),dimension,oreUBifier,biomeSet()); //TODO: Exception here.
+            result = new WorldGenManager(
+                    dimensionSeed(dimension),
+                    dimension,
+                    oreUBifier,
+                    biomeSet(dimension),
+                    ubGenerationAllowed(dimension));
             worldGenManagers.put(dimension, result);
         }
         return result;
     }
 
     public DimensionManager(UndergroundBiomesSettings settings,OreUBifier oreUBifier) {
+        this.settings = settings;
         dimensionSpecificSeeds = settings.dimensionSpecificSeeds.value();
 
         inChunkGeneration = settings.inChunkGeneration.value();
@@ -136,7 +157,7 @@ public class DimensionManager {
         // Sometimes can get called before onWorldLoad, wtf?
         WorldGenManager worldGen = worldGenManager(id);
         if (worldGen == null) {
-            UndergroundBiomes.logger.warn("UndergroundBiomes warning: onBiomeDecorate before onWorldLoad! Ignoring.");
+            System.out.println("UndergroundBiomes warning: onBiomeDecorate before onWorldLoad! Ignoring.");
             return;
         }
         //logger.info("decorating dimension "+ id );
@@ -149,10 +170,38 @@ public class DimensionManager {
         }
     }
 
+    public void onBiomeDecorate(PopulateChunkEvent.Post event)    {
+        // this is the method to change stones if inChunkGeneration is off
+        // onWorldLoad modifies existing ChunkProviderGenerator if it is on
+
+        //skip if UB is off
+        if (UndergroundBiomes.instance().settings().ubActive.value() == false) return;
+        int id = event.world.provider.dimensionId;
+
+
+        // do nothing if we're not supposed to UB this dimension
+        if (!includeDimensionIDs.isIncluded(id, excludeDimensionIDs)) return;
+
+        // Sometimes can get called before onWorldLoad, wtf?
+        WorldGenManager worldGen = worldGenManager(id);
+        if (worldGen == null) {
+            System.out.println("UndergroundBiomes warning: onBiomeDecorate before onWorldLoad! Ignoring.");
+            return;
+        }
+        //logger.info("decorating dimension "+ id );
+
+                // do nothing if being handled by in-chunk method
+        if (inChunkDimensionIDs.contains(id)) {
+            worldGen.decorateIfNeeded(event);
+        } else {
+            worldGen.onBiomeDecorate(event);
+        }
+    }
 
-    public void setupGenerators(WorldEvent.Load event) {
+    public void setupGenerators() {
 
         int id;
+        if (UndergroundBiomes.instance().settings().ubActive.value() == false) return;
         try {
             MinecraftServer server = MinecraftServer.getServer();
             if (server == null) return;
@@ -196,7 +245,8 @@ public class DimensionManager {
         inChunkDimensionIDs = new ArrayList<Integer>();
         serverAdjusted = false;
         worldGenManagers = new HashMap<Integer,WorldGenManager>();
-        cachedBiomeSet = null;
+        this.ubSetProviders = new ArrayList<UndergroundBiomeSetProvider>();
+        this.cachedBiomeSet = null;
     }
 
     public boolean inChunkGenerationAllowed(int id) {
@@ -211,10 +261,19 @@ public class DimensionManager {
         return true;
     }
 
+    public boolean ubGenerationAllowed(int id) {
+
+        // no if we're not supposed to UB this dimension
+        if (!includeDimensionIDs.isIncluded(id, excludeDimensionIDs)) return false;
+
+        return true;
+    }
+
     // this is not affected by whether inChunkGeneration is on
     @SubscribeEvent
     public void preBiomeDecorate(DecorateBiomeEvent.Pre event) {
         // this currently just saves the filler block to the VillageStoneChanger
+        if (UndergroundBiomes.instance().settings().ubActive.value() == false) return;
         int id = event.world.provider.dimensionId;
         villageWorldGenManager = worldGenManager(id);
         if (UndergroundBiomes.instance().gotWorldSeed()) {
@@ -225,6 +284,7 @@ public class DimensionManager {
     @SubscribeEvent
     public void prePopulateChunk(PopulateChunkEvent.Pre event) {
         // this currently just saves the filler block to the VillageStoneChanger
+        if (UndergroundBiomes.instance().settings().ubActive.value() == false) return;
         int id = event.world.provider.dimensionId;
         villageWorldGenManager = worldGenManager(id);
         if (UndergroundBiomes.instance().gotWorldSeed()) {
@@ -234,16 +294,25 @@ public class DimensionManager {
 
     @SubscribeEvent
     public void onVillageSelectBlock(GetVillageBlockID e){
+        if (UndergroundBiomes.instance().settings().ubActive.value() == false) return;
         if (villageWorldGenManager == null) return;
         if (UndergroundBiomes.instance().gotWorldSeed()) villageWorldGenManager.onVillageSelectBlock(e);
     }
 
     @SubscribeEvent
     public void onVillageSelectMeta(GetVillageBlockMeta e){
+        if (UndergroundBiomes.instance().settings().ubActive.value() == false) return;
         if (villageWorldGenManager == null) return;
         if (UndergroundBiomes.instance().gotWorldSeed()) villageWorldGenManager.onVillageSelectMeta(e);
     }
 
+    private ArrayList<UndergroundBiomeSetProvider> ubSetProviders =
+            new ArrayList<UndergroundBiomeSetProvider>();
+
+    public void register(UndergroundBiomeSetProvider toRegister) {
+        ubSetProviders.add(toRegister);
+    }
+
     private class StrataColumnProvider implements UBDimensionalStrataColumnProvider {
         public UBStrataColumnProvider ubStrataColumnProvider(int dimension) {
             return new UBBlockProvider(worldGenManager(dimension));
@@ -251,9 +320,13 @@ public class DimensionManager {
     }
 
     public void redoOres(int x, int z, World world) {
+        if (UndergroundBiomes.instance().settings().ubActive.value() == false) return;
+        if (UndergroundBiomes.instance().settings().ubOres.value() == false) return;
         WorldGenManager worldGenManager = worldGenManagers.get(world.provider.dimensionId);
         if (worldGenManager != null) {
-            worldGenManager.redoOres(x, z, world);
+            if (this.ubGenerationAllowed(worldGenManager.dimension)) {
+                worldGenManager.redoOres(x, z, world);
+            }
         } else UndergroundBiomes.logger.info("no manager for "+world.toString());
     }
 
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/NoiseGenerator.java E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/NoiseGenerator.java
deleted file mode 100644
index 81ab7dd..0000000
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/NoiseGenerator.java
+++ /dev/null
@@ -1,170 +0,0 @@
-package exterminatorJeff.undergroundBiomes.common;
-
-/**
- * Base class for all noise generators
- */
-public abstract class NoiseGenerator {
-    protected final int perm[] = new int[512];
-    protected double offsetX;
-    protected double offsetY;
-    protected double offsetZ;
-
-    /**
-     * Speedy floor, faster than (int)Math.floor(x)
-     *
-     * @param x Value to floor
-     * @return Floored value
-     */
-    public static int floor(double x) {
-        return x >= 0 ? (int) x : (int) x - 1;
-    }
-
-    protected static double fade(double x) {
-        return x * x * x * (x * (x * 6 - 15) + 10);
-    }
-
-    protected static double lerp(double x, double y, double z) {
-        return y + x * (z - y);
-    }
-
-    protected static double grad(int hash, double x, double y, double z) {
-        hash &= 15;
-        double u = hash < 8 ? x : y;
-        double v = hash < 4 ? y : hash == 12 || hash == 14 ? x : z;
-        return ((hash & 1) == 0 ? u : -u) + ((hash & 2) == 0 ? v : -v);
-    }
-
-    /**
-     * Computes and returns the 1D noise for the given coordinate in 1D space
-     *
-     * @param x X coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public double noise(double x) {
-        return noise(x, 0, 0);
-    }
-
-    /**
-     * Computes and returns the 2D noise for the given coordinates in 2D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public double noise(double x, double y) {
-        return noise(x, y, 0);
-    }
-
-    /**
-     * Computes and returns the 3D noise for the given coordinates in 3D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public abstract double noise(double x, double y, double z);
-
-    /**
-     * Generates noise for the 1D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, int octaves, double frequency, double amplitude) {
-        return noise(x, 0, 0, octaves, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 1D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, int octaves, double frequency, double amplitude, boolean normalized) {
-        return noise(x, 0, 0, octaves, frequency, amplitude, normalized);
-    }
-
-    /**
-     * Generates noise for the 2D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, int octaves, double frequency, double amplitude) {
-        return noise(x, y, 0, octaves, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 2D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, int octaves, double frequency, double amplitude, boolean normalized) {
-        return noise(x, y, 0, octaves, frequency, amplitude, normalized);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double z, int octaves, double frequency, double amplitude) {
-        return noise(x, y, z, octaves, frequency, amplitude, false);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @param normalized If true, normalize the value to [-1, 1]
-     * @return Resulting noise
-     */
-    public double noise(double x, double y, double z, int octaves, double frequency, double amplitude, boolean normalized) {
-        double result = 0;
-        double amp = 1;
-        double freq = 1;
-        double max = 0;
-
-        for (int i = 0; i < octaves; i++) {
-            result += noise(x * freq, y * freq, z * freq) * amp;
-            max += amp;
-            freq *= frequency;
-            amp *= amplitude;
-        }
-
-        if (normalized) {
-            result /= max;
-        }
-
-        return result;
-    }
-}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/OreUBifyRequester.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/OreUBifyRequester.java
index 64a47f1..7be95dc 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/OreUBifyRequester.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/OreUBifyRequester.java
@@ -1,6 +1,9 @@
+
 package exterminatorJeff.undergroundBiomes.common;
 
+import Zeno410Utils.MinecraftName;
 import Zeno410Utils.Zeno410Logger;
+import com.teammetallurgy.metallurgy.metals.MetalBlock;
 import cpw.mods.fml.common.event.FMLPreInitializationEvent;
 import exterminatorJeff.undergroundBiomes.api.UBAPIHook;
 import exterminatorJeff.undergroundBiomes.api.UBOreTexturizer;
@@ -17,113 +18,129 @@ import net.minecraft.world.World;
  */
 public class OreUBifyRequester implements UBOreTexturizer {
 
-	private static Logger logger = new Zeno410Logger("OrUBifyRequester").logger();
-	private HashSet<UBifyRequest> waitingRequests = new HashSet<UBifyRequest>();
-	private boolean alreadyRun = false;
-	
-	OreUBifyRequester() {
-		UBAPIHook.ubAPIHook.ubOreTexturizer = this;
-	}
-	
-	@Override
-	@Deprecated
-	public void setupUBOre(Block oreBlock, int metadata, String overlayName, FMLPreInitializationEvent notUsed) {
-		logger.info("setup attempt");
-		assert (oreBlock != null);
-		assert (metadata >= 0);
-		assert (metadata < 16);
-		assert (overlayName != null);
-		UndergroundBiomes.instance().oreUBifier().setupUBOre(oreBlock, overlayName, metadata);
-	}
-	
-	@Override
-	@Deprecated
-	public void requestUBOreSetup(Block oreBlock, int metadata, String overlayName) throws BlocksAreAlreadySet {
-		logger.info("setup request for " + oreBlock.getLocalizedName());
-		assert (oreBlock != null);
-		assert (metadata >= 0);
-		assert (metadata < 16);
-		assert (overlayName != null);
-		logger.info("request OK");
-		waitingRequests.add(new UBifyRequestWithMetadata(oreBlock, metadata, overlayName));
-	}
-	
-	@Override
-	public void setupUBOre(Block oreBlock, int metadata, String overlayName, String blockName, FMLPreInitializationEvent notUsed) {
-		setupUBOre(oreBlock, metadata, overlayName);
-	}
-	
-	private void setupUBOre(Block oreBlock, int metadata, String overlayName) {
-		UndergroundBiomes.instance().oreUBifier().setupUBOre(oreBlock, overlayName, metadata);
-	}
-	
-	@Override
-	public void requestUBOreSetup(Block oreBlock, int metadata, String overlayName, String blockName) throws BlocksAreAlreadySet {
-		logger.info("setup request for " + oreBlock.getLocalizedName());
-		assert (oreBlock != null);
-		assert (metadata >= 0);
-		assert (metadata < 16);
-		assert (overlayName != null);
-		logger.info("request OK");
-		waitingRequests.add(new UBifyRequestWithMetadata(oreBlock, metadata, overlayName));
-	}
-	
-	private class UBifyRequest {
-		final Block ore;
-		final String overlayName;
-		
-		UBifyRequest(Block ore, String overlayName) {
-			this.ore = ore;
-			this.overlayName = overlayName;
-		}
-		
-		void fulfill(FMLPreInitializationEvent event) {
-			setupUBOre(ore, overlayName, event);
-		}
-	}
-	
-	private class UBifyRequestWithMetadata extends UBifyRequest {
-		final int metadata;
-		
-		UBifyRequestWithMetadata(Block ore, int metadata, String overlayName) {
-			super(ore, overlayName);
-			this.metadata = metadata;
-		}
-		
-		@Override
-		void fulfill(FMLPreInitializationEvent event) {
-			setupUBOre(ore, metadata, overlayName);
-		}
-	}
-	
-	@Override
-	public void setupUBOre(Block oreBlock, String overlayName, FMLPreInitializationEvent event) {
-		UndergroundBiomes.instance().oreUBifier().setupUBOre(oreBlock, overlayName, event);
-	}
-	
-	@Override
-	public void requestUBOreSetup(Block oreBlock, String overlayName) throws BlocksAreAlreadySet {
-		if (alreadyRun) {
-			BlocksAreAlreadySet error = new BlocksAreAlreadySet(oreBlock, overlayName);
-			if (UndergroundBiomes.crashOnProblems())
-				throw error;
-			UndergroundBiomes.logger.error(error.toString());
-		} else {
-			waitingRequests.add(new UBifyRequest(oreBlock, overlayName));
-		}
-	}
-	
-	void fulfillRequests(FMLPreInitializationEvent event) {
-		// this should not be run by anyting other than the Underground Biomes Constructs object
-		alreadyRun = true;
-		for (UBifyRequest request : waitingRequests) {
-			request.fulfill(event);
-		}
-		waitingRequests.clear();
-	}
-	
-	@Override
-	public void redoOres(int x, int z, World world) {
-		UndergroundBiomes.instance().redoOres(x, z, world);
-	}
+    private static  Logger logger = new Zeno410Logger("OrUBifyRequester").logger();
+    private HashSet<UBifyRequest> waitingRequests = new HashSet<UBifyRequest>();
+    private boolean alreadyRun = false;
+
+    OreUBifyRequester() {
+        UBAPIHook.ubAPIHook.ubOreTexturizer = this;
+    }
+
+    @Deprecated
+    public void setupUBOre(Block oreBlock, int metadata, String overlayName, FMLPreInitializationEvent event) {
+        logger.info("setup attempt");
+        assert(oreBlock != null);
+        assert(metadata >=0);
+        assert(metadata < 16);
+        assert(overlayName != null);
+        UndergroundBiomes.instance().oreUBifier().setupUBOre(oreBlock, overlayName, metadata,minecraftName(oreBlock,metadata),event);
+    }
+
+    @Deprecated
+    public void requestUBOreSetup(Block oreBlock, int metadata, String overlayName) throws BlocksAreAlreadySet {
+        logger.info("setup request for "+oreBlock.getLocalizedName()+ " "+overlayName);
+        assert(oreBlock != null);
+        assert(metadata >=0);
+        assert(metadata < 16);
+        assert(overlayName != null);
+        logger.info("request OK");
+        waitingRequests.add(new UBifyRequestWithMetadata(oreBlock,metadata,overlayName));
+    }
+
+    public void setupUBOre(Block oreBlock, int metadata, String overlayName, String blockName, FMLPreInitializationEvent event) {
+        setupUBOre(oreBlock, metadata, overlayName, new MinecraftName(blockName), event);
+    }
+
+    private void setupUBOre(Block oreBlock, int metadata, String overlayName, MinecraftName blockName, FMLPreInitializationEvent event) {
+        UndergroundBiomes.instance().oreUBifier().setupUBOre(oreBlock, overlayName, metadata, blockName, event);
+    }
+
+    public void requestUBOreSetup(Block oreBlock, int metadata, String overlayName, String blockName) throws BlocksAreAlreadySet {
+        logger.info("setup request for "+oreBlock.getLocalizedName()+ " : "+blockName + " " + overlayName);
+        assert(oreBlock != null);
+        assert(metadata >=0);
+        assert(metadata < 16);
+        assert(overlayName != null);
+        MinecraftName properName = new MinecraftName(blockName);
+        if (!properName.legit()) {
+            properName = minecraftName(oreBlock, metadata);
+            if (!properName.legit()) {
+                new MinecraftName(blockName);
+                logger.info(blockName +" not found in the language tables");
+            }
+        }
+        logger.info("request OK");
+        waitingRequests.add(new UBifyRequestWithMetadata(oreBlock,metadata,overlayName,properName));
+    }
+    
+    private class UBifyRequest {
+        final Block ore;
+        final String overlayName;
+        UBifyRequest(Block ore, String overlayName) {
+            this.ore = ore;
+            this.overlayName = overlayName;
+        }
+        void fulfill(FMLPreInitializationEvent event) {
+            setupUBOre(ore,overlayName,event);
+        }
+    }
+
+    private class UBifyRequestWithMetadata extends UBifyRequest {
+        final int metadata;
+        final MinecraftName name;
+        UBifyRequestWithMetadata(Block ore, int metadata, String overlayName, MinecraftName name){
+            super(ore,overlayName);
+            this.metadata = metadata;
+            this.name = name;
+        }
+
+
+        UBifyRequestWithMetadata(Block ore, int metadata, String overlayName){
+            this(ore,metadata,overlayName,minecraftName(ore,metadata));
+        }
+
+        @Override
+        void fulfill(FMLPreInitializationEvent event) {
+            setupUBOre(ore,metadata,overlayName,name,event);
+        }
+    }
+    
+    public void setupUBOre(Block oreBlock, String overlayName, FMLPreInitializationEvent event) {
+        UndergroundBiomes.instance().oreUBifier().setupUBOre(oreBlock, overlayName, event);
+    }
+
+
+    public void requestUBOreSetup(Block oreBlock, String overlayName) throws BlocksAreAlreadySet {
+        if (alreadyRun) {
+            BlocksAreAlreadySet error = new BlocksAreAlreadySet(oreBlock,overlayName);
+            if (UndergroundBiomes.crashOnProblems())throw error;
+            UndergroundBiomes.logger.severe(error.toString());
+        } else {
+             waitingRequests.add(new UBifyRequest(oreBlock,overlayName));
+        }
+    }
+
+    void fulfillRequests(FMLPreInitializationEvent event) {
+        // this should not be run by anyting other than the Underground Biomes Constructs object
+        alreadyRun = true;
+        for (UBifyRequest request: waitingRequests) {
+            request.fulfill(event);
+        }
+        waitingRequests.clear();
+    }
+
+    public void redoOres(int x, int z, World world) {
+        UndergroundBiomes.instance().redoOres(x, z, world);
+    }
+
+    private static MinecraftName minecraftName(Block block, int meta) {
+        if (block instanceof MetalBlock) {
+            logger.info(((MetalBlock)block).getUnlocalizedName(meta) + " " + meta);
+            logger.info(((MetalBlock)block).getUnlocalizedName(0) + " " + 0);
+            logger.info(((MetalBlock)block).getUnlocalizedName(1) + " " + 1);
+            logger.info(((MetalBlock)block).getUnlocalizedName(2) + " " + 2);
+            return new MinecraftName(((MetalBlock)block).getUnlocalizedName(meta));
+        }
+        return new MinecraftName(block.getUnlocalizedName());
+    }
 }
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/PerlinNoiseGenerator.java E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/PerlinNoiseGenerator.java
deleted file mode 100644
index 74ca1b7..0000000
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/PerlinNoiseGenerator.java
+++ /dev/null
@@ -1,201 +0,0 @@
-package exterminatorJeff.undergroundBiomes.common;
-
-
-import java.util.Random;
-
-/**
- * Generates noise using the "classic" perlin generator
- *
- * @see SimplexNoiseGenerator "Improved" and faster version with slighly different results
- */
-public class PerlinNoiseGenerator extends NoiseGenerator {
-    protected static final int grad3[][] = {{1, 1, 0}, {-1, 1, 0}, {1, -1, 0}, {-1, -1, 0},
-        {1, 0, 1}, {-1, 0, 1}, {1, 0, -1}, {-1, 0, -1},
-        {0, 1, 1}, {0, -1, 1}, {0, 1, -1}, {0, -1, -1}};
-    private static final PerlinNoiseGenerator instance = new PerlinNoiseGenerator();
-
-    protected PerlinNoiseGenerator() {
-        int p[] = {151, 160, 137, 91, 90, 15, 131, 13, 201,
-            95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37,
-            240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62,
-            94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56,
-            87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139,
-            48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133,
-            230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25,
-            63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200,
-            196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3,
-            64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255,
-            82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42,
-            223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153,
-            101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79,
-            113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242,
-            193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249,
-            14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204,
-            176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222,
-            114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180};
-
-        for (int i = 0; i < 512; i++) {
-            perm[i] = p[i & 255];
-        }
-    }
-
-    /**
-     * Creates a seeded perlin noise generator for the given seed
-     *
-     * @param seed Seed to construct this generator for
-     */
-    public PerlinNoiseGenerator(long seed) {
-        this(new Random(seed));
-    }
-
-    /**
-     * Creates a seeded perlin noise generator with the given Random
-     *
-     * @param rand Random to construct with
-     */
-    public PerlinNoiseGenerator(Random rand) {
-        offsetX = rand.nextDouble() * 256;
-        offsetY = rand.nextDouble() * 256;
-        offsetZ = rand.nextDouble() * 256;
-
-        for (int i = 0; i < 256; i++) {
-            perm[i] = rand.nextInt(256);
-        }
-
-        for (int i = 0; i < 256; i++) {
-            int pos = rand.nextInt(256 - i) + i;
-            int old = perm[i];
-
-            perm[i] = perm[pos];
-            perm[pos] = old;
-            perm[i + 256] = perm[i];
-        }
-    }
-
-    /**
-     * Computes and returns the 1D unseeded perlin noise for the given coordinates in 1D space
-     *
-     * @param x X coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double x) {
-        return instance.noise(x);
-    }
-
-    /**
-     * Computes and returns the 2D unseeded perlin noise for the given coordinates in 2D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double x, double y) {
-        return instance.noise(x, y);
-    }
-
-    /**
-     * Computes and returns the 3D unseeded perlin noise for the given coordinates in 3D space
-     *
-     * @param x X coordinate
-     * @param y Y coordinate
-     * @param z Z coordinate
-     * @return Noise at given location, from range -1 to 1
-     */
-    public static double getNoise(double x, double y, double z) {
-        return instance.noise(x, y, z);
-    }
-
-    /**
-     * Gets the singleton unseeded instance of this generator
-     *
-     * @return Singleton
-     */
-    public static PerlinNoiseGenerator getInstance() {
-        return instance;
-    }
-
-    @Override
-    public double noise(double x, double y, double z) {
-        x += offsetX;
-        y += offsetY;
-        z += offsetZ;
-
-        int floorX = floor(x);
-        int floorY = floor(y);
-        int floorZ = floor(z);
-
-        // Find unit cube containing the point
-        int X = floorX & 255;
-        int Y = floorY & 255;
-        int Z = floorZ & 255;
-
-        // Get relative xyz coordinates of the point within the cube
-        x -= floorX;
-        y -= floorY;
-        z -= floorZ;
-
-        // Compute fade curves for xyz
-        double fX = fade(x);
-        double fY = fade(y);
-        double fZ = fade(z);
-
-        // Hash coordinates of the cube corners
-        int A = perm[X] + Y;
-        int AA = perm[A] + Z;
-        int AB = perm[A + 1] + Z;
-        int B = perm[X + 1] + Y;
-        int BA = perm[B] + Z;
-        int BB = perm[B + 1] + Z;
-
-        return lerp(fZ, lerp(fY, lerp(fX, grad(perm[AA], x, y, z),
-                        grad(perm[BA], x - 1, y, z)),
-                    lerp(fX, grad(perm[AB], x, y - 1, z),
-                        grad(perm[BB], x - 1, y - 1, z))),
-                lerp(fY, lerp(fX, grad(perm[AA + 1], x, y, z - 1),
-                        grad(perm[BA + 1], x - 1, y, z - 1)),
-                    lerp(fX, grad(perm[AB + 1], x, y - 1, z - 1),
-                        grad(perm[BB + 1], x - 1, y - 1, z - 1))));
-    }
-
-    /**
-     * Generates noise for the 1D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public static double getNoise(double x, int octaves, double frequency, double amplitude) {
-        return instance.noise(x, octaves, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 2D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public static double getNoise(double x, double y, int octaves, double frequency, double amplitude) {
-        return instance.noise(x, y, octaves, frequency, amplitude);
-    }
-
-    /**
-     * Generates noise for the 3D coordinates using the specified number of octaves and parameters
-     *
-     * @param x X-coordinate
-     * @param y Y-coordinate
-     * @param z Z-coordinate
-     * @param octaves Number of octaves to use
-     * @param frequency How much to alter the frequency by each octave
-     * @param amplitude How much to alter the amplitude by each octave
-     * @return Resulting noise
-     */
-    public static double getNoise(double x, double y, double z, int octaves, double frequency, double amplitude) {
-        return instance.noise(x, y, z, octaves, frequency, amplitude);
-    }
-}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/UBiomeCache.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/UBiomeCache.java
index 483bcd8..a4a1708 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/UBiomeCache.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/UBiomeCache.java
@@ -4,7 +4,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import net.minecraft.util.LongHashMap;
-import exterminatorJeff.undergroundBiomes.worldGen.BiomeGenUndergroundBase;
+import exterminatorJeff.undergroundBiomes.api.BiomeGenUndergroundBase;
 import exterminatorJeff.undergroundBiomes.worldGen.BiomeUndergroundCacheBlock;
 
 public class UBiomeCache{
@@ -19,8 +19,11 @@ public class UBiomeCache{
     
     public BiomeUndergroundCacheBlock getUndergroundBiomeCacheBlock(int par1, int par2)
     {
-        par1 >>= 4;
-        par2 >>= 4;
+
+        // this used to downshift to chunk coordinates. But it wasn't always called with chunk coordinates///
+        // so I took that out.
+        //par1 >>= 4;
+        //par2 >>= 4;
         long var3 = (long)par1 & 4294967295L | ((long)par2 & 4294967295L) << 32;
         BiomeUndergroundCacheBlock var5 = (BiomeUndergroundCacheBlock)this.undergroundCacheMap.getValueByKey(var3);
 
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/UndergroundBiomes.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/UndergroundBiomes.java
index 7b6c8ea..e7cb8c7 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/UndergroundBiomes.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/UndergroundBiomes.java
@@ -60,28 +58,37 @@ import Zeno410Utils.Acceptor;
 import Zeno410Utils.ConfigManager;
 import Zeno410Utils.PlayerDetector;
 import exterminatorJeff.undergroundBiomes.constructs.util.WatchList;
+
+import Zeno410Utils.Zeno410Logger;
+import cpw.mods.fml.common.IWorldGenerator;
 import cpw.mods.fml.common.eventhandler.EventPriority;
 import cpw.mods.fml.common.registry.GameData;
+import exterminatorJeff.undergroundBiomes.client.RenderUBOre;
+import exterminatorJeff.undergroundBiomes.intermod.ModOreManager;
 import exterminatorJeff.undergroundBiomes.network.PacketPipeline;
 import exterminatorJeff.undergroundBiomes.worldGen.BiomeUndergroundDecorator;
 import exterminatorJeff.undergroundBiomes.worldGen.OreUBifier;
-
 import java.io.File;
-
+import java.util.Random;
+import java.util.logging.Logger;
 import net.minecraft.block.Block;
 import net.minecraft.entity.player.EntityPlayerMP;
 import net.minecraft.init.Blocks;
 import net.minecraft.world.WorldServer;
+
+import net.minecraft.world.chunk.IChunkProvider;
 import net.minecraftforge.event.terraingen.OreGenEvent;
+import net.minecraftforge.event.terraingen.PopulateChunkEvent;
+import static java.lang.annotation.ElementType.*;
 
-@Mod(modid = "UndergroundBiomes", name = "Underground Biomes", version = "0.6h")
+@Mod(modid = "UndergroundBiomes", name = "Underground Biomes", version = "0.8.beta57")
 
-public class UndergroundBiomes{
+public class UndergroundBiomes implements IWorldGenerator{
     
     public UndergroundBiomes() {
         instance = this;
     }
-    public static org.apache.logging.log4j.Logger logger;
+    public static Logger logger = new Zeno410Logger("UndergroundBiomes").logger();
     private static UndergroundBiomes instance;
     public static UndergroundBiomes instance() {return instance;}
     public static World world;
@@ -90,7 +97,7 @@ public class UndergroundBiomes{
 
     private DimensionManager dimensionManager;
 
-    private WatchList defaultIDSetter;
+    //private WatchList defaultIDSetter;
     private boolean runningConfigIDs = false;
     
     public static String textures = "/exterminatorJeff/undergroundBiomes/textures.png";
@@ -156,7 +163,15 @@ public class UndergroundBiomes{
     private int sedimentaryStoneSlabHalfID() {return instance().settings.sedimentaryStoneSlabHalfID.value();}
     private int sedimentaryStoneSlabFullID() {return instance().settings.sedimentaryStoneSlabFullID.value();}
 
-    public final UBCodeLocations ubCodeLocations = new UBCodeLocations();
+    private final UBCodeLocations serverCodeLocations = new UBCodeLocations();
+    private final UBCodeLocations clientCodeLocations = new UBCodeLocations();
+    public final UBCodeLocations ubCodeLocations(World world) {
+        if (world.isRemote) {
+            return clientCodeLocations;
+        } else {
+            return serverCodeLocations;
+        }
+    }
 
     private List<Integer> includeDimensionIDs;
     private List<Integer> excludeDimensionIDs;
@@ -177,7 +192,8 @@ public class UndergroundBiomes{
     public final static int generateHeight() {return instance().settings.generateHeight.value();}
 
     public UndergroundBiomesConstructs constructs;
-    private UndergroundBiomesSettings settings = new UndergroundBiomesSettings();
+    private UndergroundBiomesSettings settings = new UndergroundBiomesSettings(
+            BlockIgneousStone.blockName,BlockMetamorphicStone.blockName,BlockSedimentaryStone.blockName);
     public UndergroundBiomesSettings settings() {return settings;}
     private ConfigManager<UndergroundBiomesSettings> configManager;
 
@@ -221,6 +237,7 @@ public class UndergroundBiomes{
     OreUBifier oreUBifier() {return oreUBifier;}
     public int ubOreRenderID() {return oreUBifier.getRenderID();}
     private OreUBifyRequester oreRequester = new OreUBifyRequester();
+    private ModOreManager modOreManager = new ModOreManager();
 
     private VanillaStoneRecipeManager vanillaStoneRecipeManager = new VanillaStoneRecipeManager(oreCobblestoneName());
     
@@ -228,10 +245,10 @@ public class UndergroundBiomes{
     private PlayerDetector playerDetector;
     private UndergroundBiomesNetworking networking;
 
-	@EventHandler
+    @EventHandler
     public void preInit(FMLPreInitializationEvent event) {
-		logger = event.getModLog();
-        if (UBIDs.version != 3) throw new RuntimeException("Another mod has included an obsolete version of the Underground Biomes API. Underground Biomes Constructs cannot run.");
+        if (UBIDs.version != 3) throw new RuntimeException("" +
+                "Another mod has included an obsolete version of the Underground Biomes API. Underground Biomes Constructs cannot run.");
         config = new Configuration(event.getSuggestedConfigurationFile());
         config.load();
 
@@ -258,6 +275,7 @@ public class UndergroundBiomes{
 
         oreUBifier = new OreUBifier(settings.ubOres);
         dimensionManager = new DimensionManager(settings,oreUBifier);
+        UBAPIHook.ubAPIHook.ubSetProviderRegistry = dimensionManager;
         
         config.save();
 
@@ -294,19 +312,19 @@ public class UndergroundBiomes{
         sedimentaryStone = new BlockSedimentaryStone();
         UBIDs.sedimentaryStoneName.gameRegister(sedimentaryStone,ItemMetadataBlock.class);
 
-        igneousBrickSlab = stoneSlabPair(igneousStoneBrick,UBIDs.igneousBrickSlabName, "slabStoneBricks");
+        igneousBrickSlab = stoneSlabPair(igneousStoneBrick,UBIDs.igneousBrickSlabName);
 
-        metamorphicBrickSlab = stoneSlabPair(metamorphicStoneBrick,UBIDs.metamorphicBrickSlabName, "slabStoneBricks");
+        metamorphicBrickSlab = stoneSlabPair(metamorphicStoneBrick,UBIDs.metamorphicBrickSlabName);
         
-        igneousStoneSlab = stoneSlabPair(igneousStone,UBIDs.igneousStoneSlabName, "slabStone");
+        igneousStoneSlab = stoneSlabPair(igneousStone,UBIDs.igneousStoneSlabName);
 
-        metamorphicStoneSlab = stoneSlabPair(metamorphicStone,UBIDs.metamorphicStoneSlabName, "slabStone");
+        metamorphicStoneSlab = stoneSlabPair(metamorphicStone,UBIDs.metamorphicStoneSlabName);
 
-        igneousCobblestoneSlab = stoneSlabPair(igneousCobblestone,UBIDs.igneousCobblestoneSlabName, "slabCobblestone");
+        igneousCobblestoneSlab = stoneSlabPair(igneousCobblestone,UBIDs.igneousCobblestoneSlabName);
 
-        metamorphicCobblestoneSlab = stoneSlabPair(metamorphicCobblestone,UBIDs.metamorphicCobblestoneSlabName, "slabCobblestone");
+        metamorphicCobblestoneSlab = stoneSlabPair(metamorphicCobblestone,UBIDs.metamorphicCobblestoneSlabName);
         
-        sedimentaryStoneSlab = stoneSlabPair(sedimentaryStone,UBIDs.sedimentaryStoneSlabName, "slabStone");
+        sedimentaryStoneSlab = stoneSlabPair(sedimentaryStone,UBIDs.sedimentaryStoneSlabName);
         //items
 
         ligniteCoal = new ItemLigniteCoal(ligniteCoalID());
@@ -336,86 +354,37 @@ public class UndergroundBiomes{
         //oreUBifier.setupUBOre(Blocks.redstone_ore,UBOreTexturizer.redstone_overlay, event);
         UBAPIHook.ubAPIHook.ubOreTexturizer.setupUBOre(Blocks.redstone_ore,UBOreTexturizer.redstone_overlay,event);
 
-        oreUBifier.setupUBOre(Blocks.coal_ore   , UBOreTexturizer.coal_overlay   , event);
-        oreUBifier.setupUBOre(Blocks.diamond_ore, UBOreTexturizer.diamond_overlay, event);
-        oreUBifier.setupUBOre(Blocks.lapis_ore  , UBOreTexturizer.lapis_overlay  , event);
-        oreUBifier.setupUBOre(Blocks.emerald_ore, UBOreTexturizer.emerald_overlay, event);
-        oreUBifier.setupUBOre(Blocks.gold_ore   , UBOreTexturizer.gold_overlay   , event);
+        oreUBifier.setupUBOre(Blocks.coal_ore,UBOreTexturizer.coal_overlay, event);
+        oreUBifier.setupUBOre(Blocks.diamond_ore,UBOreTexturizer.diamond_overlay, event);
+        oreUBifier.setupUBOre(Blocks.lapis_ore,UBOreTexturizer.lapis_overlay, event);
+        oreUBifier.setupUBOre(Blocks.emerald_ore,UBOreTexturizer.emerald_overlay, event);
+        oreUBifier.setupUBOre(Blocks.gold_ore,UBOreTexturizer.gold_overlay, event);
         oreUBifier.setupUBHidden(Blocks.monster_egg, event);
 
+        //modOreManager.register();
+
         oreRequester.fulfillRequests(event);
 
-        defaultIDSetter = this.defaultIDs();
+        //defaultIDSetter = this.defaultIDs();
         FMLCommonHandler.instance().bus().register(this);
+        GameRegistry.registerWorldGenerator(this,10000);
         //FMLCommonHandler.instance().bus().register(new EventWatcher());
 
-        pipeline = new PacketPipeline();
-    }
-
-    private void registerCrossModOres() {
-		oreUBifier.setupUBOre("appliedenergistics2:tile.OreQuartz", 0, "appliedenergistics2:OreQuartz");
-		oreUBifier.setupUBOre("appliedenergistics2:tile.OreQuartzCharged", 0, "appliedenergistics2:OreQuartzCharged");
-		oreUBifier.setupUBOre("arsmagica2:vinteumOre", 0, UBOreTexturizer.vinteum_overlay);
-		oreUBifier.setupUBOre("arsmagica2:vinteumOre", 1, UBOreTexturizer.chimerite_overlay);
-		oreUBifier.setupUBOre("arsmagica2:vinteumOre", 2, UBOreTexturizer.bluetopaz_overlay);
-		oreUBifier.setupUBOre("arsmagica2:vinteumOre", 3, UBOreTexturizer.moonstone_overlay);
-		oreUBifier.setupUBOre("arsmagica2:vinteumOre", 4, UBOreTexturizer.sunstone_overlay);
-		oreUBifier.setupUBOre("BiomesOPlenty:gemOre", 2, UBOreTexturizer.ruby_overlay);
-		oreUBifier.setupUBOre("BiomesOPlenty:gemOre", 4, UBOreTexturizer.olivine_peridot_overlay);
-		oreUBifier.setupUBOre("BiomesOPlenty:gemOre", 6, UBOreTexturizer.topaz_overlay);
-		oreUBifier.setupUBOre("BiomesOPlenty:gemOre", 8, UBOreTexturizer.tanzanite_overlay);
-		oreUBifier.setupUBOre("BiomesOPlenty:gemOre", 10, UBOreTexturizer.malachite_overlay);
-		oreUBifier.setupUBOre("BiomesOPlenty:gemOre", 12, UBOreTexturizer.sapphire_overlay);
-		oreUBifier.setupUBOre("BiomesOPlenty:gemOre", 14, UBOreTexturizer.amber_overlay);
-		oreUBifier.setupUBOre("bonecraft:Fossil", 0, UBOreTexturizer.fossils_overlay);
-		oreUBifier.setupUBOre("evilcraft:darkOre", 0, "evilcraft:darkOre");
-		oreUBifier.setupUBOre("harvestcraft:salt", 0, UBOreTexturizer.salt_overlay);
-		oreUBifier.setupUBOre("imc:block_adamantium_ore", 0, UBOreTexturizer.adamantium_overlay);
-		oreUBifier.setupUBOre("ImmersiveEngineering:ore", 0, UBOreTexturizer.copper_overlay);
-		oreUBifier.setupUBOre("ImmersiveEngineering:ore", 1, UBOreTexturizer.aluminium_overlay);
-		oreUBifier.setupUBOre("ImmersiveEngineering:ore", 2, UBOreTexturizer.lead_overlay);
-		oreUBifier.setupUBOre("ImmersiveEngineering:ore", 3, UBOreTexturizer.silver_overlay);
-		oreUBifier.setupUBOre("ImmersiveEngineering:ore", 4, UBOreTexturizer.nickel_overlay);
-		oreUBifier.setupUBOre("magicalcrops:MinicioOre", 0, UBOreTexturizer.minicio_overlay);
-		oreUBifier.setupUBOre("Mimicry:Sparr_Mimichite Ore", 0, UBOreTexturizer.mimichite_overlay);
-		oreUBifier.setupUBOre("OptimumGS_Mod:bunginiteOre", 0, UBOreTexturizer.bunginite_overlay);
-		oreUBifier.setupUBOre("OptimumGS_Mod:carbonOre", 0, UBOreTexturizer.carbon_overlay);
-		oreUBifier.setupUBOre("OptimumGS_Mod:eridiumOre", 0, UBOreTexturizer.eridium_overlay);
-		oreUBifier.setupUBOre("OptimumGS_Mod:silverOre", 0, UBOreTexturizer.silver_overlay);
-		oreUBifier.setupUBOre("randomadditions:BlockRAOre", 0, UBOreTexturizer.ruby_overlay);
-		oreUBifier.setupUBOre("randomadditions:BlockRAOre", 1, UBOreTexturizer.copper_overlay);
-		oreUBifier.setupUBOre("randomadditions:BlockRAOre", 2, UBOreTexturizer.tin_overlay);
-		oreUBifier.setupUBOre("randomadditions:BlockRAOre", 3, UBOreTexturizer.tourmaline_overlay);
-		oreUBifier.setupUBOre("StargateTech2:block.naquadah", 0, UBOreTexturizer.naquadah_overlay);
-		oreUBifier.setupUBOre("Thaumcraft:blockCustomOre", 0, UBOreTexturizer.cinnabar_overlay);	// cinnabar ore
-		oreUBifier.setupUBOre("Thaumcraft:blockCustomOre", 7, UBOreTexturizer.amber2_overlay);	// amber bearing stone
-		oreUBifier.setupUBOre("TYNKYN:carnelianOre", 0, UBOreTexturizer.carnelian_overlay);
-		oreUBifier.setupUBOre("TYNKYN:surfaceOre", 0, UBOreTexturizer.no_overlay);
-		oreUBifier.setupUBOre("TYNKYN:talcOre", 0, UBOreTexturizer.talc_overlay);
-		oreUBifier.setupUBOre("wildcaves3:FossilBlock", 0, UBOreTexturizer.fossils_overlay);
-	}
-
-    public StoneSlabPair stoneSlabPair(BlockMetadataBase material, NamedSlabPair slabPairName, String oreName) {
-        BlockStoneSlab half = new BlockStoneSlab(false, material, slabPairName);
-        BlockStoneSlab full = new BlockStoneSlab(true, material, slabPairName);
-
-        GameRegistry.registerBlock(half, ItemMetadataSlab.class, slabPairName.half.internal(), UBIDs.ubPrefix(), full);
-        GameRegistry.registerBlock(full, ItemMetadataSlab.class, slabPairName.full.internal(), UBIDs.ubPrefix(), half);
-
-        if (instance().settings.slabOreDictionaryRegistering.value()) {
-	        for (int i = 0; i < 8; i++){
-	            OreDictionary.registerOre(oreName, new ItemStack(half, 1, i));
-	        }
-        }
-
-        return new StoneSlabPair(half, full);
+        pipeline= new PacketPipeline();
     }
 
-    @EventHandler
-    public void load(FMLInitializationEvent event){
+    public StoneSlabPair stoneSlabPair(BlockMetadataBase material, NamedSlabPair slabPairName) {
+        BlockStoneSlab half = new BlockStoneSlab(false,material,slabPairName);
+        BlockStoneSlab full = new BlockStoneSlab(true,material,slabPairName);
 
-        registerCrossModOres();
+        GameRegistry.registerBlock(half,ItemMetadataSlab.class,slabPairName.half.internal(),UBIDs.ubPrefix(),full);
+        GameRegistry.registerBlock(full,ItemMetadataSlab.class,slabPairName.full.internal(),UBIDs.ubPrefix(),half);
+
+        return new StoneSlabPair(half,full);
+    }
 
+    @EventHandler
+    public void load(FMLInitializationEvent event){
         pipeline.initialise();
         playerDetector = new PlayerDetector();
         networking = new UndergroundBiomesNetworking(pipeline,settings);
@@ -434,6 +405,7 @@ public class UndergroundBiomes{
         if (addOreDictRecipes()){
             oreDictifyStone();
         }
+        addRescueRecipes();
 
         // Pull nuggets from ore dictionary
         ArrayList<ItemStack> stacks;
@@ -448,9 +420,9 @@ public class UndergroundBiomes{
             try{
 		//ThaumcraftApi.registerObjectTag(id, meta, (new ObjectTags()).add(EnumTag.VALUABLE, 58).add(EnumTag.LIGHT, 15));
             }
-            catch (Exception exception){
-                logger.error("[UndergroundBiomes] Error while integrating with Thaumcraft");
-                exception.printStackTrace(System.err);
+            catch (Exception e){
+                System.out.println("[UndergroundBiomes] Error while integrating with Thaumcraft");
+                e.printStackTrace(System.err);
             }
         }
 
@@ -477,6 +449,15 @@ public class UndergroundBiomes{
     public void serverLoad(FMLServerStartingEvent event) {
         //logger.info("server starting");
         event.registerServerCommand(new CommandOreDictifyStone());
+        try {
+            WorldServer server = event.getServer().worldServerForDimension(0);
+            File worldLocation = server.getChunkSaveLocation();
+            //UndergroundBiomes.logger.info(world.toString() + " " +worldLocation.getAbsolutePath());
+            configManager.setWorldFile(worldLocation);
+            this.dimensionManager.setupGenerators();
+        } catch (NullPointerException e) {
+            logger.info(e.toString());
+        }
     }
 
    @EventHandler
@@ -496,12 +478,14 @@ public class UndergroundBiomes{
         for (Object key: Block.blockRegistry.getKeys()) {
             String name = (String) key;
             Block named = Block.getBlockFromName(name);
-            Block.getIdFromBlock(named);
+            int id = Block.getIdFromBlock(named);
+            //logger.info(name + " "+id);
         }
         for (Object key: Item.itemRegistry.getKeys()) {
             String name = (String) key;
             Item named = (Item)(Item.itemRegistry.getObject(name));
-            Item.getIdFromItem(named);
+            int id = Item.getIdFromItem(named);
+            //logger.info(name + " "+id);
         }
         if (runningConfigIDs) {
             //defaultIDSetter.redoAsNeeded();
@@ -514,10 +498,11 @@ public class UndergroundBiomes{
     private boolean forceRemap;
     @EventHandler
     public void onMissingMapping(FMLMissingMappingsEvent event) {
-       // logger.info("missing mappings");
+        if (1>0) return;
+       logger.info("missing mappings");
        forceRemap = false;
         for (FMLMissingMappingsEvent.MissingMapping missing: event.get()) {
-            logger.info(missing.name + " " + missing.type.toString());
+            //logger.info(missing.name + " " + missing.type.toString());
             if (missing.name.equalsIgnoreCase("UndergroundBiomes:sedimentaryStoneItem")) forceRemap = true;
         }
     }
@@ -526,13 +511,14 @@ public class UndergroundBiomes{
     public void adjustMappings(FMLModIdMappingEvent event) {
 
         boolean oldIDs = false;
+        if (1>0) return;
         logger.info("remapping");
         ImmutableList<FMLModIdMappingEvent.ModRemapping> remappings =  event.remappedIds;
 
         Iterator<FMLModIdMappingEvent.ModRemapping> list = remappings.iterator();
         while (list.hasNext()) {
             FMLModIdMappingEvent.ModRemapping remapping = list.next();
-            // logger.info(remapping.tag +  " from " + remapping.oldId + " to " + remapping.newId);
+            //logger.info(remapping.tag +  " from " + remapping.oldId + " to " +remapping.newId);
 
             // currently tags drop the fist letter
             if(remapping.tag.equals("inecraft:bed")){
@@ -541,8 +527,7 @@ public class UndergroundBiomes{
             // and presumably Forge will fix that
             if(remapping.tag.equals("Minecraft:bed")){
                 if (remapping.oldId<256) oldIDs = true;
-            }
-            // currently tags drop the fist letter
+            }            // currently tags drop the fist letter
             if(remapping.tag.equals("inecraft:wheat")){
                 if (remapping.oldId<256) oldIDs = true;
             }
@@ -556,19 +541,9 @@ public class UndergroundBiomes{
             if (remapping.tag.equals("UndergroundBiomes:stairs")) {
                 if (remapping.newId == constructs.stoneStairID()) oldIDs = true;
             }
-            if (remapping.tag.equals("UndergroundBiomes:igneousStone")) {
-                if (remapping.newId > 2000) oldIDs = true;
-            }
-            if (remapping.tag.equals("ndergroundBiomes:igneousStone")) {
-                if (remapping.newId> 2000) oldIDs = true;
-            }
-            if (remapping.tag.equals("UndergroundBiomes:metamorphicStone")) {
-                if (remapping.newId> 2000) oldIDs = true;
-            }
-            if (remapping.tag.equals("ndergroundBiomes:metamorphicStone")) {
-                if (remapping.newId> 2000) oldIDs = true;
-            }
         }
+        //do nothing if ID forcing is off
+        if (settings.forceConfigIds.value() == false) return;
         //logger.info("old IDs "+oldIDs);
         if (oldIDs) {
             this.forceConfigIDs();
@@ -647,7 +621,54 @@ public class UndergroundBiomes{
             GameRegistry.addRecipe(new ItemStack(igneousStoneBrick, 4, i), "xx", "xx", 'x', new ItemStack(igneousStone, 1, i));
         }
 
+        // backup recipes for conversion problems
+        
         GameRegistry.registerFuelHandler(new FuelManager());
+        for (int metadata = 0; metadata< 8; metadata++) {
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_slab, 1,0), new ItemStack(igneousStoneSlab.half, 1,metadata)));
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_slab, 1,0), new ItemStack(metamorphicStoneSlab.half, 1,metadata)));
+        }
+        GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_slab, 1,1), new ItemStack(sedimentaryStoneSlab.half, 1)));
+
+        for (int metadata = 0; metadata< 8; metadata++) {
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_slab, 1,3), new ItemStack(igneousCobblestoneSlab.half, 1,metadata)));
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_slab, 1,3), new ItemStack(metamorphicCobblestoneSlab.half, 1,metadata)));
+        }
+    }
+
+    private void addRescueRecipes() {
+                // rescue recipes
+        //metamorphic stone
+        for (int metadata = 0; metadata< 8; metadata++) {
+            //GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_button, 1,0), new ItemStack(constructs.stoneButton().construct, 1,metadata)));
+        }
+        //metamorphic cobblestone
+        for (int metadata = 8; metadata< 8+8; metadata++) {
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_stairs, 1,0), constructs.stoneStair().productItemDefiner(metadata).one()));
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.cobblestone_wall, 1,0), constructs.stoneWall().productItemDefiner(metadata).one()));
+        }
+        //metamorphic brick
+        for (int metadata = 16; metadata< 16+8; metadata++) {
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_brick_stairs, 1,0), constructs.stoneStair().productItemDefiner(metadata).one()));
+        }
+        //igneous stone
+        for (int metadata = 24; metadata< 24+8; metadata++) {
+            //GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_button, 1,0), new ItemStack(constructs.stoneButton().construct, 1,metadata)));
+        }
+        //igneous cobblestone
+        for (int metadata = 32; metadata< 32+8; metadata++) {
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_stairs, 1,0), constructs.stoneStair().productItemDefiner(metadata).one()));
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.cobblestone_wall, 1,0), constructs.stoneWall().productItemDefiner(metadata).one()));
+        }
+        //igneous brick
+        for (int metadata = 40; metadata< 40+8; metadata++) {
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_brick_stairs, 1,0), constructs.stoneStair().productItemDefiner(metadata).one()));
+        }
+        //sedimentary stone
+        for (int metadata = 48; metadata< 48+8; metadata++) {
+            GameRegistry.addRecipe(new ShapelessOreRecipe(new ItemStack(Blocks.stone_button, 1,0), new ItemStack(constructs.stoneButton().construct, 1,metadata)));
+        }
+
     }
     
     public void addOreDicts() {
@@ -658,6 +679,11 @@ public class UndergroundBiomes{
         OreDictionary.registerOre(oreCobblestoneName(), new ItemStack(metamorphicCobblestone, 1, WILDCARD_VALUE));
         OreDictionary.registerOre("stoneBricks", new ItemStack(igneousStoneBrick, 1, WILDCARD_VALUE));
         OreDictionary.registerOre("stoneBricks", new ItemStack(metamorphicStoneBrick, 1, WILDCARD_VALUE));
+        for (int i = 0; i < 0; i++ ) {
+            OreDictionary.registerOre("stone", new ItemStack(igneousStone, 1, i));
+            OreDictionary.registerOre("stone", new ItemStack(metamorphicStone, 1, i));
+            OreDictionary.registerOre("stone", new ItemStack(sedimentaryStone, 1, i));
+        }
         //OreDictionary.registerOre(textures, ore);
         this.oreUBifier.registerOres();
     }
@@ -709,11 +735,12 @@ public class UndergroundBiomes{
         {
             Object obj = recipes.get(i);
             ItemStack output = ((IRecipe)obj).getRecipeOutput();
-            if (output == null || containsMatch(false, exclusions, output))
+            if (output != null && containsMatch(false, exclusions, output))
             {
                 continue;
             }
-            // suppress alterations overriding construct recipes
+            // supress alterations overriding construct recipes
+            if (obj == null) continue;
             if (UndergroundBiomesConstructs.overridesRecipe((IRecipe)obj)) continue;
 
             if (obj instanceof ShapedRecipes)
@@ -721,19 +748,23 @@ public class UndergroundBiomes{
                 ShapedRecipes recipe = (ShapedRecipes)obj;
                 if (containsMatch(true, recipe.recipeItems, replaceStacks))
                 {
-                    recipes.set(i, shapedConstr.newInstance(recipe, replacements));
+                    recipes.set(i, (ShapedOreRecipe)shapedConstr.newInstance(recipe, replacements));
                     numReplaced++;
-                    UndergroundBiomes.logger.info("Changed shaped recipe for " + output.getDisplayName());
+                    System.out.println("Changed shaped recipe for " + output.getDisplayName());
                 }
             }
             else if (obj instanceof ShapelessRecipes)
             {
                 ShapelessRecipes recipe = (ShapelessRecipes)obj;
-                if (containsMatch(true, (ItemStack[])recipe.recipeItems.toArray(new ItemStack[recipe.recipeItems.size()]), replaceStacks))
+                List recipeItems = recipe.recipeItems;
+                if (recipeItems == null) continue;
+                if (containsMatch(true, 
+                        (ItemStack[])recipeItems.toArray(
+                        new ItemStack[recipeItems.size()]), replaceStacks))
                 {
-                    recipes.set(i, shapelessConstr.newInstance(recipe, replacements));
+                    recipes.set(i, (ShapelessOreRecipe)shapelessConstr.newInstance(recipe, replacements));
                     numReplaced++;
-                    UndergroundBiomes.logger.info("Changed shapeless recipe for " + output.getDisplayName());
+                    System.out.println("Changed shapeless recipe for " + output.getDisplayName());
                 }
             }
             else if (obj instanceof ShapedOreRecipe)
@@ -742,7 +773,7 @@ public class UndergroundBiomes{
                 if (containsMatchReplaceInplace(true, recipe.getInput(), replaceStacks, replacements))
                 {
                     numReplaced++;
-                    UndergroundBiomes.logger.info("Changed shaped ore recipe for " + output.getDisplayName());
+                    System.out.println("Changed shaped ore recipe for " + output.getDisplayName());
                 }
             }
             else if (obj instanceof ShapelessOreRecipe)
@@ -751,11 +782,13 @@ public class UndergroundBiomes{
                 if (containsMatchReplaceInplace(true, recipe.getInput(), replaceStacks, replacements))
                 {
                     numReplaced++;
-                    UndergroundBiomes.logger.info("Changed shapeless ore recipe for " + output.getDisplayName());
+                    System.out.println("Changed shapeless ore recipe for " + output.getDisplayName());
                 }
             }
         }
-        //CraftingManager.getInstance().addShapelessRecipe(new ItemStack(NamedVanillaBlock.stoneButton.block()), new Object[] {NamedVanillaBlock.stone.block()});
+
+
+        CraftingManager.getInstance().addShapelessRecipe(new ItemStack(NamedVanillaBlock.stoneButton.block()), new Object[] {NamedVanillaBlock.stone.block()});
 
         return numReplaced;
     }
@@ -831,20 +864,27 @@ public class UndergroundBiomes{
         return dimensionManager.inChunkGenerationAllowed(id);
     }
 
+    public void generate(Random arg0, int x, int z, World world, IChunkProvider arg4, IChunkProvider arg5) {
+        redoOres(x*16,z*16,world);
+    }
     
     @SubscribeEvent
     public void onWorldLoad(WorldEvent.Load event) {
-        if (world instanceof WorldServer) {
+        /*if (world instanceof WorldServer) {
             WorldServer server = (WorldServer)world;
-            File worldLocation = server.getChunkSaveLocation().getParentFile();
-            //UndergroundBiomes.logger.info(world.toString() + " " +worldLocation.getAbsolutePath());
-            configManager.setWorldFile(worldLocation);
-            this.dimensionManager.setupGenerators(event);
-        }
+            if (world.provider.dimensionId == 0) {
+              File worldLocation = server.getChunkSaveLocation().getParentFile();
+               //UndergroundBiomes.logger.info(world.toString() + " " +worldLocation.getAbsolutePath());
+               configManager.setWorldFile(worldLocation);
+            }
+            this.dimensionManager.setupGenerators();
+        }*/
         if (!gotWorldSeed) {
             world = event.world;
-            worldSeed = world.getSeed();
-            gotWorldSeed = true;
+            if (world.provider.dimensionId == 0) {
+                worldSeed = world.getSeed();
+                gotWorldSeed = true;
+            }
         }
         tabModBlocks.item = ItemMetadataBlock.itemFrom(UBIDs.igneousStoneBrickName);
     }
@@ -852,13 +892,22 @@ public class UndergroundBiomes{
     @SubscribeEvent
     public void onWorldUnload(WorldEvent.Unload event){
         gotWorldSeed = false;
-        this.ubCodeLocations.clear();
+        this.serverCodeLocations.clear();
+        this.clientCodeLocations.clear();
         this.dimensionManager.unload();
     }
 
     @SubscribeEvent(priority = EventPriority.NORMAL)
     public void onBiomeDecorate(DecorateBiomeEvent.Post event)    {
+        //logger.info("decorate "+event.chunkX + "," + event.chunkZ);
+        //dimensionManager.onBiomeDecorate(event);
+    }
+
+    @SubscribeEvent(priority = EventPriority.LOWEST)
+    public void onBiomePopulate(PopulateChunkEvent.Post event)    {
+        //logger.info("decorate "+event.chunkX + "," + event.chunkZ);
         dimensionManager.onBiomeDecorate(event);
+        dimensionManager.redoOres(event.chunkX*16, event.chunkZ*16, event.world);
     }
 
     @SubscribeEvent(priority = EventPriority.LOWEST)
@@ -875,8 +924,8 @@ public class UndergroundBiomes{
         }
     }
 
-    public void redoOres(int x, int z, World worldObj) {
-        dimensionManager.redoOres(x, z, worldObj);
+    public void redoOres(int x, int z, World world) {
+        dimensionManager.redoOres(x, z, world);
     }
 
     public static String oreStoneName() {
@@ -923,9 +972,9 @@ public class UndergroundBiomes{
         forcing.addChangeWithItem(sedimentaryStoneSlabHalfID(),sedimentaryStoneSlab.half);
         forcing.addChangeWithItem(sedimentaryStoneSlabFullID(),sedimentaryStoneSlab.full);
 
-        forcing.addChange(constructs.stoneButtonID(),constructs.stoneButton().construct);
-        forcing.addChange(constructs.stoneStairID(), constructs.stoneStair().construct);
-        forcing.addChange(constructs.stoneWallID(), constructs.stoneWall().construct);
+        //forcing.addChange(constructs.stoneButtonID(),constructs.stoneButton().construct);
+        //forcing.addChange(constructs.stoneStairID(), constructs.stoneStair().construct);
+        //forcing.addChange(constructs.stoneWallID(), constructs.stoneWall().construct);
         return forcing;
     }
 
@@ -967,6 +1016,8 @@ public class UndergroundBiomes{
     }
 
     private void forceConfigIDs() {
+
+        if (1>0) throw new RuntimeException();
         WatchList forcing = configList();
         try {
             for (String warning: forcing.problems()) {
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/WorldGenManager.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/WorldGenManager.java
index 087c2db..058ebe7 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/WorldGenManager.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/WorldGenManager.java
@@ -12,25 +12,32 @@ import net.minecraft.world.gen.layer.*;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldServer;
 import net.minecraftforge.event.terraingen.DecorateBiomeEvent;
+
 import Zeno410Utils.PlaneLocation;
 import Zeno410Utils.Accessor;
-import exterminatorJeff.undergroundBiomes.worldGen.BiomeGenUndergroundBase;
+import Zeno410Utils.Bomb;
+import exterminatorJeff.undergroundBiomes.api.BiomeGenUndergroundBase;
 import exterminatorJeff.undergroundBiomes.worldGen.BiomeUndergroundCacheBlock;
 import exterminatorJeff.undergroundBiomes.worldGen.BiomeUndergroundDecorator;
 import exterminatorJeff.undergroundBiomes.worldGen.GenLayerUnderground;
 import net.minecraftforge.event.terraingen.BiomeEvent.GetVillageBlockID;
 import net.minecraftforge.event.terraingen.BiomeEvent.GetVillageBlockMeta;
 import exterminatorJeff.undergroundBiomes.worldGen.UBChunkProvider;
-import exterminatorJeff.undergroundBiomes.worldGen.UndergroundBiomeSet;
+import exterminatorJeff.undergroundBiomes.api.UndergroundBiomeSet;
 import exterminatorJeff.undergroundBiomes.worldGen.VillageStoneChanger;
+
+
+import Zeno410Utils.Zeno410Logger;
 import exterminatorJeff.undergroundBiomes.worldGen.OreUBifier;
+import java.util.logging.Logger;
 
 import java.lang.reflect.*;
-
 import net.minecraftforge.event.terraingen.PopulateChunkEvent;
 
 public class WorldGenManager {
 
+    public static Logger logger = new Zeno410Logger("WorldGenManager").logger();
+
     public final int dimension;
 
     private GenLayer genUndergroundBiomes;
@@ -58,9 +65,11 @@ public class WorldGenManager {
 
     private UndergroundBiomeSet biomeSet;
 
-    public boolean ubOn() {return UndergroundBiomes.instance().settings().ubActive.value();}
+    public boolean ubOn() {return ubOn;}
+
+    private final boolean ubOn;
 
-    public WorldGenManager(long par1, int _dimension,OreUBifier oreUBifier, UndergroundBiomeSet biomeSet){
+    public WorldGenManager(long par1, int _dimension,OreUBifier oreUBifier, UndergroundBiomeSet biomeSet, boolean ubOn){
 
         dimension = _dimension;
         seed = par1;
@@ -78,8 +87,19 @@ public class WorldGenManager {
             this.undergroundBiomeIndexLayer = gen[1];
         }
 
+        // examine gen layer
+        /*try {
+          new AccessGenLayer().report(undergroundBiomeIndexLayer);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+         */
+
         villageStoneSource = new BiomeUndergroundDecorator(this,oreUBifier);
         villageStoneChanger = new VillageStoneChanger();
+
+        this.ubOn = ubOn;
+
     }
 
     public boolean inChunkGenerationAllowed() {
@@ -116,6 +136,10 @@ public class WorldGenManager {
         this.villageStoneSource.decorate(event.world, event.rand, event.chunkX, event.chunkZ);
     }
 
+    public void onBiomeDecorate(PopulateChunkEvent.Post event){
+        this.villageStoneSource.decorate(event.world, event.rand, event.chunkX*16, event.chunkZ*16);
+    }
+
     public void onBiomeReplaceOres(DecorateBiomeEvent.Post event){
         this.villageStoneSource.replaceChunkOres(event.chunkX, event.chunkZ,event.world);
         this.villageStoneSource.doRedos(event.world);
@@ -137,10 +161,10 @@ public class WorldGenManager {
 
     public BiomeGenUndergroundBase[] loadUndergroundBlockGeneratorData(BiomeGenUndergroundBase[] par1ArrayOfBiomeGenBase, int par2, int par3, int par4, int par5)
     {
-        return this.getUndergroundBiomeGenAt(par1ArrayOfBiomeGenBase, par2, par3, par4, par5, true);
+        return this.getUndergroundBiomeGenAt(par1ArrayOfBiomeGenBase, par2, par3, par4, par5);
     }
 
-    public BiomeGenUndergroundBase[] getUndergroundBiomeGenAt(BiomeGenUndergroundBase[] biomesArrayPar, int par2, int par3, int par4, int par5, boolean par6)
+    public BiomeGenUndergroundBase[] getUndergroundBiomeGenAt(BiomeGenUndergroundBase[] biomesArrayPar, int par2, int par3, int par4, int par5)
     {
             IntCache.resetIntCache();
 
@@ -151,7 +175,7 @@ public class WorldGenManager {
                 biomesArray = new BiomeGenUndergroundBase[par4 * par5];
             }
 
-            if (par6 && par4 == 16 && par5 == 16 && (par2 & 15) == 0 && (par3 & 15) == 0){
+            if (par4 == 16 && par5 == 16 ){ //&& (par2 & 15) == 0 && (par3 & 15) == 0){
 
                 BiomeGenUndergroundBase[] var9 = this.biomeCache.getCachedUndergroundBiomes(par2, par3);
                 System.arraycopy(var9, 0, biomesArray, 0, par4 * par5);
@@ -159,18 +183,24 @@ public class WorldGenManager {
                 return biomesArray;
 
             }else{
+                throw new RuntimeException();
+        }
 
-                int[] var7 = this.undergroundBiomeIndexLayer.getInts(par2, par3, par4, par5);
-
+    }
 
+    public BiomeGenUndergroundBase[] cacheUndergroundBiomeGenAt(BiomeGenUndergroundBase[] biomesArrayPar, int par2, int par3, int par4, int par5){
+            BiomeGenUndergroundBase[] biomesArray = biomesArrayPar;
 
+            if (biomesArray == null || biomesArray.length < par4 * par5){
+                IntCache.resetIntCache();
+                biomesArray = new BiomeGenUndergroundBase[par4 * par5];
+            }
+            int[] var7 = this.undergroundBiomeIndexLayer.getInts(par2, par3, par4, par5);
                 for (int var8 = 0; var8 < par4 * par5; ++var8){
                     biomesArray[var8] = biomeSet.biomeList[var7[var8]];
+                    //if (biomesArray[var8].strata[0]==null) throw new RuntimeException();
                 }
-
            return biomesArray;
-        }
-
     }
 
     public void setGenerated(int x, int z) {
@@ -189,6 +219,18 @@ public class WorldGenManager {
         }
     }
 
+    public void decorateIfNeeded(PopulateChunkEvent.Post event) {
+        PlaneLocation target = new PlaneLocation(event.chunkX, event.chunkZ);
+        if (alreadyGenerated.contains(target))  {
+             // take it out of the generated list
+            alreadyGenerated.remove(target);
+            //this.onBiomeReplaceOres(event);
+        } else {
+            // needs generation
+           onBiomeDecorate(event);
+        }
+    }
+
     private boolean arrayHasValues(int[] ints){
         for(int i : ints){
             if(i != 0){
@@ -264,7 +306,9 @@ public class WorldGenManager {
         } else {
             if ((currentProvider instanceof ChunkProviderGenerate)
                     ||(currentProvider.getClass().getName().contains("ChunkProviderBOP")
-                    ||(currentProvider.getClass().getName().contains("BWG4ChunkProvider")))){
+                    ||(currentProvider.getClass().getName().contains("ChunkProviderTwilightForest")
+                    ||(currentProvider.getClass().getName().contains("BWG4ChunkProvider")
+                    ||(currentProvider.getClass().getName().contains("ChunkProviderRTG")))))){
                 providerFromChunkServer.setField(currentServer,
                     new UBChunkProvider(currentProvider,this.villageStoneSource,this.dimension));
             }
@@ -288,14 +332,13 @@ public class WorldGenManager {
         private void setIChunkProviderField() throws IllegalAccessException{
             Field [] fields = World.class.getDeclaredFields();
             for (int i = 0; i < fields.length;i ++) {
-            	//Better than relying on the shifting sands of obfuscated names.
                 if (IChunkProvider.class.isAssignableFrom(fields[i].getType())) {
                     iChunkProviderField = fields[i];
                     iChunkProviderField.setAccessible(true);
                     return;
                 }
             }
-            throw new RuntimeException("IChunkProvider field not found.");
+            throw new RuntimeException();
         }
 
         public IChunkProvider iChunkProvider(World world) {
@@ -324,6 +367,7 @@ public class WorldGenManager {
             }
         }
     }
+    //
 
     static class AccessChunkProviderServer{
         Field iChunkProviderServerField;
@@ -337,14 +381,11 @@ public class WorldGenManager {
         private void setIChunkProviderField() throws IllegalAccessException{
             Field [] fields = WorldServer.class.getDeclaredFields();
             for (int i = 0; i < fields.length;i ++) {
-            	UndergroundBiomes.logger.info("WorldServer field #" + i + " is a " + fields[i].getType().getName(), false);
                 if (fields[i].getType() == ChunkProviderServer.class) {
                     iChunkProviderServerField = fields[i];
                     iChunkProviderServerField.setAccessible(true);
-                    return;
                 }
             }
-            throw new RuntimeException("ChunkProviderServer field not found.");
         }
 
         public ChunkProviderServer chunkProviderServer(WorldServer world) {
@@ -369,5 +410,30 @@ public class WorldGenManager {
             }
         }
     }
+
+    static class AccessGenLayer extends GenLayer {
+        AccessGenLayer() {super(0);}
+        public int[] getInts(int i, int j, int k, int l) {return null;}
+
+        public void report(GenLayer examinedLayer) throws IllegalAccessException{
+            Field [] fields = this.getClass().getSuperclass().getDeclaredFields();
+            Field parentField = null;
+            //logger.info( "fieldcount "+fields.length);
+            for (int i = 0; i < fields.length;i ++) {
+                //logger.info( fields[i].getName());
+                if (GenLayer.class.isAssignableFrom(fields[i].getClass())) {
+                    parentField.setAccessible(true);
+                }
+            }
+            int level = 0;
+            while (examinedLayer!= null) {
+                //logger.info( examinedLayer.getClass().getName());
+                level ++;
+                examinedLayer = (GenLayer)(parentField.get(examinedLayer));
+                if (level > 100) break;
+            }
+        }
+    }
+
 }
 
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousCobblestone.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousCobblestone.java
index aaf59fb..a152911 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousCobblestone.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousCobblestone.java
@@ -1,20 +1,34 @@
 package exterminatorJeff.undergroundBiomes.common.block;
 
+import Zeno410Utils.Acceptor;
 import java.util.Random;
 
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
+import net.minecraft.util.IIcon;
 import net.minecraft.world.World;
 import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 
 public class BlockIgneousCobblestone extends BlockIgneousStone
 {
     public BlockIgneousCobblestone() {
         super(UBIDs.igneousCobblestoneName);
+        baseHardness = this.blockHardness;
         this.setHardness(this.blockHardness*1.333333f);
         replaceableByOre = false;
+        UndergroundBiomes.instance().settings().cobbleHardnessMultiplier.informOnChange(hardnessUpdater);
+        hardnessUpdater.accept(UndergroundBiomes.instance().settings().cobbleHardnessMultiplier.value());
     }
+    final float baseHardness;
+    private final Acceptor<Double> hardnessUpdater = new Acceptor<Double>() {
 
+        @Override
+        public void accept(Double accepted) {
+            setHardness(baseHardness*accepted.floatValue());
+        }
+
+    };
     @Override
     public ItemStack itemDropped(int metadata, Random random, int fortune, int y) {
         return new ItemStack(UBIDs.igneousCobblestoneName.block(), 1, metadata & 7);
@@ -35,4 +49,10 @@ public class BlockIgneousCobblestone extends BlockIgneousStone
         return Item.getItemById(UBIDs.igneousCobblestoneName.ID());
     }
 
+    @Override
+    public IIcon getIcon(int side, int metadata) {
+        return super.getIcon(side, metadata);
+    }
+
+
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousStone.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousStone.java
index 78823d9..6b6474e 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousStone.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousStone.java
@@ -14,7 +14,7 @@ public class BlockIgneousStone extends BlockMetadataBase
 {
     private static final float[] hardness = {1.7f, 1.6f, 1.3f, 1.4f, 1.0f, 1.4f, 1.5f, 1.2f};
     private static final float[] resistance = {1.42f, 1.39f, 1.26f, 1.31f, 1.0f, 1.31f, 1.35f, 1.2f};
-    private static final String[] blockName = {
+    public static final String[] blockName = {
         "redGranite", "blackGranite", "rhyolite", "andesite", "gabbro", "basalt", "komatiite", "dacite"
     };
 
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousStoneBrick.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousStoneBrick.java
index 2999222..66b6dc8 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousStoneBrick.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockIgneousStoneBrick.java
@@ -1,11 +1,13 @@
 package exterminatorJeff.undergroundBiomes.common.block;
 
+import Zeno410Utils.Acceptor;
 import java.util.Random;
 
 import net.minecraft.item.ItemStack;
 import net.minecraft.item.Item;
 
 import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 
 public class BlockIgneousStoneBrick extends BlockIgneousStone
 {
@@ -13,7 +16,19 @@ public class BlockIgneousStoneBrick extends BlockIgneousStone
     {
         super(UBIDs.igneousStoneBrickName);
         replaceableByOre = false;
+        baseHardness = this.blockHardness;
+        UndergroundBiomes.instance().settings().brickHardnessMultiplier.informOnChange(hardnessUpdater);
+        hardnessUpdater.accept(UndergroundBiomes.instance().settings().brickHardnessMultiplier.value());
     }
+    final float baseHardness;
+    private final Acceptor<Double> hardnessUpdater = new Acceptor<Double>() {
+
+        @Override
+        public void accept(Double accepted) {
+            setHardness(baseHardness*accepted.floatValue());
+        }
+
+    };
 
     public ItemStack itemDropped(int metadata, Random random, int fortune, int y)
     {
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetadataBase.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetadataBase.java
index d40f9ba..4fb2aa7 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetadataBase.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetadataBase.java
@@ -23,7 +23,7 @@ import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 import Zeno410Utils.Acceptor;
 import Zeno410Utils.Zeno410Logger;
 
-//import clickme.nocubes.NoCubes;
+import clickme.nocubes.NoCubes;
 
 import exterminatorJeff.undergroundBiomes.worldGen.BiomeUndergroundDecorator;
 import java.util.logging.Logger;
@@ -38,21 +38,15 @@ public abstract class BlockMetadataBase extends BlockStone {
     private int renderID;
     protected float ubExplosionResistance;
     private final Acceptor<Double> hardnessUpdater = new Acceptor<Double>() {
-            @Override
-			public void accept(Double newHardness) {
+            public void accept(Double newHardness) {
                 // we use the standard rather than the passed since we're having to cut back resistance
                 setHardness(1.5F*UndergroundBiomes.hardnessModifier());
-                // very bad programming practice but I should probably redo the whole system.
-                if (this.getClass().getName().contains("obble")) {
-                   setHardness(1.5F*UndergroundBiomes.hardnessModifier()*1.333F);
-                }
             }
         };
 
 
     private final Acceptor<Double> resistanceUpdater = new Acceptor<Double>() {
-            @Override
-			public void accept(Double newResistance) {
+            public void accept(Double newResistance) {
                 // we use the standard rather than the passed since we're having to cut back resistance
                 setResistance(1.66F*UndergroundBiomes.resistanceModifier());
                 ubExplosionResistance = blockResistance;
@@ -64,13 +58,17 @@ public abstract class BlockMetadataBase extends BlockStone {
         this.setBlockName(block.internal());
         this.setCreativeTab(UndergroundBiomes.tabModBlocks);
         namer = block;
-        //try {
-        //    renderID = NoCubes.renderId;
-        //} catch (java.lang.NoClassDefFoundError e) {
+        try {
             renderID = super.getRenderType();
-        //}
+        } catch (java.lang.NoSuchFieldError e) {
+            renderID = super.getRenderType();
+        } catch (Error e) {
+            renderID = super.getRenderType();
+        }
         UndergroundBiomes.instance().settings().hardnessModifier.informOnChange(this.hardnessUpdater);
+        hardnessUpdater.accept(UndergroundBiomes.instance().settings().hardnessModifier.value());
         UndergroundBiomes.instance().settings().resistanceModifier.informOnChange(this.resistanceUpdater);
+        resistanceUpdater.accept(UndergroundBiomes.instance().settings().resistanceModifier.value());
 
     }
 
@@ -87,21 +85,19 @@ public abstract class BlockMetadataBase extends BlockStone {
         }
     }
     
-    @Override
-	@SideOnly(Side.CLIENT)
+    @SideOnly(Side.CLIENT)
     public IIcon getIcon(int side, int metadata){
+        IIcon result = textures[metadata & 7];
+        if (result == null) throw new RuntimeException(""+metadata);
         return textures[metadata & 7];
     }
 
-    @Override
-	@SideOnly(Side.CLIENT)
+    @SideOnly(Side.CLIENT)
     protected String getTextureName(){
         return this.textureName == null ? "MISSING_ICON_BLOCK_" + getIdFromBlock(this) + "_" + this.getUnlocalizedName() : this.textureName;
     }
 
-    @Override
-	public void getSubBlocks(Item id, CreativeTabs tabs, List list)
-    {
+    public void getSubBlocks(Item id, CreativeTabs tabs, List list){
         for (int i = 0; i < 8; i++){
             list.add(new ItemStack(id, 1, i));
         } 
@@ -117,7 +113,9 @@ public abstract class BlockMetadataBase extends BlockStone {
 
         if (target == null) return this.replaceableByOre;
         // this obnoxious call is needed because something is redoing ore placement without calling my routines
-        BiomeUndergroundDecorator.needsRedo(x, z, world);
+        if (!UndergroundBiomes.instance().settings().newGeneration.value()) {
+           BiomeUndergroundDecorator.needsRedo(x, z, world);
+        }
         return this.replaceableByOre&&target.getUnlocalizedName().equals(Blocks.stone.getUnlocalizedName());
     }
     
@@ -132,20 +130,17 @@ public abstract class BlockMetadataBase extends BlockStone {
         return result;
     }
     
-    @Override
-	public float getExplosionResistance(Entity entity, World world, int x, int y, int z, double explosionX, double explosionY, double explosionZ)
+    public float getExplosionResistance(Entity entity, World world, int x, int y, int z, double explosionX, double explosionY, double explosionZ)
     {
         return getBlockExplosionResistance(getDamageValue(world, x, y, z) & 7);
     }
     
-    @Override
-	public float getBlockHardness(World world, int x, int y, int z)
+    public float getBlockHardness(World world, int x, int y, int z)
     {
         return getBlockHardness(getDamageValue(world, x, y, z) & 7);
     }
 
-    @Override
-	protected ItemStack createStackedBlock(int metadata){
+    protected ItemStack createStackedBlock(int metadata){
         return new ItemStack(this, 1, metadata & 7);
     }
 
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicCobblestone.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicCobblestone.java
index c7f8681..c899b2a 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicCobblestone.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicCobblestone.java
@@ -1,19 +1,32 @@
 package exterminatorJeff.undergroundBiomes.common.block;
 
+import Zeno410Utils.Acceptor;
 import java.util.Random;
 
 import net.minecraft.item.ItemStack;
 
 import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 
 public class BlockMetamorphicCobblestone extends BlockMetamorphicStone
 {
     public BlockMetamorphicCobblestone() {
         super(UBIDs.metamorphicCobblestoneName);
+        baseHardness = this.blockHardness;
         this.setHardness(this.blockHardness*1.333333f);
         replaceableByOre = false;
+        UndergroundBiomes.instance().settings().cobbleHardnessMultiplier.informOnChange(hardnessUpdater);
+        hardnessUpdater.accept(UndergroundBiomes.instance().settings().cobbleHardnessMultiplier.value());
     }
+    final float baseHardness;
+    private final Acceptor<Double> hardnessUpdater = new Acceptor<Double>() {
 
+        @Override
+        public void accept(Double accepted) {
+            setHardness(baseHardness*accepted.floatValue());
+        }
+
+    };
     @Override
     public ItemStack itemDropped(int metadata, Random random, int fortune, int y){
         return new ItemStack(UBIDs.metamorphicCobblestoneName.block(), 1, metadata & 7);
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicStone.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicStone.java
index 470a4c7..028f1d0 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicStone.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicStone.java
@@ -14,7 +14,7 @@ public class BlockMetamorphicStone extends BlockMetadataBase
 {
     private static final float[] hardness = {1.1f, 1.0f, 1.1f, 1.3f, 0.7f, 0.7f, 0.4f, 0.9f};
     private static final float[] resistance = {1.11f, 1.0f, 1.11f, 1.26f, 0.54f, 0.54f, 0.2f, 0.86f};
-    private static final String[] blockName = {
+    public static final String[] blockName = {
         "gneiss", "eclogite", "marble", "quartzite", "blueschist", "greenschist", "soapstone", "migmatite"
     };
 
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicStoneBrick.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicStoneBrick.java
index 5921d86..5cc9251 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicStoneBrick.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockMetamorphicStoneBrick.java
@@ -1,5 +1,6 @@
 package exterminatorJeff.undergroundBiomes.common.block;
 
+import Zeno410Utils.Acceptor;
 import java.util.Random;
 
 import net.minecraft.item.ItemStack;
@@ -7,14 +8,26 @@ import net.minecraft.item.Item;
 import net.minecraft.world.World;
 
 import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 
 public class BlockMetamorphicStoneBrick extends BlockMetamorphicStone
 {
     public BlockMetamorphicStoneBrick(){
         super(UBIDs.metamorphicStoneBrickName);
         this.replaceableByOre = false;
+        baseHardness = this.blockHardness;
+        UndergroundBiomes.instance().settings().brickHardnessMultiplier.informOnChange(hardnessUpdater);
+        hardnessUpdater.accept(UndergroundBiomes.instance().settings().brickHardnessMultiplier.value());
     }
+    final float baseHardness;
+    private final Acceptor<Double> hardnessUpdater = new Acceptor<Double>() {
 
+        @Override
+        public void accept(Double accepted) {
+            setHardness(baseHardness*accepted.floatValue());
+        }
+
+    };
     public ItemStack itemDropped(int metadata, Random random, int fortune, int y){
         return new ItemStack(UBIDs.metamorphicStoneBrickName.block(), 1, metadata & 7);
     }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockOverlay.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockOverlay.java
index 947565a..7a3cb55 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockOverlay.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockOverlay.java
@@ -14,7 +14,6 @@ import net.minecraft.block.material.Material;
 import net.minecraft.client.renderer.texture.IIconRegister;
 import net.minecraft.client.renderer.texture.TextureMap;
 import net.minecraft.util.IIcon;
-//import clickme.nocubes.NoCubes;
 
 /*
  *
@@ -29,13 +28,10 @@ public class BlockOverlay extends Block{
 
     public BlockOverlay(String overlayName) {
         super(Material.rock);
+        if (overlayName.contains("null")) throw new RuntimeException();
         this.overlayFileName  = overlayName;
         this.textureName = overlayName;
-        //try {
-        //    renderID = NoCubes.renderId;
-        //} catch (java.lang.NoClassDefFoundError e) {
-            renderID = super.getRenderType();
-        //}
+        renderID = super.getRenderType();
 
     }
     @SideOnly(Side.CLIENT)
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockSedimentaryStone.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockSedimentaryStone.java
index bff2188..032de8c 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockSedimentaryStone.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockSedimentaryStone.java
@@ -13,7 +13,7 @@ public class BlockSedimentaryStone extends BlockMetadataBase
 {
     private static final float[] hardness = {0.5f, 0.5f, 0.5f, 0.6f, 0.5f, 0.5f, 1.0f, 0.9f};
     private static final float[] resistance = {0.29f, 0.29f, 0.29f, 0.4f, 0.29f, 0.29f, 1.0f, 0.86f};
-    private static final String[] blockName = {
+    public static final String[] blockName = {
         "limestone", "chalk", "shale", "siltstone", "ligniteBlock", "dolomite", "greywacke", "chert"
     };
 
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockStoneSlab.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockStoneSlab.java
index 65a9f92..f42a5f1 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockStoneSlab.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockStoneSlab.java
@@ -27,7 +27,7 @@ public class BlockStoneSlab extends BlockSlab {
     public final BlockMetadataBase referenceBlock;
     private final NamedItem halfSlabNamer;
     
-    public BlockStoneSlab(boolean isDouble, Block refBlock, NamedSlabPair pairName){
+    public BlockStoneSlab(boolean isDouble, Block refBlock,NamedSlabPair pairName){
         super(isDouble, refBlock.getMaterial());
         this.setCreativeTab(isDouble ? null : UndergroundBiomes.tabModBlocks);
         isDoubleSlab = isDouble;
@@ -37,6 +37,11 @@ public class BlockStoneSlab extends BlockSlab {
     }
 
     @Override
+    public void registerBlockIcons(IIconRegister p_149651_1_) {
+        //super.registerBlockIcons(p_149651_1_);
+    }
+
+    @Override
     public float getBlockHardness(World par1World, int x, int y, int z) {
         float result =  referenceBlock.getBlockHardness(par1World, x, y, z);
         if (this.isDoubleSlab()) return result;
@@ -49,8 +54,7 @@ public class BlockStoneSlab extends BlockSlab {
         return getHalfSlab();
     }
 
-    @Override
-	public String func_150002_b(int meta) {
+    public String func_150002_b(int meta) {
         return referenceBlock.getUnlocalizedName() + "Slab."+referenceBlock.getBlockTypeName(meta);      
     }
 
@@ -82,8 +86,7 @@ public class BlockStoneSlab extends BlockSlab {
         }
     }
 
-    @Override
-	public int getDamageValue(World world, int x, int y, int z)
+    public int getDamageValue(World world, int x, int y, int z)
     {
         return world.getBlockMetadata(x, y, z) & 7;
     }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBHidden.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBHidden.java
index 0f2d5de..5956b7d 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBHidden.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBHidden.java
@@ -8,11 +9,15 @@ package exterminatorJeff.undergroundBiomes.common.block;
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import Zeno410Utils.Mutable;
+import Zeno410Utils.MinecraftName;
+import exterminatorJeff.undergroundBiomes.constructs.util.ShamWorld;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
+import net.minecraft.client.renderer.texture.IIconRegister;
 import net.minecraft.creativetab.CreativeTabs;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.player.EntityPlayer;
@@ -27,154 +32,160 @@ import net.minecraft.world.World;
  *
  * @author Zeno410
  */
-public class BlockUBHidden extends Block {
-	
-	protected final BlockMetadataBase stone;
-	protected final Block ore;
-	
-	public BlockUBHidden(BlockMetadataBase stone, final Block ore) {
-		super(Material.rock);
-		this.stone = stone;
-		this.ore = ore;
-		if (ore instanceof BlockUBOre) {
-			throw new RuntimeException();
-		}
-		
-		//renderIDSource = null;
-		this.setCreativeTab(UndergroundBiomes.tabModBlocks);
-	}
-	
-	public Block block() {
-		return this;
-	}
-	
-	@SideOnly(Side.CLIENT)
-	@Override
-	public IIcon getIcon(int side, int metadata) {
-		return stone.getIcon(side, metadata);
-	}
-	
-	@SideOnly(Side.CLIENT)
-	@Override
-	protected String getTextureName() {
-		return stone.getTextureName();
-	}
-	
-	@Override
-	public void getSubBlocks(Item id, CreativeTabs tabs, List list) {
-		// if UB ores is off nothing in the tabs
-		if (UndergroundBiomes.ubOres() == false)
-			return;
-		for (int i = 0; i < BlockMetadataBase.metadatas; i++) {
-			list.add(new ItemStack(id, 1, i));
-		}
-	}
-	
-	@Override
-	public ArrayList<ItemStack> getDrops(World world, int x, int y, int z, int metadata, int fortune) {
-		return ore.getDrops(world, x, y, z, metadata, fortune);
-	}
-	
-	@Override
-	public String getItemIconName() {
-		return stone.getItemIconName() + " " + ore.getItemIconName();
-	}
-	
-	public String getDisplayName(int meta) {
-		return stone.getBlockName(meta);
-	}
-	
-	public String getUnlocalizedName(int meta) {
-		return stone.getBlockName(meta);
-	}
-	
-	@Override
-	public void dropXpOnBlockBreak(World p_149657_1_, int p_149657_2_, int p_149657_3_, int p_149657_4_, int p_149657_5_) {
-		ore.dropXpOnBlockBreak(p_149657_1_, p_149657_2_, p_149657_3_, p_149657_4_, p_149657_5_);
-	}
-	
-	@Override
-	public void dropBlockAsItemWithChance(World p_149690_1_, int p_149690_2_, int p_149690_3_, int p_149690_4_, int p_149690_5_, float p_149690_6_, int p_149690_7_) {
-		ore.dropBlockAsItemWithChance(p_149690_1_, p_149690_2_, p_149690_3_, p_149690_4_, p_149690_5_, p_149690_6_, p_149690_7_);
-	}
-	
-	@Override
-	public float getBlockHardness(World p_149712_1_, int p_149712_2_, int p_149712_3_, int p_149712_4_) {
-		return ore.getBlockHardness(p_149712_1_, p_149712_2_, p_149712_3_, p_149712_4_);
-	}
-	
-	@Override
-	public int getExpDrop(IBlockAccess world, int metadata, int fortune) {
-		return ore.getExpDrop(world, metadata, fortune);
-	}
-	
-	@Override
-	public float getExplosionResistance(Entity p_149638_1_) {
-		return ore.getExplosionResistance(p_149638_1_);
-	}
-	
-	@Override
-	public float getExplosionResistance(Entity par1Entity, World world, int x, int y, int z, double explosionX, double explosionY, double explosionZ) {
-		return ore.getExplosionResistance(par1Entity, world, x, y, z, explosionX, explosionY, explosionZ);
-	}
-	
-	@Override
-	public int getLightOpacity(IBlockAccess world, int x, int y, int z) {
-		return ore.getLightOpacity();
-	}
-	
-	@Override
-	public int getLightValue() {
-		return ore.getLightValue();
-	}
-	
-	@Override
-	public int getLightValue(IBlockAccess world, int x, int y, int z) {
-		return ore.getLightValue();
-	}
-	
-	@Override
-	public void harvestBlock(World p_149636_1_, EntityPlayer p_149636_2_, int p_149636_3_, int p_149636_4_, int p_149636_5_, int p_149636_6_) {
-		ore.harvestBlock(p_149636_1_, p_149636_2_, p_149636_3_, p_149636_4_, p_149636_5_, p_149636_6_);
-	}
-	
-	@Override
-	public boolean canHarvestBlock(EntityPlayer player, int meta) {
-		return ore.canHarvestBlock(player, 0);
-	}
-	
-	@Override
-	public void updateTick(World p_149674_1_, int p_149674_2_, int p_149674_3_, int p_149674_4_, Random p_149674_5_) {
-		ore.updateTick(p_149674_1_, p_149674_2_, p_149674_3_, p_149674_4_, p_149674_5_);
-	}
-	
-	@Override
-	public ItemStack getPickBlock(MovingObjectPosition target, World world, int x, int y, int z) {
-		Item item = getItem(world, x, y, z);
-		if (item == null) {
-			return null;
-		}
-		return new ItemStack(item, 1, getDamageValue(world, x, y, z));
-	}
-	
-	@Override
-	public int damageDropped(int metadata) {
-		return metadata;
-	}
-	
-	@Override
-	public boolean canEntityDestroy(IBlockAccess world, int x, int y, int z, Entity entity) {
-		return ore.canEntityDestroy(world, x, y, z, entity);
-	}
-	
-	@Override
-	public void onBlockDestroyedByPlayer(World p_149664_1_, int p_149664_2_, int p_149664_3_, int p_149664_4_, int p_149664_5_) {
-		ore.onBlockDestroyedByPlayer(p_149664_1_, p_149664_2_, p_149664_3_, p_149664_4_, p_149664_5_);
-	}
-	
-	@Override
-	public boolean onBlockEventReceived(World p_149696_1_, int p_149696_2_, int p_149696_3_, int p_149696_4_, int p_149696_5_, int p_149696_6_) {
-		return ore.onBlockEventReceived(p_149696_1_, p_149696_2_, p_149696_3_, p_149696_4_, p_149696_5_, p_149696_6_);
-	}
+public class BlockUBHidden extends Block implements BlockUBReplaceable {
+
+    protected final BlockMetadataBase stone;
+    protected final Block ore;
+    private final MinecraftName oreName;
+
+    public BlockUBHidden(BlockMetadataBase stone, final Block ore) {
+        this(stone,ore,new MinecraftName(ore.getUnlocalizedName()));
+    }
+
+    public BlockUBHidden(BlockMetadataBase stone, Block ore,MinecraftName oreName) {
+        super(Material.rock);
+        this.stone = stone;
+        this.ore = ore;
+        if (ore instanceof BlockUBOre) {
+            throw new RuntimeException();
+        }
+
+        //renderIDSource = null;
+        this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+        this.oreName = oreName;
+    }
+    
+    public Block block() {return this;}
+
+    @Override
+    public void registerBlockIcons(IIconRegister p_149651_1_) {
+        //super.registerBlockIcons(p_149651_1_);
+    }
+    @SideOnly(Side.CLIENT)
+    @Override
+    public IIcon getIcon(int side, int metadata){
+        return stone.getIcon(side,metadata);
+    }
+
+    @SideOnly(Side.CLIENT)
+    @Override
+    protected String getTextureName(){
+        return stone.getTextureName();
+    }
+
+    @Override
+    public void getSubBlocks(Item id, CreativeTabs tabs, List list){
+        // if UB ores is off nothing in the tabs
+        if (UndergroundBiomes.ubOres() == false) return;
+        for (int i = 0; i < BlockMetadataBase.metadatas; i++){
+            list.add(new ItemStack(id, 1, i));
+        }
+    }
+
+    @Override
+    public ArrayList<ItemStack> getDrops(World world, int x, int y, int z, int metadata, int fortune){
+        return ore.getDrops(world, x, y, z, metadata, fortune);
+    }
+
+    @Override
+    public String getItemIconName() {
+        return stone.getItemIconName()+" " + oreName.localized();
+    }
+
+    public String getDisplayName(int meta) {
+        return stone.getBlockName(meta);
+    }
+
+    public String getUnlocalizedName(int meta) {
+        return stone.getBlockName(meta);
+    }
+
+    @Override
+    public void dropXpOnBlockBreak(World p_149657_1_, int p_149657_2_, int p_149657_3_, int p_149657_4_, int p_149657_5_) {
+        ore.dropXpOnBlockBreak(p_149657_1_, p_149657_2_, p_149657_3_, p_149657_4_, p_149657_5_);
+    }
+
+    @Override
+    public void dropBlockAsItemWithChance(World p_149690_1_, int p_149690_2_, int p_149690_3_, int p_149690_4_, int p_149690_5_, float p_149690_6_, int p_149690_7_) {
+        ore.dropBlockAsItemWithChance(p_149690_1_, p_149690_2_, p_149690_3_, p_149690_4_, p_149690_5_, p_149690_6_, p_149690_7_);
+    }
+
+    @Override
+    public float getBlockHardness(World p_149712_1_, int p_149712_2_, int p_149712_3_, int p_149712_4_) {
+        return ore.getBlockHardness(p_149712_1_, p_149712_2_, p_149712_3_, p_149712_4_);
+    }
+
+    @Override
+    public int getExpDrop(IBlockAccess world, int metadata, int fortune) {
+        return ore.getExpDrop(world, metadata, fortune);
+    }
+
+    @Override
+    public float getExplosionResistance(Entity p_149638_1_) {
+        return ore.getExplosionResistance(p_149638_1_);
+    }
+
+    @Override
+    public float getExplosionResistance(Entity par1Entity, World world, int x, int y, int z, double explosionX, double explosionY, double explosionZ) {
+        return ore.getExplosionResistance(par1Entity, world, x, y, z, explosionX, explosionY, explosionZ);
+    }
+
+    @Override
+    public int getLightOpacity(IBlockAccess world, int x, int y, int z) {
+        return ore.getLightOpacity();
+    }
+
+    @Override
+    public int getLightValue() {
+        return ore.getLightValue();
+    }
+
+    @Override
+    public int getLightValue(IBlockAccess world, int x, int y, int z) {
+        return ore.getLightValue();
+    }
+
+    @Override
+    public void harvestBlock(World p_149636_1_, EntityPlayer p_149636_2_, int p_149636_3_, int p_149636_4_, int p_149636_5_, int p_149636_6_) {
+        ore.harvestBlock(p_149636_1_, p_149636_2_, p_149636_3_, p_149636_4_, p_149636_5_, p_149636_6_);
+    }
+
+
+    @Override
+    public boolean canHarvestBlock(EntityPlayer player, int meta) {
+        return ore.canHarvestBlock(player, 0);
+    }
+
+    @Override
+    public void updateTick(World p_149674_1_, int p_149674_2_, int p_149674_3_, int p_149674_4_, Random p_149674_5_) {
+        ore.updateTick(p_149674_1_, p_149674_2_, p_149674_3_, p_149674_4_, p_149674_5_);
+    }
+
+    @Override
+    public ItemStack getPickBlock(MovingObjectPosition target, World world, int x, int y, int z) {
+        Item item = getItem(world, x, y, z);
+        if (item == null){
+            return null;
+        }
+        return new ItemStack(item, 1, getDamageValue(world, x, y, z));
+    }
+    public int damageDropped(int metadata){
+        return metadata;
+    }
+
+    @Override
+    public boolean canEntityDestroy(IBlockAccess world, int x, int y, int z, Entity entity) {
+        return ore.canEntityDestroy(world, x, y, z, entity);
+    }
+
+    @Override
+    public void onBlockDestroyedByPlayer(World p_149664_1_, int p_149664_2_, int p_149664_3_, int p_149664_4_, int p_149664_5_) {
+        ore.onBlockDestroyedByPlayer(p_149664_1_, p_149664_2_, p_149664_3_, p_149664_4_, p_149664_5_);
+    }
+
+    @Override
+    public boolean onBlockEventReceived(World p_149696_1_, int p_149696_2_, int p_149696_3_, int p_149696_4_, int p_149696_5_, int p_149696_6_) {
+        return ore.onBlockEventReceived(p_149696_1_, p_149696_2_, p_149696_3_, p_149696_4_, p_149696_5_, p_149696_6_);
+    }
 
 }
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBMetadataOre.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBMetadataOre.java
index 8fdac6c..df5944b 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBMetadataOre.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBMetadataOre.java
@@ -1,20 +2,25 @@
 package exterminatorJeff.undergroundBiomes.common.block;
 
 import Zeno410Utils.BlockState;
+import Zeno410Utils.MinecraftName;
 import Zeno410Utils.Mutable;
-
+import Zeno410Utils.Zeno410Logger;
 import java.util.ArrayList;
 import java.util.Random;
-
+import java.util.logging.Logger;
 import net.minecraft.block.Block;
+import net.minecraft.client.renderer.texture.IIconRegister;
+import net.minecraft.enchantment.EnchantmentHelper;
 import net.minecraft.entity.Entity;
 import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.item.ItemStack;
+import net.minecraft.stats.StatList;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
 import net.minecraft.world.biome.BiomeGenBase;
 import net.minecraftforge.common.util.ForgeDirection;
+import net.minecraftforge.event.ForgeEventFactory;
 
 /**
  *
@@ -22,173 +28,192 @@ import net.minecraftforge.common.util.ForgeDirection;
  */
 public class BlockUBMetadataOre extends BlockUBOre {
 
-	private final int oreMetadata;
-	private IBlockAccess currentAccess;
-	private IBlockAccess currentShamAccess;
-	
-	public BlockUBMetadataOre(BlockMetadataBase stone, BlockState ore, BlockOverlay overlay, Mutable<Integer> renderIDSource) {
-		super(stone, ore.block, overlay, renderIDSource);
-		oreMetadata = ore.metadata;
-	}
-	
-	@Override
-	public ArrayList<ItemStack> getDrops(World world, int x, int y, int z, int metadata, int fortune) {
-		return ore.getDrops(world, x, y, z, oreMetadata, fortune);
-	}
-	
-	private IBlockAccess iBlockAccess(IBlockAccess toWrap) {
-		if (toWrap != currentAccess) {
-			currentAccess = toWrap;
-			currentShamAccess = new ThisBlockAccess(toWrap);
-		}
-		return currentShamAccess;
-	}
-	
-	@Override
-	public String getDisplayName(int meta) {
-		ItemStack itemStack = new ItemStack(ore, 1, oreMetadata);
-		return stone.getBlockName(meta) + " " + itemStack.getDisplayName();
-	}
-	
-	@Override
-	public void dropXpOnBlockBreak(World world, int x, int y, int z, int p_149657_5_) {
-		int stoneMetadata = world.getBlockMetadata(x, y, z);
-		world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
-		ore.dropXpOnBlockBreak(world, x, y, z, p_149657_5_);
-		world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
-	}
-	
-	@Override
-	public void dropBlockAsItemWithChance(World world, int x, int y, int z, int p_149690_5_, float p_149690_6_, int p_149690_7_) {
-		super.dropBlockAsItemWithChance(world, x, y, z, oreMetadata, p_149690_6_, p_149690_7_);
-	}
-	
-	@Override
-	public float getBlockHardness(World world, int x, int y, int z) {
-		int stoneMetadata = world.getBlockMetadata(x, y, z);
-		world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
-		float result = ore.getBlockHardness(world, x, y, z);
-		world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
-		return result;
-	}
-	
-	@Override
-	public int getExpDrop(IBlockAccess world, int metadata, int fortune) {
-		return ore.getExpDrop(iBlockAccess(world), metadata, fortune);
-	}
-	
-	@Override
-	public float getExplosionResistance(Entity par1Entity, World world, int x, int y, int z, double explosionX, double explosionY, double explosionZ) {
-		int stoneMetadata = world.getBlockMetadata(x, y, z);
-		world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
-		float result = ore.getExplosionResistance(par1Entity, world, x, y, z, explosionX, explosionY, explosionZ);
-		world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
-		return result;
-	}
-	
-	@Override
-	public int getLightOpacity(IBlockAccess world, int x, int y, int z) {
-		return ore.getLightOpacity();
-	}
-	
-	@Override
-	public int getLightValue() {
-		return ore.getLightValue();
-	}
-	
-	@Override
-	public int getLightValue(IBlockAccess world, int x, int y, int z) {
-		return ore.getLightValue();
-	}
-	
-	@Override
-	public void harvestBlock(World world, EntityPlayer p_149636_2_, int x, int y, int z, int p_149636_6_) {
-		super.harvestBlock(world, p_149636_2_, x, y, z, oreMetadata);
-	}
-	
-	@Override
-	public boolean canHarvestBlock(EntityPlayer player, int meta) {
-		return ore.canHarvestBlock(player, oreMetadata);
-	}
-	
-	@Override
-	public void updateTick(World world, int x, int y, int z, Random p_149674_5_) {
-		int stoneMetadata = world.getBlockMetadata(x, y, z);
-		world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
-		ore.updateTick(world, x, y, z, p_149674_5_);
-		world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
-	}
-	
-	@Override
-	public void randomDisplayTick(World world, int x, int y, int z, Random p_149734_5_) {
-		int stoneMetadata = world.getBlockMetadata(x, y, z);
-		world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
-		super.randomDisplayTick(world, x, y, z, p_149734_5_);
-		world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
-	}
-	
-	private class ThisBlockAccess implements IBlockAccess {
-		private final IBlockAccess wrapped;
-		int x;
-		int y;
-		int z;
-		
-		ThisBlockAccess(IBlockAccess wrapped) {
-			this.wrapped = wrapped;
-		}
-		
-		@Override
-		public Block getBlock(int arg0, int arg1, int arg2) {
-			if ((arg0 == x) && (arg1 == y) && (arg2 == z))
-				return BlockUBMetadataOre.this;
-			return wrapped.getBlock(arg0, arg1, arg2);
-		}
-		
-		@Override
-		public TileEntity getTileEntity(int arg0, int arg1, int arg2) {
-			return wrapped.getTileEntity(arg0, arg1, arg2);
-		}
-		
-		@Override
-		public int getLightBrightnessForSkyBlocks(int arg0, int arg1, int arg2, int arg3) {
-			return wrapped.getLightBrightnessForSkyBlocks(arg0, arg1, arg2, arg3);
-		}
-		
-		@Override
-		public int getBlockMetadata(int arg0, int arg1, int arg2) {
-			if ((arg0 == x) && (arg1 == y) && (arg2 == z))
-				return oreMetadata;
-			return wrapped.getBlockMetadata(arg0, arg1, arg2);
-		}
-		
-		@Override
-		public boolean isAirBlock(int arg0, int arg1, int arg2) {
-			return wrapped.isAirBlock(arg0, arg1, arg2);
-		}
-		
-		@Override
-		public BiomeGenBase getBiomeGenForCoords(int arg0, int arg1) {
-			return wrapped.getBiomeGenForCoords(arg0, arg1);
-		}
-		
-		@Override
-		public int getHeight() {
-			return wrapped.getHeight();
-		}
-		
-		@Override
-		public boolean extendedLevelsInChunkCache() {
-			return wrapped.extendedLevelsInChunkCache();
-		}
-		
-		@Override
-		public int isBlockProvidingPowerTo(int arg0, int arg1, int arg2, int arg3) {
-			return wrapped.isBlockProvidingPowerTo(arg0, arg1, arg2, arg3);
-		}
-		
-		@Override
-		public boolean isSideSolid(int arg0, int arg1, int arg2, ForgeDirection arg3, boolean arg4) {
-			return wrapped.isSideSolid(arg0, arg1, arg2, arg3, arg4);
-		}
-	}
+    public static Logger logger = new Zeno410Logger("BlockUBMetadataOre").logger();
+
+    private final int oreMetadata;
+    private IBlockAccess currentAccess;
+    private IBlockAccess currentShamAccess;
+
+    public BlockUBMetadataOre(BlockMetadataBase stone, BlockState ore, BlockOverlay overlay, 
+            Mutable<Integer> renderIDSource, MinecraftName oreName) {
+        super(stone,ore.block,overlay,renderIDSource,oreName);
+        oreMetadata = ore.metadata;
+    }
+    @Override
+    public ArrayList<ItemStack> getDrops(World world, int x, int y, int z, int metadata, int fortune){
+        //logger.info("Getting drops "+oreMetadata);
+        return ore.getDrops(world, x, y, z, oreMetadata, fortune);
+    }
+
+    @Override
+    public void registerBlockIcons(IIconRegister iconRegister) {
+        super.registerBlockIcons(iconRegister);
+    }
+
+    private IBlockAccess iBlockAccess(IBlockAccess toWrap) {
+        if (toWrap != currentAccess) {
+            currentAccess = toWrap;
+            currentShamAccess = new ThisBlockAccess(toWrap);
+        }
+        return currentShamAccess;
+    }
+
+    @Override
+    public void dropXpOnBlockBreak(World world, int x, int y, int z, int p_149657_5_) {
+        int stoneMetadata = world.getBlockMetadata(x, y, z);
+        world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
+        ore.dropXpOnBlockBreak(world, x, y, z, p_149657_5_);
+        world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
+    }
+
+    @Override
+    public void dropBlockAsItemWithChance(World world, int x, int y, int z, int p_149690_5_, float p_149690_6_, int p_149690_7_) {
+        super.dropBlockAsItemWithChance(world, x, y, z, oreMetadata, p_149690_6_, p_149690_7_);
+    }
+
+    @Override
+    public float getBlockHardness(World world, int x, int y, int z) {
+        int stoneMetadata = world.getBlockMetadata(x, y, z);
+        world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
+        float result =  ore.getBlockHardness(world, x, y, z);
+        world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
+        return result;
+    }
+
+    @Override
+    public int getExpDrop(IBlockAccess world, int metadata, int fortune) {
+        return ore.getExpDrop(iBlockAccess(world), oreMetadata, fortune);
+    }
+
+    @Override
+    public float getExplosionResistance(Entity par1Entity, World world, int x, int y, int z, double explosionX, double explosionY, double explosionZ) {
+        int stoneMetadata = world.getBlockMetadata(x, y, z);
+        world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
+        float result =  ore.getExplosionResistance(par1Entity, world, x, y, z, explosionX, explosionY, explosionZ);
+        world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
+        return result;
+    }
+
+    @Override
+    public int getLightOpacity(IBlockAccess world, int x, int y, int z) {
+        return ore.getLightOpacity();
+    }
+
+    @Override
+    public int getLightValue() {
+        return ore.getLightValue();
+    }
+
+    @Override
+    public int getLightValue(IBlockAccess world, int x, int y, int z) {
+        return ore.getLightValue();
+    }
+
+    @Override
+    public void harvestBlock(World world, EntityPlayer p_149636_2_, int x, int y, int z, int p_149636_6_) {
+        super.harvestBlock(world, p_149636_2_, x, y, z, oreMetadata);
+    }
+    
+    @Override
+    public int getHarvestLevel(int metadata) {
+        return ore.getHarvestLevel(oreMetadata);
+    }
+
+    @Override
+    public String getHarvestTool(int metadata) {
+        return ore.getHarvestTool(oreMetadata);
+    }
+
+    @Override
+    public boolean canHarvestBlock(EntityPlayer player, int meta) {
+        return ore.canHarvestBlock(player, oreMetadata);
+    }
+
+    @Override
+    public float getPlayerRelativeBlockHardness(EntityPlayer player, World world, int x, int y, int z) {        int metadata = world.getBlockMetadata(x, y, z);
+        float hardness = getBlockHardness(world, x, y, z);
+        if (hardness < 0.0F)
+        {
+            return 0.0F;
+        }
+
+        if (!canHarvestBlock(player, metadata))
+        {
+            return player.getBreakSpeed(this, true, metadata, x, y, z) / hardness / 100F;
+        }
+        else
+        {
+            return player.getBreakSpeed(this, false, metadata, x, y, z) / hardness / 30F;
+        }
+    }
+    
+    @Override
+    public void updateTick(World world, int x, int y, int z, Random p_149674_5_) {
+        int stoneMetadata = world.getBlockMetadata(x, y, z);
+        world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
+        ore.updateTick(world, x, y, z, p_149674_5_);
+        world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
+    }
+
+    @Override
+    public void randomDisplayTick(World world, int x, int y, int z, Random p_149734_5_) {
+        int stoneMetadata = world.getBlockMetadata(x, y, z);
+        world.setBlockMetadataWithNotify(x, y, z, oreMetadata, 0);
+        super.randomDisplayTick(world, x, y, z, p_149734_5_);
+        world.setBlockMetadataWithNotify(x, y, z, stoneMetadata, 0);
+    }
+    
+    private class ThisBlockAccess implements IBlockAccess {
+        private final IBlockAccess wrapped;
+        int x;
+        int y;
+        int z;
+
+        ThisBlockAccess(IBlockAccess wrapped) {
+            this.wrapped = wrapped;
+        }
+
+        public Block getBlock(int arg0, int arg1, int arg2) {
+            if ((arg0 == x)&&(arg1== y)&&(arg2 == z)) return BlockUBMetadataOre.this;
+            return wrapped.getBlock(arg0, arg1, arg2);
+        }
+
+        public TileEntity getTileEntity(int arg0, int arg1, int arg2) {
+            return wrapped.getTileEntity(arg0, arg1, arg2);
+        }
+
+        public int getLightBrightnessForSkyBlocks(int arg0, int arg1, int arg2, int arg3) {
+            return wrapped.getLightBrightnessForSkyBlocks(arg0, arg1, arg2, arg3);
+        }
+
+        public int getBlockMetadata(int arg0, int arg1, int arg2) {
+            if ((arg0 == x)&&(arg1== y)&&(arg2 == z)) return oreMetadata;
+            return wrapped.getBlockMetadata(arg0, arg1, arg2);
+        }
+
+        public boolean isAirBlock(int arg0, int arg1, int arg2) {
+            return wrapped.isAirBlock(arg0, arg1, arg2);
+        }
+
+        public BiomeGenBase getBiomeGenForCoords(int arg0, int arg1) {
+            return wrapped.getBiomeGenForCoords(arg0, arg1);
+        }
+
+        public int getHeight() {
+            return wrapped.getHeight();
+        }
+
+        public boolean extendedLevelsInChunkCache() {
+            return wrapped.extendedLevelsInChunkCache();
+        }
+
+        public int isBlockProvidingPowerTo(int arg0, int arg1, int arg2, int arg3) {
+            return wrapped.isBlockProvidingPowerTo(arg0, arg1, arg2, arg3);
+        }
+
+        public boolean isSideSolid(int arg0, int arg1, int arg2, ForgeDirection arg3, boolean arg4) {
+            return wrapped.isSideSolid(arg0, arg1, arg2, arg3, arg4);
+        }
+
+    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBOre.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBOre.java
index 99d1dac..8759613 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBOre.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBOre.java
@@ -4,12 +5,14 @@ import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 import Zeno410Utils.Mutable;
+import Zeno410Utils.MinecraftName;
 import exterminatorJeff.undergroundBiomes.constructs.util.ShamWorld;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Random;
 import net.minecraft.block.Block;
 import net.minecraft.block.material.Material;
+import net.minecraft.client.particle.EffectRenderer;
 import net.minecraft.client.renderer.texture.IIconRegister;
 import net.minecraft.creativetab.CreativeTabs;
 import net.minecraft.entity.Entity;
@@ -18,6 +21,7 @@ import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
 import net.minecraft.util.IIcon;
 import net.minecraft.util.MovingObjectPosition;
+import net.minecraft.util.StatCollector;
 import net.minecraft.world.IBlockAccess;
 import net.minecraft.world.World;
 import net.minecraft.world.WorldSettings;
@@ -26,171 +30,210 @@ import net.minecraft.world.WorldSettings;
  *
  * @author Zeno410
  */
-public class BlockUBOre extends Block {
-	
-	protected final BlockMetadataBase stone;
-	protected final Block ore;
-	private final BlockOverlay overlay;
-	private Mutable<Integer> renderIDSource;
-	protected ShamWorld shamWorld;
-	
-	public BlockUBOre(BlockMetadataBase stone, final Block ore, BlockOverlay overlay, Mutable<Integer> renderIDSource) {
-		this(stone, ore, overlay, renderIDSource, null);
-	}
-	
-	public BlockUBOre(BlockMetadataBase stone, Block ore, BlockOverlay overlay, Mutable<Integer> renderIDSource, Object deleteMe) {
-		super(Material.rock);
-		this.stone = stone;
-		this.ore = ore;
-		if (ore instanceof BlockUBOre) {
-			throw new RuntimeException();
-		}
-		this.renderIDSource = renderIDSource;
-		if (renderIDSource == null) {
-			if (UndergroundBiomes.crashOnProblems())
-				throw new RuntimeException();
-		}
-		this.overlay = overlay;
-		this.setCreativeTab(UndergroundBiomes.tabModBlocks);
-	}
-	
-	@Override
-	public int getRenderType() {
-		if (renderIDSource == null)
-			return 0;
-		Integer result = renderIDSource.value();
-		if (result == null)
-			return 0;
-		return result;
-	}
-	
-	@SideOnly(Side.CLIENT)
-	@Override
-	public void registerBlockIcons(IIconRegister iconRegister) {
-		// Block icons registered by UB blocks.
-		// overlay doesn't get its icon registered because *it* doesn't get registered;
-		overlay.registerBlockIcons(iconRegister);
-	}
-	
-	@SideOnly(Side.CLIENT)
-	@Override
-	public IIcon getIcon(int side, int metadata) {
-		return stone.getIcon(side, metadata);
-	}
-	
-	@SideOnly(Side.CLIENT)
-	@Override
-	protected String getTextureName() {
-		return stone.getTextureName();
-	}
-	
-	@Override
-	public void getSubBlocks(Item id, CreativeTabs tabs, List list) {
-		// if UB ores is off nothing in the tabs
-		if (UndergroundBiomes.ubOres() == false)
-			return;
-		for (int i = 0; i < BlockMetadataBase.metadatas; i++) {
-			list.add(new ItemStack(id, 1, i));
-		}
-	}
-	
-	protected ShamWorld shamWorld(World forSettings) {
-		if (shamWorld == null)
-			shamWorld = new ShamWorld(new WorldSettings(forSettings.getWorldInfo()));
-		return shamWorld;
-	}
-	
-	@Override
-	public ArrayList<ItemStack> getDrops(World world, int x, int y, int z, int metadata, int fortune) {
-		return ore.getDrops(world, x, y, z, metadata, fortune);
-	}
-	
-	@Override
-	public String getItemIconName() {
-		return stone.getItemIconName() + " " + ore.getItemIconName();
-	}
-	
-	public String getDisplayName(int meta) {
-		ItemStack itemStack = new ItemStack(ore, 1, 0);
-		return stone.getBlockName(meta) + " " + itemStack.getDisplayName();
-	}
-	
-	public String getUnlocalizedName(int meta) {
-		return stone.getBlockName(meta) + "." + ore.getUnlocalizedName();
-	}
-	
-	@Override
-	public void dropXpOnBlockBreak(World p_149657_1_, int p_149657_2_, int p_149657_3_, int p_149657_4_, int p_149657_5_) {
-		ore.dropXpOnBlockBreak(p_149657_1_, p_149657_2_, p_149657_3_, p_149657_4_, p_149657_5_);
-	}
-	
-	@Override
-	public void dropBlockAsItemWithChance(World p_149690_1_, int p_149690_2_, int p_149690_3_, int p_149690_4_, int p_149690_5_, float p_149690_6_, int p_149690_7_) {
-		ore.dropBlockAsItemWithChance(p_149690_1_, p_149690_2_, p_149690_3_, p_149690_4_, p_149690_5_, p_149690_6_, p_149690_7_);
-	}
-	
-	@Override
-	public float getBlockHardness(World p_149712_1_, int p_149712_2_, int p_149712_3_, int p_149712_4_) {
-		return ore.getBlockHardness(p_149712_1_, p_149712_2_, p_149712_3_, p_149712_4_);
-	}
-	
-	@Override
-	public int getExpDrop(IBlockAccess world, int metadata, int fortune) {
-		return ore.getExpDrop(world, metadata, fortune);
-	}
-	
-	@Override
-	public float getExplosionResistance(Entity p_149638_1_) {
-		return ore.getExplosionResistance(p_149638_1_);
-	}
-	
-	@Override
-	public float getExplosionResistance(Entity par1Entity, World world, int x, int y, int z, double explosionX, double explosionY, double explosionZ) {
-		return ore.getExplosionResistance(par1Entity, world, x, y, z, explosionX, explosionY, explosionZ);
-	}
-	
-	@Override
-	public int getLightOpacity(IBlockAccess world, int x, int y, int z) {
-		return ore.getLightOpacity();
-	}
-	
-	@Override
-	public int getLightValue() {
-		return ore.getLightValue();
-	}
-	
-	@Override
-	public int getLightValue(IBlockAccess world, int x, int y, int z) {
-		return ore.getLightValue();
-	}
-	
-	@Override
-	public void harvestBlock(World p_149636_1_, EntityPlayer p_149636_2_, int p_149636_3_, int p_149636_4_, int p_149636_5_, int p_149636_6_) {
-		ore.harvestBlock(p_149636_1_, p_149636_2_, p_149636_3_, p_149636_4_, p_149636_5_, p_149636_6_);
-	}
-	
-	@Override
-	public boolean canHarvestBlock(EntityPlayer player, int meta) {
-		return ore.canHarvestBlock(player, 0);
-	}
-	
-	@Override
-	public void updateTick(World p_149674_1_, int p_149674_2_, int p_149674_3_, int p_149674_4_, Random p_149674_5_) {
-		ore.updateTick(p_149674_1_, p_149674_2_, p_149674_3_, p_149674_4_, p_149674_5_);
-	}
-	
-	@Override
-	public ItemStack getPickBlock(MovingObjectPosition target, World world, int x, int y, int z) {
-		Item item = getItem(world, x, y, z);
-		if (item == null) {
-			return null;
-		}
-		return new ItemStack(item, 1, getDamageValue(world, x, y, z));
-	}
-	
-	@Override
-	public int damageDropped(int metadata) {
-		return metadata;
-	}
+public class BlockUBOre extends Block implements BlockUBReplaceable {
+
+    protected final BlockMetadataBase stone;
+    protected final Block ore;
+    private final BlockOverlay overlay;
+    private Mutable<Integer> renderIDSource;
+    protected ShamWorld shamWorld;
+    private final MinecraftName oreName;
+
+    public BlockUBOre(BlockMetadataBase stone, final Block ore, BlockOverlay overlay, Mutable<Integer> renderIDSource) {
+        this(stone,ore,overlay,renderIDSource,new MinecraftName(ore.getUnlocalizedName()));
+    }
+
+    public BlockUBOre(BlockMetadataBase stone, Block ore, BlockOverlay overlay,
+            Mutable<Integer> renderIDSource,MinecraftName oreName) {
+        super(Material.rock);
+        this.stone = stone;
+        this.ore = ore;
+        if (ore instanceof BlockUBOre) {
+            throw new RuntimeException();
+        }
+        this.renderIDSource = renderIDSource;
+        if (renderIDSource == null) {
+            if (UndergroundBiomes.crashOnProblems()) throw new RuntimeException();
+        }
+        //renderIDSource = null;
+        this.overlay = overlay;
+        this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+        this.oreName = oreName;
+
+    }
+
+    public Block block() {return this;}
+
+    @Override
+    public int getRenderType() {
+        if (renderIDSource == null) return 0;
+        Integer result = renderIDSource.value();
+        if (result == null) return 0;
+        return result;
+    }
+
+    @SideOnly(Side.CLIENT)
+    @Override
+    public void registerBlockIcons(IIconRegister iconRegister){
+        // Block icons registered by UB blocks.
+        // overlay doesn't get its icon registered because *it* doesn't get registered;
+        overlay.registerBlockIcons(iconRegister);
+    }
+
+    @SideOnly(Side.CLIENT)
+    @Override
+    public IIcon getIcon(int side, int metadata){
+        return stone.getIcon(side,metadata);
+    }
+
+    @SideOnly(Side.CLIENT)
+    @Override
+    protected String getTextureName(){
+        return stone.getTextureName();
+    }
+
+    @Override
+    public void getSubBlocks(Item id, CreativeTabs tabs, List list){
+        // if UB ores is off nothing in the tabs
+        if (UndergroundBiomes.ubOres() == false) return;
+        for (int i = 0; i < BlockMetadataBase.metadatas; i++){
+            list.add(new ItemStack(id, 1, i));
+        }
+    }
+
+    @Override
+    public ArrayList<ItemStack> getDrops(World world, int x, int y, int z, int metadata, int fortune){
+        return ore.getDrops(world, x, y, z, metadata, fortune);
+    }
+
+    @Override
+    public String getItemIconName() {
+        return stone.getItemIconName()+" " + oreName.localized();
+    }
+
+    public String getDisplayName(int meta) {
+        return StatCollector.translateToLocal(stone.getUnlocalizedName()+"."
+                +stone.getBlockName(meta)+".name")+ " " + oreName.localized();
+    }
+
+    public String getUnlocalizedName(int meta) {
+        return stone.getBlockName(meta)+ "."+ oreName.unlocalized();
+    }
+
+    @Override
+    public void dropXpOnBlockBreak(World p_149657_1_, int p_149657_2_, int p_149657_3_, int p_149657_4_, int p_149657_5_) {
+        ore.dropXpOnBlockBreak(p_149657_1_, p_149657_2_, p_149657_3_, p_149657_4_, p_149657_5_);
+    }
+
+    @Override
+    public void dropBlockAsItemWithChance(World p_149690_1_, int p_149690_2_, int p_149690_3_, int p_149690_4_, int p_149690_5_, float p_149690_6_, int p_149690_7_) {
+        ore.dropBlockAsItemWithChance(p_149690_1_, p_149690_2_, p_149690_3_, p_149690_4_, p_149690_5_, p_149690_6_, p_149690_7_);
+    }
+
+    @Override
+    public float getBlockHardness(World p_149712_1_, int p_149712_2_, int p_149712_3_, int p_149712_4_) {
+        return ore.getBlockHardness(p_149712_1_, p_149712_2_, p_149712_3_, p_149712_4_);
+    }
+
+    @Override
+    public int getExpDrop(IBlockAccess world, int metadata, int fortune) {
+        return ore.getExpDrop(world, metadata, fortune);
+    }
+
+    @Override
+    public float getExplosionResistance(Entity p_149638_1_) {
+        return ore.getExplosionResistance(p_149638_1_);
+    }
+
+    @Override
+    public float getExplosionResistance(Entity par1Entity, World world, int x, int y, int z, double explosionX, double explosionY, double explosionZ) {
+        return ore.getExplosionResistance(par1Entity, world, x, y, z, explosionX, explosionY, explosionZ);
+    }
+
+    @Override
+    public int getLightOpacity(IBlockAccess world, int x, int y, int z) {
+        return ore.getLightOpacity();
+    }
+
+    @Override
+    public int getLightValue() {
+        return ore.getLightValue();
+    }
+
+    @Override
+    public int getLightValue(IBlockAccess world, int x, int y, int z) {
+        return ore.getLightValue();
+    }
+
+    @Override
+    public void harvestBlock(World p_149636_1_, EntityPlayer p_149636_2_, int p_149636_3_, int p_149636_4_, int p_149636_5_, int p_149636_6_) {
+        ore.harvestBlock(p_149636_1_, p_149636_2_, p_149636_3_, p_149636_4_, p_149636_5_, p_149636_6_);
+    }
+
+
+    @Override
+    public boolean canHarvestBlock(EntityPlayer player, int meta) {
+        return ore.canHarvestBlock(player, 0);
+    }
+    
+    @Override
+    public void updateTick(World p_149674_1_, int p_149674_2_, int p_149674_3_, int p_149674_4_, Random p_149674_5_) {
+        ore.updateTick(p_149674_1_, p_149674_2_, p_149674_3_, p_149674_4_, p_149674_5_);
+    }
+
+    @Override
+    public ItemStack getPickBlock(MovingObjectPosition target, World world, int x, int y, int z) {
+        Item item = getItem(world, x, y, z);
+        if (item == null){
+            return null;
+        }
+        return new ItemStack(item, 1, getDamageValue(world, x, y, z));
+    }
+    public int damageDropped(int metadata){
+        return metadata;
+    }
+
+    @Override
+    public boolean canEntityDestroy(IBlockAccess world, int x, int y, int z, Entity entity) {
+        return ore.canEntityDestroy(world, x, y, z, entity);
+    }
+
+    @Override
+    public boolean addDestroyEffects(World world, int x, int y, int z, int meta, EffectRenderer effectRenderer) {
+        return super.addDestroyEffects(world, x, y, z, meta, effectRenderer);
+    }
+    
+    @Override
+    public int getHarvestLevel(int metadata) {
+        return ore.getHarvestLevel(0);
+    }
+
+    @Override
+    public String getHarvestTool(int metadata) {
+        return ore.getHarvestTool(0);
+    }
+
+    @Override
+    public float getPlayerRelativeBlockHardness(EntityPlayer player, World world, int x, int y, int z) {        int metadata = world.getBlockMetadata(x, y, z);
+        float hardness = getBlockHardness(world, x, y, z);
+        if (hardness < 0.0F)
+        {
+            return 0.0F;
+        }
+
+        if (!canHarvestBlock(player, metadata))
+        {
+            return player.getBreakSpeed(this, true, metadata, x, y, z) / hardness / 100F;
+        }
+        else
+        {
+            return player.getBreakSpeed(this, false, metadata, x, y, z) / hardness / 30F;
+        }
+    }
+    
+    @Override
+    public void onBlockClicked(World p_149699_1_, int p_149699_2_, int p_149699_3_, int p_149699_4_, EntityPlayer p_149699_5_) {
+        ore.onBlockClicked(p_149699_1_, p_149699_2_, p_149699_3_, p_149699_4_, p_149699_5_);
+    }
 
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBReplaceable.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBReplaceable.java
new file mode 100644
index 0000000..4d560e2
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/BlockUBReplaceable.java
@@ -0,0 +1,13 @@
+
+package exterminatorJeff.undergroundBiomes.common.block;
+
+import net.minecraft.block.Block;
+
+/**
+ *
+ * @author Zeno410
+ */
+public interface BlockUBReplaceable {
+    public Block block();
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/UBStoneTextureProvider.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/UBStoneTextureProvider.java
index 79546a1..00d6035 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/block/UBStoneTextureProvider.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/block/UBStoneTextureProvider.java
@@ -1,5 +1,6 @@
 package exterminatorJeff.undergroundBiomes.common.block;
 import net.minecraft.block.Block;
+import net.minecraft.client.renderer.texture.IIconRegister;
 import net.minecraft.util.IIcon;
 import net.minecraft.block.material.Material;
 
@@ -17,6 +18,10 @@ public class UBStoneTextureProvider extends Block {
     }
 
     @Override
+    public void registerBlockIcons(IIconRegister p_149651_1_) {
+        //super.registerBlockIcons(p_149651_1_);
+    }
+    @Override
    public IIcon getIcon(int side, int meta){
        UndergroundBiomesBlock block = UndergroundBiomesBlockList.indexed(meta);
        return block.icon();
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/command/CommandOreDictifyStone.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/command/CommandOreDictifyStone.java
index 23af334..b5fc710 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/command/CommandOreDictifyStone.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/command/CommandOreDictifyStone.java
@@ -2,39 +2,40 @@ package exterminatorJeff.undergroundBiomes.common.command;
 
 import net.minecraft.command.CommandBase;
 import net.minecraft.command.ICommandSender;
-import net.minecraft.util.ChatComponentText;
-import net.minecraft.util.EnumChatFormatting;
-import net.minecraft.util.StatCollector;
+
 import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 
-public class CommandOreDictifyStone extends CommandBase {
-	
-	public CommandOreDictifyStone() {
-	}
-	
-	@Override
-	public int compareTo(Object compared) {
-		return this.toString().compareTo(compared.toString());
-	}
-	
-	@Override
-	public String getCommandName() {
-		return "oredictifystone";
-	}
-	
-	@Override
-	public String getCommandUsage(ICommandSender par1ICommandSender) {
-		return "/" + this.getCommandName();
-	}
-	
-	@Override
-	public void processCommand(ICommandSender sender, String as[]) {
-		try {
-			int num = UndergroundBiomes.oreDictifyStone();
-			sender.addChatMessage(new ChatComponentText("" + EnumChatFormatting.GREEN).appendText(StatCollector.translateToLocalFormatted("commands.oredictifystone.ok", num)));
-		} catch (Exception exception) {
-			sender.addChatMessage(new ChatComponentText("" + EnumChatFormatting.GREEN).appendText(StatCollector.translateToLocalFormatted("commands.oredictifystone.fail")));
-			exception.printStackTrace();
-		}
-	}
+public class CommandOreDictifyStone extends CommandBase
+{
+
+    public CommandOreDictifyStone(){}
+
+    public int compareTo(Object compared) {
+        return this.toString().compareTo(compared.toString());
+    }
+
+
+    public String getCommandName(){
+        return "oredictifystone";
+    }
+
+    public String getCommandUsage(ICommandSender par1ICommandSender){
+        return "/" + this.getCommandName();
+    }
+
+    public void processCommand(ICommandSender sender, String as[])
+    {
+        try
+        {
+            int num = UndergroundBiomes.oreDictifyStone();
+            //sender.func_110122_a(ChatMessageComponent.func_111077_e(String.format("commands.oredictifystone.ok", num)).func_111059_a(EnumChatFormatting.GREEN));
+            //sender.sendChatToPlayer(String.format("\u00a7aStone OreDictify complete, modified %d recipes.", num));
+        }
+        catch (Exception e)
+        {
+            //sender.func_110122_a(ChatMessageComponent.func_111077_e("commands.oredictifystone.fail").func_111059_a(EnumChatFormatting.RED));
+            //sender.sendChatToPlayer("\u00a7cStone OreDictify has failed!");
+            e.printStackTrace();
+        }
+    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/item/ItemUBHiddenBlock.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/item/ItemUBHiddenBlock.java
index 1073ec9..747ce60 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/item/ItemUBHiddenBlock.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/item/ItemUBHiddenBlock.java
@@ -13,11 +13,14 @@ import net.minecraft.util.IIcon;
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 
+import net.minecraft.util.StatCollector;
+
 import exterminatorJeff.undergroundBiomes.api.NamedBlock;
 import exterminatorJeff.undergroundBiomes.api.NamedItem;
 import exterminatorJeff.undergroundBiomes.common.block.BlockUBHidden;
 import net.minecraft.entity.player.EntityPlayer;
 
+import net.minecraft.item.Item;
 import net.minecraft.world.World;
 
 public class ItemUBHiddenBlock  extends ItemBlock {
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/item/ItemUBOreBlock.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/item/ItemUBOreBlock.java
index 562bbc6..a08aa51 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/common/item/ItemUBOreBlock.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/common/item/ItemUBOreBlock.java
@@ -12,66 +13,79 @@ import net.minecraft.util.IIcon;
 import cpw.mods.fml.relauncher.Side;
 import cpw.mods.fml.relauncher.SideOnly;
 
+import net.minecraft.util.StatCollector;
+
 import exterminatorJeff.undergroundBiomes.api.NamedBlock;
 import exterminatorJeff.undergroundBiomes.api.NamedItem;
+import exterminatorJeff.undergroundBiomes.common.block.BlockOverlay;
 import exterminatorJeff.undergroundBiomes.common.block.BlockUBOre;
 import net.minecraft.entity.player.EntityPlayer;
 
+import net.minecraft.item.Item;
 import net.minecraft.world.World;
 
-public class ItemUBOreBlock extends ItemBlock {
-	private static HashMap<String, ItemMetadataBlock> namedBlocks = new HashMap<String, ItemMetadataBlock>();
-	private BlockUBOre theBlock;
-	
-	public static ItemMetadataBlock itemFrom(NamedBlock namer) {
-		return namedBlocks.get(new NamedItem(namer).internal());
-	}
-	
-	public ItemUBOreBlock(Block block) {
-		super(block);
-		BlockUBOre baseBlock = (BlockUBOre) block;
-		this.theBlock = baseBlock;
-		//itemName.register(namedBlock.ID(), this);
-		this.setMaxDamage(0);
-		this.setHasSubtypes(true);
-	}
-	
-	@SideOnly(Side.CLIENT)
-	@Override
-	public IIcon getIconFromDamage(int meta) {
-		return theBlock.getIcon(2, meta);
-	}
-	
-	@Override
-	public String getItemStackDisplayName(ItemStack stack) {
-		return theBlock.getDisplayName(stack.getItemDamage());
-	}
-	
-	@Override
-	public String getUnlocalizedName(ItemStack stack) {
-		return theBlock.getUnlocalizedName(stack.getItemDamage());
-	}
-	
-	@Override
-	public boolean isFull3D() {
-		return true;
-	}
-	
-	@Override
-	public int getSpriteNumber() {
-		return 0;
-	}
-	
-	@Override
-	public boolean placeBlockAt(ItemStack stack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ, int metadata) {
-		metadata = stack.getItemDamage();
-		if (!world.setBlock(x, y, z, theBlock, metadata, 3)) {
-			return false;
-		}
-		if (world.getBlock(x, y, z) == theBlock) {
-			theBlock.onBlockPlacedBy(world, x, y, z, player, stack);
-			theBlock.onPostBlockPlaced(world, x, y, z, metadata);
-		}
-		return true;
-	}
+public class ItemUBOreBlock  extends ItemBlock {
+    private static HashMap<String,ItemMetadataBlock> namedBlocks = new HashMap<String,ItemMetadataBlock>();
+    private BlockUBOre theBlock;
+
+    public static ItemMetadataBlock itemFrom(NamedBlock namer) {
+        return namedBlocks.get(new NamedItem(namer).internal());
+    }
+
+    public ItemUBOreBlock(Block block){
+        super(block);
+        BlockUBOre baseBlock = (BlockUBOre)block;
+        this.theBlock = baseBlock;
+        //itemName.register(namedBlock.ID(), this);
+        this.setMaxDamage(0);
+        this.setHasSubtypes(true);
+    }
+
+
+    @SideOnly(Side.CLIENT)
+    @Override
+    public IIcon getIconFromDamage(int meta){
+        return theBlock.getIcon(2, meta);
+    }
+
+
+    @Override
+    public String getItemStackDisplayName(ItemStack stack) {
+
+        return theBlock.getDisplayName(stack.getItemDamage());
+        //String result =  super.getItemStackDisplayName(par1ItemStack);
+        //String lookup =  "tile." +result.split(":")[1];
+        //String lookup = result;
+        //return ("" + StatCollector.translateToLocal(lookup)).trim();
+    }
+
+    @Override
+    public String getUnlocalizedName(ItemStack stack) {
+        return theBlock.getUnlocalizedName(stack.getItemDamage());
+    }
+
+    @Override
+    public boolean isFull3D() {
+        return true;
+    }
+
+    @Override
+    public int getSpriteNumber() {
+        return 0;
+    }
+
+    @Override
+    public boolean placeBlockAt(ItemStack stack, EntityPlayer player, World world, int x, int y, int z, int side, float hitX, float hitY, float hitZ, int metadata){
+       metadata = stack.getItemDamage();
+       if (!world.setBlock(x, y, z, theBlock, metadata, 3)){
+           return false;
+       }
+       if (world.getBlock(x, y, z) == theBlock){
+           theBlock.onBlockPlacedBy(world, x, y, z, player, stack);
+           theBlock.onPostBlockPlaced(world, x, y, z, metadata);
+       }
+       return true;
+    }
+
 }
+
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/UndergroundBiomesConstructs.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/UndergroundBiomesConstructs.java
index 890bb59..d5cb49e 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/UndergroundBiomesConstructs.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/UndergroundBiomesConstructs.java
@@ -10,9 +10,9 @@ import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
 import exterminatorJeff.undergroundBiomes.common.block.BlockSedimentaryStone;
 
 import exterminatorJeff.undergroundBiomes.constructs.item.ItemUndergroundBiomesConstruct;
-import exterminatorJeff.undergroundBiomes.constructs.block.UBButtonGroup;
-import exterminatorJeff.undergroundBiomes.constructs.block.UBStairsGroup;
-import exterminatorJeff.undergroundBiomes.constructs.block.UBWallGroup;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBTEButtonGroup;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBTEStairsGroup;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBTEWallGroup;
 
 import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlockList;
 import exterminatorJeff.undergroundBiomes.constructs.entity.UndergroundBiomesTileEntity;
@@ -33,6 +33,16 @@ import cpw.mods.fml.common.registry.GameRegistry;
 
 import exterminatorJeff.undergroundBiomes.api.UndergroundBiomesSettings;
 import exterminatorJeff.undergroundBiomes.common.item.SwitchableRecipeGroup;
+import Zeno410Utils.Zeno410Logger;
+import exterminatorJeff.undergroundBiomes.api.NamedBlock;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBButtonBlockGroup;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBStairsBlockGroup;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBWall;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBWallBlockGroup;
+import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBWall;
+import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBWallBlock;
+import java.util.ArrayList;
+import net.minecraft.item.Item;
 
 //@Mod(modid = "UndergroundBiomesConstructs", name = "Underground Biomes Constructs", version = "0.0.4")
 //@NetworkMod(clientSideRequired = true, serverSideRequired = true)
@@ -43,17 +53,21 @@ public class UndergroundBiomesConstructs {
         return UndergroundBiomes.instance().settings();
     }
 
-    private UBStairsGroup stoneStair;
+    private UBStairsBlockGroup stoneStair;
     public int stoneStairID() {return settings().stoneStairID.value();}
-    public UBStairsGroup stoneStair() {return stoneStair;}
+    public UBStairsBlockGroup stoneStair() {return stoneStair;}
 
-    private UBWallGroup stoneWall;
+    private UBTEWallGroup stoneWall;
     public int stoneWallID() {return settings().stoneWallID.value();}
-    public UBWallGroup stoneWall() {return stoneWall;}
+    public UBTEWallGroup stoneWall() {return stoneWall;}
 
-    private UBButtonGroup stoneButton;
+    private UBWallBlockGroup blockWall;
+
+    private UBTEButtonGroup oldButton;
+    private UBButtonBlockGroup stoneButton;
     public int stoneButtonID() {return settings().stoneButtonID.value();}
-    public UBButtonGroup stoneButton() {return stoneButton;}
+
+    public UBButtonBlockGroup stoneButton() {return stoneButton;}
 
     private BlockMetadataBase iconTrap;
 
@@ -69,47 +83,72 @@ public class UndergroundBiomesConstructs {
     private SwitchableRecipeGroup buttonRecipes;
 
     //@PreIni
-    public void preInit(Configuration parConfig) {
-        config = parConfig;
+    public void preInit(Configuration config) {
+        this.config = config;
         ubBlockList = new UndergroundBiomesBlockList();
         GameRegistry.registerTileEntity(UndergroundBiomesTileEntity.class, "UndergroundBiomesTileEntity");
         iconTrap = new IconTrap();
 
         // with world-specific configs the buttons always have to exist.
-        preInitButtons();
-        preInitStairs();
-        preInitWalls();
+        /*if (UndergroundBiomes.buttonsOn())*/ preInitButtons();
+        /*if (UndergroundBiomes.stairsOn())*/ preInitStairs();
+        /*if (UndergroundBiomes.wallsOn())*/ preInitWalls();
     }
 
     public void preInitStairs() {
-        stoneStair = new UBStairsGroup();
+        UBTEStairsGroup oldStairs = new UBTEStairsGroup();
+        oldStairs.baseBlock = ubBlockList.sedimentaryStone;
+        oldStairs.define(stoneStairID());
+        stoneStair = new UBStairsBlockGroup();
         stoneStair.baseBlock = iconTrap;
         stoneStair.define(stoneStairID());
     }
 
+
+
     public void preInitWalls() {
-        stoneWall = new UBWallGroup();
+        stoneWall = new UBTEWallGroup();
         stoneWall.baseBlock = ubBlockList.sedimentaryStone;
         stoneWall.define(stoneWallID());
+        blockWall= new UBWallBlockGroup();
+        blockWall.define();
     }
 
     public void preInitButtons() {
-        stoneButton = new UBButtonGroup();
-        stoneButton.baseBlock = ubBlockList.sedimentaryStone;
-        stoneButton.define(stoneButtonID());
+        oldButton = new UBTEButtonGroup();
+        oldButton.baseBlock = ubBlockList.sedimentaryStone;
+        oldButton.define(stoneButtonID());
+        stoneButton = new UBButtonBlockGroup();
+        stoneButton.baseBlock = iconTrap;
+        stoneButton.define(stoneStairID());
     }
     
+    public ArrayList<BlockMetadataBase> baseBlocks() {
+        ArrayList<BlockMetadataBase> result = new ArrayList<BlockMetadataBase>();
+        result.add(UndergroundBiomes.igneousStone);
+        System.out.println(UndergroundBiomes.igneousStone.getUnlocalizedName());
+        result.add(UndergroundBiomes.igneousCobblestone);
+        result.add(UndergroundBiomes.igneousStoneBrick);
+        result.add(UndergroundBiomes.metamorphicStone);
+        result.add(UndergroundBiomes.metamorphicCobblestone);
+        result.add(UndergroundBiomes.metamorphicStoneBrick);
+        result.add(UndergroundBiomes.sedimentaryStone);
+        return result;
+    }
+
+
+
     public void load(FMLInitializationEvent event) {
-        loadButtons();
-        loadStairs();
-        loadWalls();
+        /*if (UndergroundBiomes.buttonsOn())*/ loadButtons();
+        /*if (UndergroundBiomes.stairsOn())*/ loadStairs();
+        /*if (UndergroundBiomes.wallsOn())*/ loadWalls();
     }
 
     private void loadStairs(){
         stairRecipes = new SwitchableRecipeGroup(stoneStair.recipes(),settings().stairsOn);
     }
     private void loadWalls() {
-        wallRecipes = new SwitchableRecipeGroup(stoneWall.recipes(),settings().wallsOn);
+        wallRecipes = new SwitchableRecipeGroup(blockWall.recipes(),settings().wallsOn);
     }
 
     private void loadButtons() {
@@ -160,8 +199,7 @@ class IconTrap extends BlockSedimentaryStone {
 
     IconTrap() {super(UBIDs.IconTrap);}
     
-    @Override
-	public IIcon getIcon(int side, int metadata) {
+    public IIcon getIcon(int side, int metadata) {
 
         return ItemUndergroundBiomesConstruct.currentColor;
     }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButton.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButton.java
new file mode 100644
index 0000000..9574595
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButton.java
@@ -0,0 +1,90 @@
+
+package exterminatorJeff.undergroundBiomes.constructs.block;
+
+import cpw.mods.fml.relauncher.Side;
+import cpw.mods.fml.relauncher.SideOnly;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import java.util.List;
+import net.minecraft.block.BlockButton;
+import net.minecraft.client.renderer.texture.IIconRegister;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IIcon;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class UBButton extends BlockButton {
+    final BlockMetadataBase baseStone;
+    final int lowerMetadata;
+    IIcon currentIcon;
+    public boolean renderingItem;
+    static final int materialFace = 2;
+
+    UBButton(BlockMetadataBase material, int lowerMetadata) {
+        super(true);
+        baseStone = material;
+        this.lowerMetadata = lowerMetadata;
+        this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+    }
+    public final int blockMetadata(int worldMetadata) {
+        return lowerMetadata;
+    }
+    @Override
+    public void registerBlockIcons(IIconRegister arg0) {
+        //super.registerBlockIcons(arg0);
+    }
+    @Override
+    public int getRenderColor(int metadata) {
+        currentIcon =  baseStone.getIcon(materialFace, lowerMetadata());
+        return super.getRenderColor(metadata);
+    }
+
+    public final int itemMetadata(int itemDamage) {
+        return itemDamage;
+    }
+
+    public BlockMetadataBase baseStone() {return baseStone;}
+    public int lowerMetadata() {return lowerMetadata;}
+    /**
+     * Gets the block's texture. Args: side, meta
+     */
+    @SideOnly(Side.CLIENT)
+    @Override
+    public IIcon getIcon(int side, int metadata){
+        currentIcon =  baseStone.getIcon(materialFace, lowerMetadata());
+        // world metadata: stair status plus 8 if upper metadata
+        /*if (metadata>7) {
+            return this.baseStone.getIcon(side, lowerMetadata()+1);
+        }
+        throw new RuntimeException("metadata "+metadata);*/
+        //return this.baseStone.getIcon(side, lowerMetadata());
+        return this.currentIcon;
+    }
+
+    @Override
+    public IIcon getIcon(IBlockAccess world, int x, int y, int z, int side) {
+        return this.getIcon(side, world.getBlockMetadata(x, y, z));
+    }
+
+        @Override
+    public IIcon func_149735_b(int side, int metadata) {
+        //if (metadata <8) throw new RuntimeException("metadata "+metadata);
+        //if (metadata > 0) return baseStone.getIcon(side, lowerMetadata()+1);
+        return this.baseStone.getIcon(side, blockMetadata(metadata));
+    }
+
+    @Override
+    public void getSubBlocks(Item id, CreativeTabs tabs, List list){
+        list.add(new ItemStack(id, 1, 0));
+    }
+    /*@Override
+    public void onBlockDestroyedByPlayer(World p_149664_1_, int p_149664_2_, int p_149664_3_, int p_149664_4_, int p_149664_5_){
+        this.baseStone.onBlockDestroyedByPlayer(p_149664_1_, p_149664_2_, p_149664_3_, p_149664_4_, blockMetadata(p_149664_5_));
+    }*/
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonBase.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonBase.java
index 7d33ba4..79ea2fe 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonBase.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonBase.java
@@ -24,6 +24,7 @@ import net.minecraft.util.IIcon;
 import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
 import net.minecraft.block.ITileEntityProvider;
+import net.minecraft.client.renderer.texture.IIconRegister;
 import net.minecraft.tileentity.TileEntity;
 import net.minecraft.world.World;
 import net.minecraft.entity.Entity;
@@ -41,19 +42,21 @@ public class UBButtonBase extends BlockButton implements ITileEntityProvider{
         super(false);
         name = namer;
         this.isBlockContainer = false;
-        this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+        this.setCreativeTab(null);
         this.setBlockName("button");
     }
-
+    @Override
+    public void registerBlockIcons(IIconRegister arg0) {
+        //super.registerBlockIcons(arg0);
+    }
     @Override
     public boolean hasTileEntity(int metadata) {return true;}
 
     @Override
     public boolean hasTileEntity() {return true;}
 
-    @Override
-	public TileEntity createNewTileEntity(World world, int i) {
-        return new UndergroundBiomesTileEntity();
+    public TileEntity createNewTileEntity(World world, int i) {
+        throw new RuntimeException();
     }
 
     @Override
@@ -66,7 +69,7 @@ public class UBButtonBase extends BlockButton implements ITileEntityProvider{
         if (!(UndergroundBiomes.buttonsOn())) return;
         for (int i = 0; i < UndergroundBiomesBlockList.detailedBlockCount; i++){
             UndergroundBiomesBlock source = UndergroundBiomesBlockList.indexed(i);
-            if (UBButtonGroup.suppress(source)) continue;// no brick buttons
+            if (UBTEButtonGroup.suppress(source)) continue;// no brick buttons
             list.add(new ItemStack(item, 1, i));
         }
     }
@@ -85,9 +88,6 @@ public class UBButtonBase extends BlockButton implements ITileEntityProvider{
     }
 
     public final UndergroundBiomesBlock safeUBBlock(IBlockAccess world, int x, int y, int z) {
-    	if (world == null) {
-    		return ubBlock(0);
-    	}
         try {
             UndergroundBiomesTileEntity entity = ubTileEntity(world,x,y,z);
             if (entity == null) return ubBlock(0);
@@ -170,11 +170,14 @@ public class UBButtonBase extends BlockButton implements ITileEntityProvider{
         super.onBlockPreDestroy( world,  x,  y,  z, p_149725_5_);
         // the tile entity we need for the drops is destroyed during the drop procedure
         // so we have to grab the index here
-        cacheCode(x,y,z,ubBlock(world,x,y,z));
+        TileEntity entity = world.getTileEntity(x, y, z);
+        if (entity != null&&(entity instanceof UndergroundBiomesTileEntity)){
+            cacheCode(x,y,z,ubBlock(world,x,y,z),world);
+        }
     }
 
-    private void cacheCode(int x, int y, int z, UndergroundBiomesBlock code) {
-        UndergroundBiomes.instance().ubCodeLocations.add(x, y, z, code);
+    private void cacheCode(int x, int y, int z, UndergroundBiomesBlock code,World world) {
+        UndergroundBiomes.instance().ubCodeLocations(world).add(x, y, z, code);
     }
 
     private int blockStayCode = 0;
@@ -193,10 +196,10 @@ public class UBButtonBase extends BlockButton implements ITileEntityProvider{
         blockStayCode = ubBlock(world,x,y,z).index;
         return super.canBlockStay(world, x, y, z);
     }
-    private UndergroundBiomesBlock unCacheCode(int x, int y, int z){
+    private UndergroundBiomesBlock unCacheCode(int x, int y, int z,World world){
         UndergroundBiomesBlock result;
-        result = UndergroundBiomes.instance().ubCodeLocations.get(x, y, z);
-        UndergroundBiomes.instance().ubCodeLocations.remove(x, y, z);
+        result = UndergroundBiomes.instance().ubCodeLocations(world).get(x, y, z);
+        UndergroundBiomes.instance().ubCodeLocations(world).remove(x, y, z);
         return result;
     }
 
@@ -210,7 +213,7 @@ public class UBButtonBase extends BlockButton implements ITileEntityProvider{
         {
             Item item = getItemDropped(metadata, world.rand, fortune);
             if (item != null) {
-                int index = this.unCacheCode(x, y, z).index;
+                int index = this.unCacheCode(x, y, z,world).index;
                 ret.add(new ItemStack(item, 1,index));
             }
         }
@@ -223,7 +226,7 @@ public class UBButtonBase extends BlockButton implements ITileEntityProvider{
     public void onBlockDestroyedByPlayer(World world, int x, int y, int z, int p_149664_5_) {
         super.onBlockDestroyedByPlayer(world, x,y , z, p_149664_5_);
         TileEntity entity = world.getTileEntity(x, y, z);
-        if (entity != null) {
+        if (entity != null&&(entity instanceof UndergroundBiomesTileEntity)) {
              world.removeTileEntity(x, y, z);
         }
     }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonBlockGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonBlockGroup.java
new file mode 100644
index 0000000..d6fb08e
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonBlockGroup.java
@@ -0,0 +1,109 @@
+package exterminatorJeff.undergroundBiomes.constructs.block;
+
+import exterminatorJeff.undergroundBiomes.api.NamedBlock;
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBButtonBlock;
+import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlock;
+import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlockList;
+import net.minecraft.block.Block;
+import net.minecraft.item.ItemStack;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class UBButtonBlockGroup extends UBButtonGroup {
+    private UBButtonSet igneousStoneButtonSet;
+    private UBButtonSet igneousCobblestoneButtonSet;
+    private UBButtonSet igneousStoneBrickButtonSet;
+    private UBButtonSet metamorphicStoneButtonSet;
+    private UBButtonSet metamorphicCobblestoneButtonSet;
+    private UBButtonSet metamorphicStoneBrickButtonSet;
+    private UBButtonSet sedimentaryStoneButtonSet;
+
+    @Override
+    public void define(int _constructID) {define();}
+
+    public void define() {
+       igneousStoneButtonSet = createButtonSet(UndergroundBiomes.igneousStone);
+       igneousCobblestoneButtonSet= createButtonSet(UndergroundBiomes.igneousCobblestone);
+       igneousStoneBrickButtonSet= createButtonSet(UndergroundBiomes.igneousStoneBrick);
+       metamorphicStoneButtonSet= createButtonSet(UndergroundBiomes.metamorphicStone);
+       metamorphicCobblestoneButtonSet= createButtonSet(UndergroundBiomes.metamorphicCobblestone);
+       metamorphicStoneBrickButtonSet= createButtonSet(UndergroundBiomes.metamorphicStoneBrick);
+       sedimentaryStoneButtonSet= createButtonSet(UndergroundBiomes.sedimentaryStone);
+    }
+
+    private UBButtonSet createButtonSet(BlockMetadataBase sourceBlock) {
+        return new UBButtonSet(sourceBlock);
+    }
+
+    private UBButtonSet ButtonSetFor(UndergroundBiomesBlock base) {
+        if (base.ubBlock == UndergroundBiomes.igneousStone) return igneousStoneButtonSet;
+        if (base.ubBlock == UndergroundBiomes.igneousCobblestone) return igneousCobblestoneButtonSet;
+        if (base.ubBlock == UndergroundBiomes.igneousStoneBrick) return igneousStoneBrickButtonSet;
+        if (base.ubBlock == UndergroundBiomes.metamorphicStone) return metamorphicStoneButtonSet;
+        if (base.ubBlock == UndergroundBiomes.metamorphicCobblestone) return metamorphicCobblestoneButtonSet;
+        if (base.ubBlock == UndergroundBiomes.metamorphicStoneBrick) return metamorphicStoneBrickButtonSet;
+        if (base.ubBlock == UndergroundBiomes.sedimentaryStone) return sedimentaryStoneButtonSet;
+        throw new RuntimeException(base.ubBlock.getUnlocalizedName());
+    }
+
+        @Override
+    public ProductItemDefiner productItemDefiner(int index) {
+        return new BlockProductItemDefiner(index);
+    }
+
+    class BlockProductItemDefiner extends ProductItemDefiner {
+
+        BlockProductItemDefiner(int _stoneIndex) {
+            super(_stoneIndex);
+        }
+
+        private final UndergroundBiomesBlock ubBlock() {
+            return UndergroundBiomesBlockList.indexed(stoneIndex);
+        }
+
+        private Block product() {
+            UBButtonSet ButtonSet = ButtonSetFor(ubBlock());
+            if (ubBlock().metadata<8) return ButtonSet.buttons[ubBlock().metadata];
+            throw new RuntimeException();
+        }
+
+        private int productMetadata() {
+            return ubBlock().metadata;
+        }
+        
+        @Override
+        public final ItemStack stackOf(int items) {
+
+            return new ItemStack(product(),items,productMetadata());
+        }
+    }
+
+    private static class UBButtonSet {
+        // a group of UBButton blocks covering one type of stone
+        UBButton [] buttons = new UBButton[8];
+
+        public UBButtonSet(BlockMetadataBase sourceBlock) {
+            buttons[0] = createButton(sourceBlock,0);
+            buttons[1] = createButton(sourceBlock,1);
+            buttons[2] = createButton(sourceBlock,2);
+            buttons[3] = createButton(sourceBlock,3);
+            buttons[4] = createButton(sourceBlock,4);
+            buttons[5] = createButton(sourceBlock,5);
+            buttons[6] = createButton(sourceBlock,6);
+            buttons[7] = createButton(sourceBlock,7);
+        }
+
+        private UBButton createButton(BlockMetadataBase sourceBlock, int lowerMetadata) {
+            NamedBlock createdNamer = new NamedBlock(UBIDs.UBButtonName.internal()+"."+sourceBlock.getUnlocalizedName()+lowerMetadata);
+            UBButton created = new UBButton(sourceBlock,lowerMetadata);
+            createdNamer.gameRegister(created, ItemUBButtonBlock.class);
+        return created;
+        }
+    }
+
+}
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonGroup.java
index 29ed3fb..d8da7f0 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonGroup.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBButtonGroup.java
@@ -1,26 +1,24 @@
-/**
- *
- * @author Zeno410
- *
- * Constructor for the button group
- */
 package exterminatorJeff.undergroundBiomes.constructs.block;
+
 import exterminatorJeff.undergroundBiomes.api.UBIDs;
 import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBButton;
 import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlock;
-
-import cpw.mods.fml.common.registry.GameRegistry;
-
 import net.minecraft.block.Block;
-import net.minecraft.item.ItemBlock;
+import net.minecraft.init.Blocks;
 import net.minecraft.item.crafting.IRecipe;
+import net.minecraft.item.ItemStack;
+import net.minecraftforge.oredict.ShapedOreRecipe;
 import net.minecraftforge.oredict.ShapelessOreRecipe;
 
+/**
+ *
+ * @author Zeno410
+ */
 public class UBButtonGroup extends UBConstructGroup {
 
     public UBButtonGroup() {
-        super("button");
+        super("Button");
     }
 
     public static boolean suppress(UndergroundBiomesBlock block) {
@@ -28,21 +26,25 @@ public class UBButtonGroup extends UBConstructGroup {
         return  (block.ubBlock  == UndergroundBiomes.metamorphicStoneBrick) ;
     }
 
-    void addRecipe(ProductItemDefiner product,StoneItemDefiner stone) {
-        // suppress brick buttons
-        if (suppress(stone.ubBlock())) return;
-        //GameRegistry.addRecipe(new ShapedOreRecipe(product.stackOf(2), "   ", " X ", " X ", 'X', stone.one()));
-        GameRegistry.addShapelessRecipe(product.stackOf(1), stone.one());
-    }
-    
     IRecipe recipe(ProductItemDefiner product,StoneItemDefiner stone) {
         // suppress brick buttons
         if (suppress(stone.ubBlock())) return null;
         return new ShapelessOreRecipe(product.stackOf(1), stone.one());
     }
 
-    Class<? extends ItemBlock> itemClass() {
-        return ItemUBButton.class;
+    IRecipe rescueRecipe(ProductItemDefiner product, StoneItemDefiner stone) {
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.igneousCobblestone) return null;
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.metamorphicCobblestone) return null;
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.igneousStoneBrick){
+            return new ShapelessOreRecipe(new ItemStack(Blocks.stone_button,1), product.stackOf(1));
+        }
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.metamorphicStoneBrick){
+            return new ShapelessOreRecipe(new ItemStack(Blocks.stone_button,1), product.stackOf(1));
+        }
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.sedimentaryStone){
+            return new ShapelessOreRecipe(new ItemStack(Blocks.stone_button,1), product.stackOf(1));
+        }
+        return new ShapelessOreRecipe(new ItemStack(Blocks.stone_button,1), product.stackOf(1));
     }
 
     private static UBButtonBase constructBlock;
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBConstructGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBConstructGroup.java
index f8e95a9..f0f67de 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBConstructGroup.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBConstructGroup.java
@@ -36,16 +36,12 @@ public abstract class UBConstructGroup {
             //GameRegistry.registerBlock( construct, itemClass(),name);\
         }
         
-        public void addRecipes() {
-            for (int ubIndex = 0; ubIndex <UndergroundBiomesBlockList.detailedBlockCount;ubIndex++) {
-                addRecipe(new ProductItemDefiner(ubIndex),new StoneItemDefiner(ubIndex));
-            }
-        }
-        
         public ArrayList<IRecipe> recipes() {
             ArrayList<IRecipe> result = new ArrayList<IRecipe>();
             for (int ubIndex = 0; ubIndex <UndergroundBiomesBlockList.detailedBlockCount;ubIndex++) {
-                IRecipe added = recipe(new ProductItemDefiner(ubIndex),new StoneItemDefiner(ubIndex));
+                IRecipe added = recipe(productItemDefiner(ubIndex),new StoneItemDefiner(ubIndex));
+                if (added != null) result.add(added);
+                added = rescueRecipe(productItemDefiner(ubIndex),new StoneItemDefiner(ubIndex));
                 if (added != null) result.add(added);
             }
             return result;
@@ -53,11 +49,9 @@ public abstract class UBConstructGroup {
                 
         abstract IRecipe recipe(ProductItemDefiner product, StoneItemDefiner stone);
 
-        abstract Block definedBlock(); // this should return the construct block for the group
-
-        abstract Class<? extends ItemBlock> itemClass(); // the class to handle items
+        abstract IRecipe rescueRecipe(ProductItemDefiner product, StoneItemDefiner stone);
 
-        abstract void addRecipe(ProductItemDefiner product, StoneItemDefiner stone); //
+        abstract Block definedBlock(); // this should return the construct block for the group
 
         public BlockMetadataBase baseBlock() {
             return baseBlock;
@@ -83,18 +77,22 @@ public abstract class UBConstructGroup {
             public final ItemStack one() {return stackOf(1);}
         }
 
-        class ProductItemDefiner {
+        public ProductItemDefiner productItemDefiner(int index) {
+            return new ProductItemDefiner(index);
+        }
+
+        public class ProductItemDefiner {
             // this inner class wraps the stoneIndex for "standard" UBConstruct item group
             // the assumption is that a damage index of x indicates that stone
             final int stoneIndex;
 
             ProductItemDefiner(int _stoneIndex) {stoneIndex = _stoneIndex;}
 
-            public final ItemStack stackOf(int items) {
+            public ItemStack stackOf(int items) {
                 return new ItemStack(construct,items,stoneIndex);
             }
 
-            public final ItemStack one() {return stackOf(1);}
+            public ItemStack one() {return stackOf(1);}
         }
 
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairs.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairs.java
new file mode 100644
index 0000000..c356697
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairs.java
@@ -0,0 +1,451 @@
+
+package exterminatorJeff.undergroundBiomes.constructs.block;
+
+import cpw.mods.fml.relauncher.Side;
+import cpw.mods.fml.relauncher.SideOnly;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import java.util.ArrayList;
+import java.util.List;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockStairs;
+import net.minecraft.client.renderer.texture.IIconRegister;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IIcon;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.world.World;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class UBStairs extends BlockStairs {
+    final BlockMetadataBase baseStone;
+    final int lowerMetadata;
+    public IIcon currentIcon;
+    public boolean renderingItem;
+    static final int materialFace = 2;
+
+    UBStairs(BlockMetadataBase material, int lowerMetadata) {
+        super(material,materialFace);
+        baseStone = material;
+        this.lowerMetadata = lowerMetadata;
+        this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+        this.lightOpacity = 1;
+    }
+
+    public final int blockMetadata(int worldMetadata) {
+        return lowerMetadata + ((worldMetadata &8)>>3);
+    }
+
+    @Override
+    public void func_150147_e(IBlockAccess arg0, int arg1, int arg2, int arg3) {
+        super.func_150147_e(arg0, arg1, arg2, arg3);
+        renderingItem = false;
+    }
+
+    @Override
+    public void registerBlockIcons(IIconRegister arg0) {
+        //super.registerBlockIcons(arg0);
+    }
+    
+    @Override
+    public int getRenderColor(int metadata) {
+        if (metadata>7) {
+            currentIcon =  baseStone.getIcon(materialFace, lowerMetadata()+1);
+        } else {
+            currentIcon =  baseStone.getIcon(materialFace, lowerMetadata());
+        }
+        return super.getRenderColor(metadata);
+    }
+
+    public BlockMetadataBase baseStone() {return baseStone;}
+    public int lowerMetadata() {return lowerMetadata;}
+
+
+    /**
+     * Gets the block's texture. Args: side, meta
+     */
+    @SideOnly(Side.CLIENT)
+    @Override
+    public IIcon getIcon(int side, int metadata){
+        // world metadata: stair status plus 8 if upper metadata
+        /*if (metadata>7) {
+            return this.baseStone.getIcon(side, lowerMetadata()+1);
+        }
+        throw new RuntimeException("metadata "+metadata);*/
+        //return this.baseStone.getIcon(side, lowerMetadata());
+        if (metadata>7) {
+            if (currentIcon != null&& false) {
+                IIcon result = currentIcon;
+                if (side >=5) {
+                     currentIcon = null;
+                     renderingItem = false;
+                }
+                return result;
+            }
+            if (side >=6) {
+                 renderingItem = false;
+            }
+            currentIcon = null;
+            return baseStone.getIcon(materialFace, lowerMetadata()+1);
+        } else {
+            if (currentIcon != null && renderingItem) {
+                IIcon result = currentIcon;
+                if (side >=6) {
+                    currentIcon = null;
+                    renderingItem = false;
+                }
+                return result;
+            }
+            currentIcon =  baseStone.getIcon(materialFace, lowerMetadata());
+        }
+        return this.currentIcon;
+    }
+
+    @Override
+    public IIcon getIcon(IBlockAccess world, int x, int y, int z, int side) {
+        return this.getIcon(side, world.getBlockMetadata(x, y, z));
+    }
+
+    @Override
+    public void getSubBlocks(Item id, CreativeTabs tabs, List list){
+        list.add(new ItemStack(id, 1, 0));
+        list.add(new ItemStack(id, 1, 8));
+    }
+
+    @Override
+    public IIcon func_149735_b(int side, int metadata) {
+        //if (metadata <8) throw new RuntimeException("metadata "+metadata);
+        //if (metadata > 0) return baseStone.getIcon(side, lowerMetadata()+1);
+        if (metadata>7) {
+            if (currentIcon != null&&false) {
+                IIcon result = currentIcon;
+                if (side >=5) {
+                     currentIcon = null;
+                     renderingItem = false;
+                }
+                return result;
+            }
+            if (side >=6) {
+                 renderingItem = false;
+            }
+            currentIcon = null;
+            return baseStone.getIcon(materialFace, lowerMetadata()+1);
+        } else {
+            if (currentIcon != null && renderingItem) {
+                IIcon result = currentIcon;
+                if (side >=6) {
+                    currentIcon = null;
+                    renderingItem = false;
+                }
+                return result;
+            }
+            currentIcon =  baseStone.getIcon(materialFace, lowerMetadata());
+        }
+        return this.currentIcon;
+        //return this.baseStone.getIcon(side, blockMetadata(metadata));
+    }
+
+    @Override
+    public void onBlockDestroyedByPlayer(World p_149664_1_, int p_149664_2_, int p_149664_3_, int p_149664_4_, int p_149664_5_){
+        this.baseStone.onBlockDestroyedByPlayer(p_149664_1_, p_149664_2_, p_149664_3_, p_149664_4_, blockMetadata(p_149664_5_));
+    }
+
+        /**
+     * Called when the block is placed in the world.
+     */
+    @Override
+    public void onBlockPlacedBy(World p_149689_1_, int p_149689_2_, int p_149689_3_, int p_149689_4_, EntityLivingBase p_149689_5_, ItemStack placed)
+    {
+        int l = MathHelper.floor_double((double)(p_149689_5_.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3;
+        int i1 = p_149689_1_.getBlockMetadata(p_149689_2_, p_149689_3_, p_149689_4_) & 4;
+        int addToMetadata = 0;
+        if (placed.getItemDamage()>0) addToMetadata = 8;
+
+        if (l == 0)
+        {
+            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, (2 | i1)+addToMetadata, 2);
+        }
+
+        if (l == 1)
+        {
+            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, (1 | i1)+addToMetadata, 2);
+        }
+
+        if (l == 2)
+        {
+            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, (3 | i1)+addToMetadata, 2);
+        }
+
+        if (l == 3)
+        {
+            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, (0 | i1)+addToMetadata, 2);
+        }
+    }
+
+
+    @Override
+    public ArrayList<ItemStack> getDrops(World world, int x, int y, int z, int metadata, int fortune) {
+        ArrayList<ItemStack> result = super.getDrops(world, x, y, z, metadata&8, fortune);
+        for (ItemStack itemStack: result) {
+            itemStack.setItemDamage(metadata&8);
+            break;// a crude way to affect only the first
+        }
+        return result;
+    }
+    /**
+     * Called when a block is placed using its ItemBlock. Args: World, X, Y, Z, side, hitX, hitY, hitZ, block metadata
+     */
+    @Override
+    public int onBlockPlaced(World p_149660_1_, int p_149660_2_, int p_149660_3_, int p_149660_4_, int p_149660_5_, float p_149660_6_, float p_149660_7_, float p_149660_8_, int p_149660_9_)
+    {
+        int result = p_149660_5_ != 0 && (p_149660_5_ == 1 || (double)p_149660_7_ <= 0.5D) ? p_149660_9_ : p_149660_9_ | 4;
+        return result;
+    }
+
+
+    boolean func_150146_f(IBlockAccess p_150146_1_, int p_150146_2_, int p_150146_3_, int p_150146_4_, int p_150146_5_){
+        Block block = p_150146_1_.getBlock(p_150146_2_, p_150146_3_, p_150146_4_);
+        return func_150148_a(block) && (p_150146_1_.getBlockMetadata(p_150146_2_, p_150146_3_, p_150146_4_)&7) == p_150146_5_;
+    }
+
+    @Override
+    public boolean func_150145_f(IBlockAccess p_150145_1_, int p_150145_2_, int p_150145_3_, int p_150145_4_){
+        int l = p_150145_1_.getBlockMetadata(p_150145_2_, p_150145_3_, p_150145_4_);
+        int i1 = l & 3;
+        float f = 0.5F;
+        float f1 = 1.0F;
+
+        if ((l & 4) != 0){
+            f = 0.0F;
+            f1 = 0.5F;
+        }
+
+        float f2 = 0.0F;
+        float f3 = 1.0F;
+        float f4 = 0.0F;
+        float f5 = 0.5F;
+        boolean flag = true;
+        Block block;
+        int j1;
+        int k1;
+
+        if (i1 == 0){
+            f2 = 0.5F;
+            f5 = 1.0F;
+            block = p_150145_1_.getBlock(p_150145_2_ + 1, p_150145_3_, p_150145_4_);
+            j1 = p_150145_1_.getBlockMetadata(p_150145_2_ + 1, p_150145_3_, p_150145_4_);
+
+            if (func_150148_a(block) && (l & 4) == (j1 & 4)) {
+                k1 = j1 & 3;
+
+                if (k1 == 3 && !this.func_150146_f(p_150145_1_, p_150145_2_, p_150145_3_, p_150145_4_ + 1, l)){
+                    f5 = 0.5F;
+                    flag = false;
+                }
+                else if (k1 == 2 && !this.func_150146_f(p_150145_1_, p_150145_2_, p_150145_3_, p_150145_4_ - 1, l)){
+                    f4 = 0.5F;
+                    flag = false;
+                }
+            }
+        }
+        else if (i1 == 1)
+        {
+            f3 = 0.5F;
+            f5 = 1.0F;
+            block = p_150145_1_.getBlock(p_150145_2_ - 1, p_150145_3_, p_150145_4_);
+            j1 = p_150145_1_.getBlockMetadata(p_150145_2_ - 1, p_150145_3_, p_150145_4_);
+
+            if (func_150148_a(block) && (l & 4) == (j1 & 4))
+            {
+                k1 = j1 & 3;
+
+                if (k1 == 3 && !this.func_150146_f(p_150145_1_, p_150145_2_, p_150145_3_, p_150145_4_ + 1, l))
+                {
+                    f5 = 0.5F;
+                    flag = false;
+                }
+                else if (k1 == 2 && !this.func_150146_f(p_150145_1_, p_150145_2_, p_150145_3_, p_150145_4_ - 1, l))
+                {
+                    f4 = 0.5F;
+                    flag = false;
+                }
+            }
+        }
+        else if (i1 == 2)
+        {
+            f4 = 0.5F;
+            f5 = 1.0F;
+            block = p_150145_1_.getBlock(p_150145_2_, p_150145_3_, p_150145_4_ + 1);
+            j1 = p_150145_1_.getBlockMetadata(p_150145_2_, p_150145_3_, p_150145_4_ + 1);
+
+            if (func_150148_a(block) && (l & 4) == (j1 & 4))
+            {
+                k1 = j1 & 3;
+
+                if (k1 == 1 && !this.func_150146_f(p_150145_1_, p_150145_2_ + 1, p_150145_3_, p_150145_4_, l))
+                {
+                    f3 = 0.5F;
+                    flag = false;
+                }
+                else if (k1 == 0 && !this.func_150146_f(p_150145_1_, p_150145_2_ - 1, p_150145_3_, p_150145_4_, l))
+                {
+                    f2 = 0.5F;
+                    flag = false;
+                }
+            }
+        }
+        else if (i1 == 3)
+        {
+            block = p_150145_1_.getBlock(p_150145_2_, p_150145_3_, p_150145_4_ - 1);
+            j1 = p_150145_1_.getBlockMetadata(p_150145_2_, p_150145_3_, p_150145_4_ - 1);
+
+            if (func_150148_a(block) && (l & 4) == (j1 & 4))
+            {
+                k1 = j1 & 3;
+
+                if (k1 == 1 && !this.func_150146_f(p_150145_1_, p_150145_2_ + 1, p_150145_3_, p_150145_4_, l))
+                {
+                    f3 = 0.5F;
+                    flag = false;
+                }
+                else if (k1 == 0 && !this.func_150146_f(p_150145_1_, p_150145_2_ - 1, p_150145_3_, p_150145_4_, l))
+                {
+                    f2 = 0.5F;
+                    flag = false;
+                }
+            }
+        }
+
+        this.setBlockBounds(f2, f, f4, f3, f1, f5);
+        return flag;
+    }
+
+    public boolean func_150144_g(IBlockAccess p_150144_1_, int p_150144_2_, int p_150144_3_, int p_150144_4_)
+    {
+        int l = p_150144_1_.getBlockMetadata(p_150144_2_, p_150144_3_, p_150144_4_);
+        int i1 = l & 3;
+        float f = 0.5F;
+        float f1 = 1.0F;
+
+        if ((l & 4) != 0)
+        {
+            f = 0.0F;
+            f1 = 0.5F;
+        }
+
+        float f2 = 0.0F;
+        float f3 = 0.5F;
+        float f4 = 0.5F;
+        float f5 = 1.0F;
+        boolean flag = false;
+        Block block;
+        int j1;
+        int k1;
+
+        if (i1 == 0)
+        {
+            block = p_150144_1_.getBlock(p_150144_2_ - 1, p_150144_3_, p_150144_4_);
+            j1 = p_150144_1_.getBlockMetadata(p_150144_2_ - 1, p_150144_3_, p_150144_4_);
+
+            if (func_150148_a(block) && (l & 4) == (j1 & 4))
+            {
+                k1 = j1 & 3;
+
+                if (k1 == 3 && !this.func_150146_f(p_150144_1_, p_150144_2_, p_150144_3_, p_150144_4_ - 1, l))
+                {
+                    f4 = 0.0F;
+                    f5 = 0.5F;
+                    flag = true;
+                }
+                else if (k1 == 2 && !this.func_150146_f(p_150144_1_, p_150144_2_, p_150144_3_, p_150144_4_ + 1, l))
+                {
+                    f4 = 0.5F;
+                    f5 = 1.0F;
+                    flag = true;
+                }
+            }
+        }
+        else if (i1 == 1)
+        {
+            block = p_150144_1_.getBlock(p_150144_2_ + 1, p_150144_3_, p_150144_4_);
+            j1 = p_150144_1_.getBlockMetadata(p_150144_2_ + 1, p_150144_3_, p_150144_4_);
+
+            if (func_150148_a(block) && (l & 4) == (j1 & 4))
+            {
+                f2 = 0.5F;
+                f3 = 1.0F;
+                k1 = j1 & 3;
+
+                if (k1 == 3 && !this.func_150146_f(p_150144_1_, p_150144_2_, p_150144_3_, p_150144_4_ - 1, l))
+                {
+                    f4 = 0.0F;
+                    f5 = 0.5F;
+                    flag = true;
+                }
+                else if (k1 == 2 && !this.func_150146_f(p_150144_1_, p_150144_2_, p_150144_3_, p_150144_4_ + 1, l))
+                {
+                    f4 = 0.5F;
+                    f5 = 1.0F;
+                    flag = true;
+                }
+            }
+        }
+        else if (i1 == 2)
+        {
+            block = p_150144_1_.getBlock(p_150144_2_, p_150144_3_, p_150144_4_ - 1);
+            j1 = p_150144_1_.getBlockMetadata(p_150144_2_, p_150144_3_, p_150144_4_ - 1);
+
+            if (func_150148_a(block) && (l & 4) == (j1 & 4))
+            {
+                f4 = 0.0F;
+                f5 = 0.5F;
+                k1 = j1 & 3;
+
+                if (k1 == 1 && !this.func_150146_f(p_150144_1_, p_150144_2_ - 1, p_150144_3_, p_150144_4_, l))
+                {
+                    flag = true;
+                }
+                else if (k1 == 0 && !this.func_150146_f(p_150144_1_, p_150144_2_ + 1, p_150144_3_, p_150144_4_, l))
+                {
+                    f2 = 0.5F;
+                    f3 = 1.0F;
+                    flag = true;
+                }
+            }
+        }
+        else if (i1 == 3)
+        {
+            block = p_150144_1_.getBlock(p_150144_2_, p_150144_3_, p_150144_4_ + 1);
+            j1 = p_150144_1_.getBlockMetadata(p_150144_2_, p_150144_3_, p_150144_4_ + 1);
+
+            if (func_150148_a(block) && (l & 4) == (j1 & 4))
+            {
+                k1 = j1 & 3;
+
+                if (k1 == 1 && !this.func_150146_f(p_150144_1_, p_150144_2_ - 1, p_150144_3_, p_150144_4_, l)){
+                    flag = true;
+                }
+                else if (k1 == 0 && !this.func_150146_f(p_150144_1_, p_150144_2_ + 1, p_150144_3_, p_150144_4_, l))
+                {
+                    f2 = 0.5F;
+                    f3 = 1.0F;
+                    flag = true;
+                }
+            }
+        }
+
+        if (flag){
+            this.setBlockBounds(f2, f, f4, f3, f1, f5);
+        }
+
+        return flag;
+    }
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsBase.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsBase.java
index 0a88eb5..3a796cb 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsBase.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsBase.java
@@ -31,6 +31,7 @@ import net.minecraft.world.World;
 import net.minecraft.entity.Entity;
 
 import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import net.minecraft.client.renderer.texture.IIconRegister;
 
 public class UBStairsBase extends BlockStairs implements ITileEntityProvider{
 
@@ -42,11 +43,14 @@ public class UBStairsBase extends BlockStairs implements ITileEntityProvider{
         name = namer;
         this.setLightOpacity(4);
         this.isBlockContainer = false;
-        this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+        this.setCreativeTab(null);
         this.setBlockName("stairs");
     }
 
-
+    @Override
+    public void registerBlockIcons(IIconRegister arg0) {
+        //super.registerBlockIcons(arg0);
+    }
 
     @Override
     public boolean hasTileEntity(int metadata) {return true;}
@@ -54,9 +58,8 @@ public class UBStairsBase extends BlockStairs implements ITileEntityProvider{
     @Override
     public boolean hasTileEntity() {return true;}
 
-    @Override
-	public TileEntity createNewTileEntity(World world, int i) {
-        return new UndergroundBiomesTileEntity();
+    public TileEntity createNewTileEntity(World world, int i) {
+        throw new RuntimeException();
     }
 
     @Override
@@ -185,17 +188,21 @@ public class UBStairsBase extends BlockStairs implements ITileEntityProvider{
         super.onBlockPreDestroy( world,  x,  y,  z, p_149725_5_);
         // the tile entity we need for the drops is destroyed during the drop procedure
         // so we have to grab the index here
-        cacheCode(x,y,z,ubBlock(world,x,y,z));
+        TileEntity entity = world.getTileEntity(x, y, z);
+        if (entity != null&&(entity instanceof UndergroundBiomesTileEntity)){
+            //logger.info(entity.toString()+ x + " " + y + " " + z + " " + world.toString());
+            cacheCode(x,y,z,ubBlock(world,x,y,z),world);
+        }
     }
 
-    private void cacheCode(int x, int y, int z, UndergroundBiomesBlock code) {
-        UndergroundBiomes.instance().ubCodeLocations.add(x, y, z, code);
+    private void cacheCode(int x, int y, int z, UndergroundBiomesBlock code,World world) {
+        UndergroundBiomes.instance().ubCodeLocations(world).add(x, y, z, code);
     }
 
-    private UndergroundBiomesBlock unCacheCode(int x, int y, int z){
+    private UndergroundBiomesBlock unCacheCode(int x, int y, int z,World world){
         UndergroundBiomesBlock result;
-        result = UndergroundBiomes.instance().ubCodeLocations.get(x, y, z);
-        UndergroundBiomes.instance().ubCodeLocations.remove(x, y, z);
+        result = UndergroundBiomes.instance().ubCodeLocations(world).get(x, y, z);
+        UndergroundBiomes.instance().ubCodeLocations(world).remove(x, y, z);
         return result;
     }
 
@@ -209,7 +216,7 @@ public class UBStairsBase extends BlockStairs implements ITileEntityProvider{
         {
             Item item = getItemDropped(metadata, world.rand, fortune);
             if (item != null) {
-                int index = this.unCacheCode(x, y, z).index;
+                int index = this.unCacheCode(x, y, z,world).index;
                 ret.add(new ItemStack(item, 1,index));
             }
         }
@@ -222,7 +229,7 @@ public class UBStairsBase extends BlockStairs implements ITileEntityProvider{
     public void onBlockDestroyedByPlayer(World world, int x, int y, int z, int p_149664_5_) {
         super.onBlockDestroyedByPlayer(world, x,y , z, p_149664_5_);
         TileEntity entity = world.getTileEntity(x, y, z);
-        if (entity != null) {
+        if (entity != null&&(entity instanceof UndergroundBiomesTileEntity)) {
              world.removeTileEntity(x, y, z);
         }
     }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsBlockGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsBlockGroup.java
new file mode 100644
index 0000000..09981cb
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsBlockGroup.java
@@ -0,0 +1,113 @@
+
+package exterminatorJeff.undergroundBiomes.constructs.block;
+
+import exterminatorJeff.undergroundBiomes.api.NamedBlock;
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBStairsBlock;
+import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlock;
+import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlockList;
+import net.minecraft.block.Block;
+import net.minecraft.item.ItemStack;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class UBStairsBlockGroup extends UBStairsGroup {
+    private UBStairsSet igneousStoneStairsSet;
+    private UBStairsSet igneousCobblestoneStairsSet;
+    private UBStairsSet igneousStoneBrickStairsSet;
+    private UBStairsSet metamorphicStoneStairsSet;
+    private UBStairsSet metamorphicCobblestoneStairsSet;
+    private UBStairsSet metamorphicStoneBrickStairsSet;
+    private UBStairsSet sedimentaryStoneStairsSet;
+
+    @Override
+    public void define(int _constructID) {define();}
+
+    public void define() {
+       igneousStoneStairsSet = createStairsSet(UndergroundBiomes.igneousStone);
+       igneousCobblestoneStairsSet= createStairsSet(UndergroundBiomes.igneousCobblestone);
+       igneousStoneBrickStairsSet= createStairsSet(UndergroundBiomes.igneousStoneBrick);
+       metamorphicStoneStairsSet= createStairsSet(UndergroundBiomes.metamorphicStone);
+       metamorphicCobblestoneStairsSet= createStairsSet(UndergroundBiomes.metamorphicCobblestone);
+       metamorphicStoneBrickStairsSet= createStairsSet(UndergroundBiomes.metamorphicStoneBrick);
+       sedimentaryStoneStairsSet= createStairsSet(UndergroundBiomes.sedimentaryStone);
+    }
+
+    private UBStairsSet createStairsSet(BlockMetadataBase sourceBlock) {
+        return new UBStairsSet(sourceBlock);
+    }
+
+    private UBStairsSet stairsSetFor(UndergroundBiomesBlock base) {
+        if (base.ubBlock == UndergroundBiomes.igneousStone) return igneousStoneStairsSet;
+        if (base.ubBlock == UndergroundBiomes.igneousCobblestone) return igneousCobblestoneStairsSet;
+        if (base.ubBlock == UndergroundBiomes.igneousStoneBrick) return igneousStoneBrickStairsSet;
+        if (base.ubBlock == UndergroundBiomes.metamorphicStone) return metamorphicStoneStairsSet;
+        if (base.ubBlock == UndergroundBiomes.metamorphicCobblestone) return metamorphicCobblestoneStairsSet;
+        if (base.ubBlock == UndergroundBiomes.metamorphicStoneBrick) return metamorphicStoneBrickStairsSet;
+        if (base.ubBlock == UndergroundBiomes.sedimentaryStone) return sedimentaryStoneStairsSet;
+        throw new RuntimeException(base.ubBlock.getUnlocalizedName());
+    }
+
+        @Override
+    public ProductItemDefiner productItemDefiner(int index) {
+        return new BlockProductItemDefiner(index);
+    }
+
+    class BlockProductItemDefiner extends ProductItemDefiner {
+
+        BlockProductItemDefiner(int _stoneIndex) {
+            super(_stoneIndex);
+        }
+
+        private final UndergroundBiomesBlock ubBlock() {
+            return UndergroundBiomesBlockList.indexed(stoneIndex);
+        }
+
+        private Block product() {
+            UBStairsSet stairsSet = stairsSetFor(ubBlock());
+            if (ubBlock().metadata<2) return stairsSet.zeroOne;
+            if (ubBlock().metadata<4) return stairsSet.twoThree;
+            if (ubBlock().metadata<6) return stairsSet.fourFive;
+            if (ubBlock().metadata<8) return stairsSet.sixSeven;
+            throw new RuntimeException();
+        }
+
+        private int productMetadata() {
+            int result = ubBlock().metadata%2*8;
+            if ((result !=0)&&result!=8) throw new RuntimeException();
+            return ubBlock().metadata%2*8;
+        }
+        @Override
+        public final ItemStack stackOf(int items) {
+
+            return new ItemStack(product(),items,productMetadata());
+        }
+    }
+
+    private static class UBStairsSet {
+        // a group of UBStairs blocks covering one type of stone
+        UBStairs zeroOne;
+        UBStairs twoThree;
+        UBStairs fourFive;
+        UBStairs sixSeven;
+
+        public UBStairsSet(BlockMetadataBase sourceBlock) {
+            zeroOne = createStairs(sourceBlock,0);
+            twoThree = createStairs(sourceBlock,2);
+            fourFive = createStairs(sourceBlock,4);
+            sixSeven = createStairs(sourceBlock,6);
+        }
+
+        private UBStairs createStairs(BlockMetadataBase sourceBlock, int lowerMetadata) {
+            NamedBlock createdNamer = new NamedBlock(UBIDs.UBStairsName.internal()+"."+sourceBlock.getUnlocalizedName()+lowerMetadata/2);
+            UBStairs created = new UBStairs(sourceBlock,lowerMetadata);
+            createdNamer.gameRegister(created, ItemUBStairsBlock.class);
+        return created;
+        }
+    }
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsGroup.java
index ee9d081..fe0db5c 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsGroup.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBStairsGroup.java
@@ -1,45 +1,43 @@
-/**
- *
- * @author Zeno410
- *
- * Constructor for the Stairs group
- */
 
 package exterminatorJeff.undergroundBiomes.constructs.block;
 
 import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBStairs;
-
-import cpw.mods.fml.common.registry.GameRegistry;
-
 import net.minecraft.block.Block;
-import net.minecraft.inventory.InventoryCrafting;
+import net.minecraft.init.Blocks;
 import net.minecraft.item.crafting.IRecipe;
-import net.minecraft.item.Item;
-import net.minecraft.item.ItemBlock;
 import net.minecraft.item.ItemStack;
-
 import net.minecraftforge.oredict.ShapedOreRecipe;
+import net.minecraftforge.oredict.ShapelessOreRecipe;
 
-
+/**
+ *
+ * @author Zeno410
+ */
 public class UBStairsGroup extends UBConstructGroup {
     
     public UBStairsGroup() {
         super("stairs");
     }
 
-    void addRecipe(ProductItemDefiner product, StoneItemDefiner stone) {
-        IRecipe stairsRecipe = new ShapedOreRecipe(
-                product.stackOf(4), "  X", " XX", "XXX", 'X', stone.one());
-        GameRegistry.addRecipe(stairsRecipe);
-    }
-
     IRecipe recipe(ProductItemDefiner product, StoneItemDefiner stone) {
         return new ShapedOreRecipe(product.stackOf(4), "  X", " XX", "XXX", 'X', stone.one());
     }
 
-    Class<? extends ItemBlock> itemClass() {
-        return ItemUBStairs.class;
+    IRecipe rescueRecipe(ProductItemDefiner product, StoneItemDefiner stone) {
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.igneousCobblestone) return null;
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.metamorphicCobblestone) return null;
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.igneousStoneBrick){
+            return new ShapelessOreRecipe(new ItemStack(Blocks.stone_brick_stairs,1), product.stackOf(1));
+        }
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.metamorphicStoneBrick){
+            return new ShapelessOreRecipe(new ItemStack(Blocks.stone_brick_stairs,1), product.stackOf(1));
+        }
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.sedimentaryStone){
+            return new ShapelessOreRecipe(new ItemStack(Blocks.sandstone_stairs,1), product.stackOf(1));
+        }
+        return new ShapelessOreRecipe(new ItemStack(Blocks.stone_stairs,1), product.stackOf(1));
     }
 
     private static UBStairsBase constructBlock;
@@ -50,31 +48,4 @@ public class UBStairsGroup extends UBConstructGroup {
         }
         return constructBlock;
     }
-    
-    class StairsRecipe extends ShapedOreRecipe {
-        public StairsRecipe(ProductItemDefiner product, StoneItemDefiner stone) {
-            super (product.stackOf(4), "  X", " XX", "XXX", 'X', stone.one());
-        }
-
-        @Override
-        public ItemStack getCraftingResult(InventoryCrafting var1) {
-            ItemStack result =  super.getCraftingResult(var1);
-            int registeredID = Item.getIdFromItem(result.getItem());
-            //ItemUBWall.logger.info("crafting "+registeredID+" " +result.getItem().toString());
-            if (registeredID == -1) {
-                ItemUBStairs wallItem = (ItemUBStairs)(result.getItem());
-                registeredID = Item.getIdFromItem(result.getItem());
-                throw new RuntimeException();
-            }
-            //ItemUBWall.logger.info("crafting "+registeredID+" " +result.getItem().toString());
-            return result;
-        }
-
-        public ItemStack getRecipeOutput() {
-            ItemStack result = super.getRecipeOutput();
-            //ItemUBWall.logger.info("output "+Item.getIdFromItem(result.getItem())+" " +result.getItem().toString());
-            return result;
-        }
-
-    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEButtonGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEButtonGroup.java
new file mode 100644
index 0000000..525f346
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEButtonGroup.java
@@ -0,0 +1,57 @@
+/**
+ *
+ * @author Zeno410
+ *
+ * Constructor for the button group
+ */
+package exterminatorJeff.undergroundBiomes.constructs.block;
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBButton;
+import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlock;
+
+import cpw.mods.fml.common.registry.GameRegistry;
+
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.item.ItemStack;
+import net.minecraft.item.crafting.IRecipe;
+import net.minecraftforge.oredict.ShapelessOreRecipe;
+
+public class UBTEButtonGroup extends UBConstructGroup {
+
+    public UBTEButtonGroup() {
+        super("button");
+    }
+
+    public static boolean suppress(UndergroundBiomesBlock block) {
+        if (block.ubBlock == UndergroundBiomes.igneousStoneBrick) return true;
+        return  (block.ubBlock  == UndergroundBiomes.metamorphicStoneBrick) ;
+    }
+    
+    IRecipe recipe(ProductItemDefiner product,StoneItemDefiner stone) {
+        // suppress brick buttons
+        if (suppress(stone.ubBlock())) return null;
+        return new ShapelessOreRecipe(product.stackOf(1), stone.one());
+    }
+
+    IRecipe rescueRecipe(ProductItemDefiner product,StoneItemDefiner stone) {
+        // suppress brick buttons
+        if (suppress(stone.ubBlock())) return null;
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.igneousCobblestone) return null;
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.metamorphicCobblestone) return null;
+        return new ShapelessOreRecipe(new ItemStack(Blocks.stone_button,1), product.stackOf(1));
+    }
+
+    private static UBButtonBase constructBlock;
+    Block definedBlock() {
+        if (constructBlock == null) {
+            constructBlock = new UBButtonBase(UBIDs.UBButtonName);
+            UBIDs.UBButtonName.gameRegister(constructBlock, ItemUBButton.class);
+        }
+        return constructBlock;
+    }
+
+}
+
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEStairsGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEStairsGroup.java
new file mode 100644
index 0000000..9c72397
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEStairsGroup.java
@@ -0,0 +1,14 @@
+/**
+ *
+ * @author Zeno410
+ *
+ * Constructor for the Stairs group
+ */
+
+package exterminatorJeff.undergroundBiomes.constructs.block;
+
+
+public class UBTEStairsGroup extends UBStairsGroup {
+   
+    
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEWallGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEWallGroup.java
new file mode 100644
index 0000000..6a2812e
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBTEWallGroup.java
@@ -0,0 +1,29 @@
+/**
+ *
+ * @author Zeno410
+ */
+
+package exterminatorJeff.undergroundBiomes.constructs.block;
+
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBWall;
+
+import net.minecraft.block.Block;
+
+
+public class UBTEWallGroup  extends UBWallGroup {
+
+    public UBTEWallGroup() {
+        super();
+    }
+
+    private static UBWallBase constructBlock;
+    Block definedBlock() {
+        if (constructBlock == null) {
+            constructBlock = new UBWallBase(baseBlock(),UBIDs.UBWallsName);
+            UBIDs.UBWallsName.gameRegister(constructBlock, ItemUBWall.class);
+        }
+        return constructBlock;
+    }
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWall.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWall.java
new file mode 100644
index 0000000..f142630
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWall.java
@@ -0,0 +1,111 @@
+/**
+ *
+ * @author Zeno410
+ */
+
+package exterminatorJeff.undergroundBiomes.constructs.block;
+import exterminatorJeff.undergroundBiomes.api.NamedBlock;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlockList;
+
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+
+import java.util.List;
+import java.util.Random;
+
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockWall;
+import net.minecraft.creativetab.CreativeTabs;
+import net.minecraft.world.IBlockAccess;
+import net.minecraft.util.IIcon;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemStack;
+import net.minecraft.world.World;
+import net.minecraft.entity.Entity;
+
+import Zeno410Utils.Zeno410Logger;
+import java.util.logging.Logger;
+import net.minecraft.client.renderer.texture.IIconRegister;
+
+public class UBWall extends BlockWall {
+
+    private int storedID;
+    public static Logger logger = new Zeno410Logger("UBWallBase").logger();
+    private final BlockMetadataBase baseBlock;
+
+    public UBWall(BlockMetadataBase _baseBlock) {
+        super(_baseBlock);
+        baseBlock = _baseBlock;
+        this.isBlockContainer = false;
+        this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+        this.setBlockName("wall");
+    }
+    
+    @Override
+    public void registerBlockIcons(IIconRegister arg0) {
+        //super.registerBlockIcons(arg0);
+    }
+    public BlockMetadataBase baseBlock() {return baseBlock;}
+
+    @Override
+    public void getSubBlocks(Item item, CreativeTabs tabs, List list) {
+        if (!(UndergroundBiomes.wallsOn())) return;
+        for (int i = 0; i < BlockMetadataBase.metadatas; i++){
+            list.add(new ItemStack(item, 1, i));
+        }
+    }
+
+    @Override
+    public int getDamageValue(World world, int x, int y, int z){
+        return world.getBlockMetadata(x,y,z);
+    }
+
+    @Override
+    public float getBlockHardness(World world, int x, int y, int z){
+        return this.baseBlock.getBlockHardness(world, x, y, z);
+    }
+
+    @Override
+    public IIcon getIcon(int side, int metadata) {
+        return this.baseBlock.getIcon(side, metadata);
+    }
+
+    @Override
+    public IIcon getIcon(IBlockAccess world, int x, int y, int z, int side){
+        return this.baseBlock.getIcon(world, x,y,z, side);
+    }
+
+
+    @Override
+    public boolean isReplaceableOreGen(World world, int x, int y, int z, Block target){
+        return false;
+    }
+
+    @Override
+    public float getExplosionResistance(Entity par1Entity, World world, int x, int y, int z,
+            double explosionX, double explosionY, double explosionZ){
+        return this.baseBlock.getExplosionResistance(par1Entity, world, x, y, z, explosionX, explosionY, explosionZ);
+    }
+
+    @Override
+    public int getRenderType(){return 32;}
+
+    @Override
+    public int damageDropped(int metadata) {
+        return metadata;
+    }
+
+    public ItemStack itemDropped(int metadata, Random random, int fortune, int y){
+        return new ItemStack(this, 1, metadata);
+    }
+
+    public String getBlockName(int meta) {
+        return this.baseBlock.getBlockName(meta);
+    }
+
+    @Override
+    public boolean canPlaceTorchOnTop(World world, int x, int y, int z) {
+        return true;
+    }
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallBase.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallBase.java
index a098c17..5741555 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallBase.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallBase.java
@@ -31,6 +31,7 @@ import net.minecraft.entity.Entity;
 
 import Zeno410Utils.Zeno410Logger;
 import java.util.logging.Logger;
+import net.minecraft.client.renderer.texture.IIconRegister;
 
 public class UBWallBase extends BlockWall  implements ITileEntityProvider{
 
@@ -42,7 +43,8 @@ public class UBWallBase extends BlockWall  implements ITileEntityProvider{
         super(_baseBlock);
         name = namer;
         this.isBlockContainer = false;
-        this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+        //this.setCreativeTab(UndergroundBiomes.tabModBlocks);
+        this.setCreativeTab(null);
         this.setBlockName("wall");
     }
 
@@ -50,6 +52,11 @@ public class UBWallBase extends BlockWall  implements ITileEntityProvider{
         name.register(storedID, this);
     }
     
+    @Override
+    public void registerBlockIcons(IIconRegister arg0) {
+        //super.registerBlockIcons(arg0);
+    }
+    
     public void reRegister() {
         name.reRegister(storedID, this);
     }
@@ -61,7 +68,7 @@ public class UBWallBase extends BlockWall  implements ITileEntityProvider{
     public boolean hasTileEntity() {return true;}
     
     public TileEntity createNewTileEntity(World world, int i) {
-        return new UndergroundBiomesTileEntity();
+        throw new RuntimeException();
     }
     
     @Override
@@ -186,17 +193,20 @@ public class UBWallBase extends BlockWall  implements ITileEntityProvider{
         super.onBlockPreDestroy( world,  x,  y,  z, p_149725_5_);
         // the tile entity we need for the drops is destroyed during the drop procedure
         // so we have to grab the index here
-        cacheCode(x,y,z,ubBlock(world,x,y,z));
+        TileEntity entity = world.getTileEntity(x, y, z);
+        if (entity != null&&(entity instanceof UndergroundBiomesTileEntity)){
+            cacheCode(x,y,z,ubBlock(world,x,y,z),world);
+        }
     }
 
-    private void cacheCode(int x, int y, int z, UndergroundBiomesBlock code) {
-        UndergroundBiomes.instance().ubCodeLocations.add(x, y, z, code);
+    private void cacheCode(int x, int y, int z, UndergroundBiomesBlock code,World world) {
+        UndergroundBiomes.instance().ubCodeLocations(world).add(x, y, z, code);
     }
 
-    private UndergroundBiomesBlock unCacheCode(int x, int y, int z){
+    private UndergroundBiomesBlock unCacheCode(int x, int y, int z,World world){
         UndergroundBiomesBlock result;
-        result = UndergroundBiomes.instance().ubCodeLocations.get(x, y, z);
-        UndergroundBiomes.instance().ubCodeLocations.remove(x, y, z);
+        result = UndergroundBiomes.instance().ubCodeLocations(world).get(x, y, z);
+        UndergroundBiomes.instance().ubCodeLocations(world).remove(x, y, z);
         return result;
     }
 
@@ -206,11 +216,10 @@ public class UBWallBase extends BlockWall  implements ITileEntityProvider{
         ArrayList<ItemStack> ret = new ArrayList<ItemStack>();
 
         int count = quantityDropped(metadata, fortune, world.rand);
-        for(int i = 0; i < count; i++)
-        {
+        for(int i = 0; i < count; i++) {
             Item item = getItemDropped(metadata, world.rand, fortune);
             if (item != null) {
-                int index = this.unCacheCode(x, y, z).index;
+                int index = this.unCacheCode(x, y, z,world).index;
                 ret.add(new ItemStack(item, 1,index));
             }
         }
@@ -225,7 +234,7 @@ public class UBWallBase extends BlockWall  implements ITileEntityProvider{
     public void onBlockDestroyedByPlayer(World world, int x, int y, int z, int p_149664_5_) {
         super.onBlockDestroyedByPlayer(world, x,y , z, p_149664_5_);
         TileEntity entity = world.getTileEntity(x, y, z);
-        if (entity != null) {
+        if (entity != null&&(entity instanceof UndergroundBiomesTileEntity)) {
              world.removeTileEntity(x, y, z);
         }
     }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallBlockGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallBlockGroup.java
new file mode 100644
index 0000000..9034601
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallBlockGroup.java
@@ -0,0 +1,84 @@
+
+package exterminatorJeff.undergroundBiomes.constructs.block;
+
+import exterminatorJeff.undergroundBiomes.api.NamedBlock;
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBWallBlock;
+import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlock;
+import exterminatorJeff.undergroundBiomes.constructs.util.UndergroundBiomesBlockList;
+import net.minecraft.block.Block;
+import net.minecraft.item.ItemStack;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class UBWallBlockGroup extends UBWallGroup {
+
+    private UBWall igneousStoneWall;
+    private UBWall igneousCobblestoneWall;
+    private UBWall igneousStoneBrickWall;
+    private UBWall metamorphicStoneWall;
+    private UBWall metamorphicCobblestoneWall;
+    private UBWall metamorphicStoneBrickWall;
+    private UBWall sedimentaryStoneWall;
+
+    public void define() {
+       igneousStoneWall = createWall(UndergroundBiomes.igneousStone);
+       igneousCobblestoneWall= createWall(UndergroundBiomes.igneousCobblestone);
+       igneousStoneBrickWall= createWall(UndergroundBiomes.igneousStoneBrick);
+       metamorphicStoneWall= createWall(UndergroundBiomes.metamorphicStone);
+       metamorphicCobblestoneWall= createWall(UndergroundBiomes.metamorphicCobblestone);
+       metamorphicStoneBrickWall= createWall(UndergroundBiomes.metamorphicStoneBrick);
+       sedimentaryStoneWall= createWall(UndergroundBiomes.sedimentaryStone);
+    }
+
+    private Block wallFor(UndergroundBiomesBlock base) {
+        if (base.ubBlock == UndergroundBiomes.igneousStone) return igneousStoneWall;
+        if (base.ubBlock == UndergroundBiomes.igneousCobblestone) return igneousCobblestoneWall;
+        if (base.ubBlock == UndergroundBiomes.igneousStoneBrick) return igneousStoneBrickWall;
+        if (base.ubBlock == UndergroundBiomes.metamorphicStone) return metamorphicStoneWall;
+        if (base.ubBlock == UndergroundBiomes.metamorphicCobblestone) return metamorphicCobblestoneWall;
+        if (base.ubBlock == UndergroundBiomes.metamorphicStoneBrick) return metamorphicStoneBrickWall;
+        if (base.ubBlock == UndergroundBiomes.sedimentaryStone) return sedimentaryStoneWall;
+        throw new RuntimeException(base.ubBlock.getUnlocalizedName());
+    }
+
+    private UBWall createWall(BlockMetadataBase sourceBlock) {
+        NamedBlock createdNamer = new NamedBlock(UBIDs.UBWallsName.internal()+"."+sourceBlock.getUnlocalizedName());
+        UBWall created = new UBWall(sourceBlock);
+        createdNamer.gameRegister(created, ItemUBWallBlock.class);
+        return created;
+    }
+
+    @Override
+    public ProductItemDefiner productItemDefiner(int index) {
+        return new BlockProductItemDefiner(index);
+    }
+
+    class BlockProductItemDefiner extends ProductItemDefiner {
+
+        BlockProductItemDefiner(int _stoneIndex) {
+            super(_stoneIndex);
+        }
+
+        private UndergroundBiomesBlock ubBlock() {
+            return UndergroundBiomesBlockList.indexed(stoneIndex);
+        }
+
+        private Block product() {
+            return wallFor(ubBlock());
+        }
+
+        private int productMetadata() {
+            return ubBlock().metadata;
+        }
+        @Override
+        public final ItemStack stackOf(int items) {
+
+            return new ItemStack(product(),items,productMetadata());
+        }
+    }
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallGroup.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallGroup.java
index 6f3c333..07ee4e0 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallGroup.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/block/UBWallGroup.java
@@ -1,7 +1,3 @@
-/**
- *
- * @author Zeno410
- */
 
 package exterminatorJeff.undergroundBiomes.constructs.block;
 
@@ -10,14 +6,15 @@ import exterminatorJeff.undergroundBiomes.constructs.item.ItemUBWall;
 
 import cpw.mods.fml.common.registry.GameRegistry;
 
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 import net.minecraft.block.Block;
-import net.minecraft.inventory.InventoryCrafting;
+import net.minecraft.init.Blocks;
 import net.minecraft.item.crafting.IRecipe;
 import net.minecraft.item.Item;
-import net.minecraft.item.ItemBlock;
 import net.minecraft.item.ItemStack;
 
 import net.minecraftforge.oredict.ShapedOreRecipe;
+import net.minecraftforge.oredict.ShapelessOreRecipe;
 
 public class UBWallGroup  extends UBConstructGroup {
 
@@ -39,6 +35,7 @@ public class UBWallGroup  extends UBConstructGroup {
             Item toGetProduct = wallRecipe.getRecipeOutput().copy().getItem();
             //ItemUBWall.logger.info(""+Item.getIdFromItem(toGetProduct));
             //ItemUBWall.logger.info(""+Item.getIdFromItem(toGet));
+            GameRegistry.addShapelessRecipe(new ItemStack(Blocks.cobblestone_wall,1), product.stackOf(1));
             //product.stackOf(6).func_77980_a(ItemStack.java:411)
     }
 
@@ -46,11 +43,17 @@ public class UBWallGroup  extends UBConstructGroup {
         return wallRecipe(product,stone);
     }
 
-    private ShapedOreRecipe wallRecipe(ProductItemDefiner product, StoneItemDefiner stone) {
-        return new ShapedOreRecipe(product.stackOf(6), "   ", "XXX", "XXX", 'X', stone.one());
+    IRecipe rescueRecipe(ProductItemDefiner product, StoneItemDefiner stone) {
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.igneousCobblestone){
+            return new ShapelessOreRecipe(new ItemStack(Blocks.cobblestone_wall,1), product.stackOf(1));
+        }
+        if (stone.ubBlock().ubBlock == UndergroundBiomes.metamorphicCobblestone) {
+            return new ShapelessOreRecipe(new ItemStack(Blocks.cobblestone_wall,1), product.stackOf(1));
+        }
+        return null;
     }
-    Class<? extends ItemBlock> itemClass() {
-        return ItemUBWall.class;
+    ShapedOreRecipe wallRecipe(ProductItemDefiner product, StoneItemDefiner stone) {
+        return new ShapedOreRecipe(product.stackOf(6), "   ", "XXX", "XXX", 'X', stone.one());
     }
 
     private static UBWallBase constructBlock;
@@ -62,29 +65,4 @@ public class UBWallGroup  extends UBConstructGroup {
         return constructBlock;
     }
 
-    class WallRecipe extends ShapedOreRecipe {
-        public WallRecipe(ProductItemDefiner product, StoneItemDefiner stone) {
-            super (product.stackOf(6), "   ", "XXX", "XXX", 'X', stone.one());
-        }
-
-        public ItemStack getCraftingResult(InventoryCrafting var1) {
-            ItemStack result =  super.getCraftingResult(var1);
-            int registeredID = Item.getIdFromItem(result.getItem());
-            //ItemUBWall.logger.info("crafting "+registeredID+" " +result.getItem().toString());
-            if (registeredID == -1) {
-                ItemUBWall wallItem = (ItemUBWall)(result.getItem());
-                registeredID = Item.getIdFromItem(result.getItem());
-                throw new RuntimeException();
-            }
-            //ItemUBWall.logger.info("crafting "+registeredID+" " +result.getItem().toString());
-            return result;
-        }
-
-        public ItemStack getRecipeOutput() {
-            ItemStack result = super.getRecipeOutput();
-            //ItemUBWall.logger.info("output "+Item.getIdFromItem(result.getItem())+" " +result.getItem().toString());
-            return result;
-        }
-        
-    }
 }
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBButtonBlock.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBButtonBlock.java
new file mode 100644
index 0000000..6813829
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBButtonBlock.java
@@ -0,0 +1,129 @@
+package exterminatorJeff.undergroundBiomes.constructs.item;
+
+import cpw.mods.fml.relauncher.Side;
+import cpw.mods.fml.relauncher.SideOnly;
+import exterminatorJeff.undergroundBiomes.api.NamedItem;
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBButton;
+import net.minecraft.block.Block;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.item.ItemMultiTexture;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IIcon;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class ItemUBButtonBlock extends ItemMultiTexture {
+    private UBButton ubButton;
+    private NamedItem name;
+    protected String names;
+    public static int top = 2;
+
+    private static String names(Block appearance, NamedItem name,int metadata) {
+        String result = new String();
+        BlockMetadataBase sourceBlock =((UBButton)appearance).baseStone();
+        result = sourceBlock.getBlockTypeName(metadata)+"."+ name.internal();
+        return result;
+    }
+
+    public ItemUBButtonBlock(Block ubBlock) {
+        this(ubBlock, UBIDs.UBButtonItemName);
+    }
+
+    public int getMetatata(int metadata) {
+        return metadata;}
+
+    public ItemUBButtonBlock(Block ubBlock, NamedItem name) {
+        //super(_structure, appearance,names(appearance,_name));
+        super(ubBlock,null,null);
+        //this(Blocks.cobblestone_wall, ubBlock,names(ubBlock,name));
+        ubButton = (UBButton)ubBlock;
+
+        this.names = names(ubBlock,name,ubButton.lowerMetadata());
+        this.name = name;
+        this.setUnlocalizedName(name.internal());
+        this.setMaxDamage(0);
+        this.setHasSubtypes(true);
+        //this.setUnlocalizedName(_name.external());
+        //bFull3D = true;
+    }
+   @Override
+    public int getColorFromItemStack(ItemStack itemStack, int par2) {
+        currentColor = getIconFromDamage(itemStack.getItemDamage());
+        return super.getColorFromItemStack(itemStack, par2);
+    }
+
+    public static IIcon currentColor;
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIcon(ItemStack stack, int pass) {
+        return this.getIconIndex(stack);
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIconFromDamageForRenderPass(int par1, int par2) {
+        return getIconFromDamage(par2);
+    }
+
+    @Override
+    public int getDamage(ItemStack stack) {
+        return super.getDamage(stack);
+    }
+
+
+    @Override
+    public int getDisplayDamage(ItemStack stack) {
+        return super.getDisplayDamage(stack);
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIconIndex(ItemStack itemStack) {
+        return getIconFromDamage(itemStack.getItemDamage());
+
+    }
+
+
+    @Override
+    public boolean requiresMultipleRenderPasses() {
+        return false;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIconFromDamage(int par1) {
+        //if (par1>0) throw new RuntimeException();
+        //return Blocks.cobblestone.getIcon(1, 0);
+        return ubButton.baseStone().getIcon(top, ubButton.blockMetadata(par1));//
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIcon(ItemStack stack, int renderPass, EntityPlayer player, ItemStack usingItem, int useRemaining) {
+        return getIconIndex(usingItem);
+    }
+
+    int nameReference(int metadata) {
+        return metadata>>3;
+    }
+    @Override
+    public String getUnlocalizedName(ItemStack stack)
+    {
+        return  ubButton.baseStone().getUnlocalizedName()+"." + (String)this.names;
+    }
+
+    @Override
+    public int getSpriteNumber() {
+        return 0;
+    }
+
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBStairs.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBStairs.java
index b452495..38b2986 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBStairs.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBStairs.java
@@ -9,6 +9,7 @@ import java.util.ArrayList;
 import net.minecraft.block.Block;
 
 import net.minecraft.entity.EntityLivingBase;
+import net.minecraft.entity.player.EntityPlayer;
 import net.minecraft.util.MathHelper;
 import net.minecraft.world.World;
 
@@ -31,29 +32,32 @@ public class ItemUBStairs extends ItemUndergroundBiomesConstruct {
 
     public String groupName() {return "stairs";}
 
-    public void onBlockPlacedBy(World p_149689_1_, int p_149689_2_, int p_149689_3_, int p_149689_4_, EntityLivingBase p_149689_5_, ItemStack p_149689_6_)
+    public void onBlockPlacedBy(World p_149689_1_, int p_149689_2_, int p_149689_3_, int p_149689_4_, EntityLivingBase p_149689_5_, ItemStack stairs)
     {
         int l = MathHelper.floor_double((double)(p_149689_5_.rotationYaw * 4.0F / 360.0F) + 0.5D) & 3;
-        int i1 = p_149689_1_.getBlockMetadata(p_149689_2_, p_149689_3_, p_149689_4_) & 4;
+        int i1 = p_149689_1_.getBlockMetadata(p_149689_2_, p_149689_3_, p_149689_4_) ;
+        int metadata = stairs.getItemDamage();
 
         if (l == 0)
         {
-            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, 2 | i1, 2);
+            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, 2 | i1 | metadata, 2);
         }
 
         if (l == 1)
         {
-            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, 1 | i1, 2);
+            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, 1 | i1| metadata, 2);
         }
 
         if (l == 2)
         {
-            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, 3 | i1, 2);
+            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, 3 | i1| metadata, 2);
         }
 
         if (l == 3)
         {
-            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, 0 | i1, 2);
+            p_149689_1_.setBlockMetadataWithNotify(p_149689_2_, p_149689_3_, p_149689_4_, 0 | i1| metadata, 2);
         }
+
+        throw new RuntimeException("" + metadata + " " + (0 | i1| metadata));
     }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBStairsBlock.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBStairsBlock.java
new file mode 100644
index 0000000..70d9f20
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBStairsBlock.java
@@ -0,0 +1,138 @@
+package exterminatorJeff.undergroundBiomes.constructs.item;
+
+import cpw.mods.fml.relauncher.Side;
+import cpw.mods.fml.relauncher.SideOnly;
+import exterminatorJeff.undergroundBiomes.api.NamedItem;
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBStairs;
+import net.minecraft.block.Block;
+import net.minecraft.entity.player.EntityPlayer;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.item.ItemMultiTexture;
+import net.minecraft.item.ItemStack;
+import net.minecraft.util.IIcon;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class ItemUBStairsBlock extends ItemMultiTexture {
+    private UBStairs ubStairs;
+    private NamedItem name;
+    protected String[] names;
+    public static int top = 2;
+
+    private static String[] names(Block appearance, NamedItem name,int metadata) {
+        String [] result = new String[2];
+        for (int i = metadata ; i < metadata + 2; i++) {
+            BlockMetadataBase sourceBlock =((UBStairs)appearance).baseStone();
+            result[i-metadata] = sourceBlock.getBlockTypeName(i)+"."+ name.internal();
+        }
+        return result;
+    }
+
+    public ItemUBStairsBlock(Block ubBlock) {
+        this(ubBlock, UBIDs.UBStairsItemName);
+    }
+
+    public int getMetatata(int metadata) {
+        if (metadata == 0) throw new RuntimeException();
+        return metadata;}
+
+    public ItemUBStairsBlock(Block ubBlock, NamedItem name) {
+        //super(_structure, appearance,names(appearance,_name));
+        super(ubBlock,null,null);
+        //this(Blocks.cobblestone_wall, ubBlock,names(ubBlock,name));
+        ubStairs = (UBStairs)ubBlock;
+
+        this.names = names(ubBlock,name,ubStairs.lowerMetadata());
+        this.name = name;
+        this.setUnlocalizedName(name.internal());
+        this.setMaxDamage(0);
+        this.setHasSubtypes(true);
+        //this.setUnlocalizedName(_name.external());
+        //bFull3D = true;
+    }
+   @Override
+    public int getColorFromItemStack(ItemStack itemStack, int par2) {
+        currentColor = getIconFromDamage(itemStack.getItemDamage());
+        return super.getColorFromItemStack(itemStack, par2);
+    }
+
+   
+    public static IIcon currentColor;
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIcon(ItemStack stack, int pass) {
+
+        //return this.getIconIndex(stack);
+        return currentColor;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIconFromDamageForRenderPass(int par1, int par2) {
+        return currentColor;
+        //return getIconFromDamage(par2);
+    }
+
+    @Override
+    public int getDamage(ItemStack stack) {
+        return super.getDamage(stack);
+    }
+
+
+    @Override
+    public int getDisplayDamage(ItemStack stack) {
+        return super.getDisplayDamage(stack);
+    }
+           
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIconIndex(ItemStack itemStack) {
+        return getIconFromDamage(itemStack.getItemDamage());
+
+    }
+
+
+    @Override
+    public boolean requiresMultipleRenderPasses() {
+        return false;
+    }
+    
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIconFromDamage(int par1) {
+        IIcon result = ubStairs.baseStone().getIcon(top, ubStairs.blockMetadata(par1));//
+        currentColor = result;
+        ubStairs.currentIcon = result;
+        ubStairs.renderingItem = true;
+        return result;
+    }
+
+    @Override
+    @SideOnly(Side.CLIENT)
+    public IIcon getIcon(ItemStack stack, int renderPass, EntityPlayer player, ItemStack usingItem, int useRemaining) {
+        return getIconIndex(usingItem);
+    }
+
+    int nameReference(int metadata) {
+        return metadata>>3;
+    }
+    @Override
+    public String getUnlocalizedName(ItemStack stack)
+    {
+        return  ubStairs.baseStone().getUnlocalizedName()+"." + (String)this.names[nameReference(stack.getItemDamage())];
+    }
+
+    @Override
+    public int getSpriteNumber() {
+        return 0;
+    }
+
+   
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBWallBlock.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBWallBlock.java
new file mode 100644
index 0000000..4cea7af
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/item/ItemUBWallBlock.java
@@ -0,0 +1,58 @@
+
+package exterminatorJeff.undergroundBiomes.constructs.item;
+
+import exterminatorJeff.undergroundBiomes.api.NamedItem;
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import exterminatorJeff.undergroundBiomes.constructs.block.UBWall;
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.item.ItemBlock;
+import net.minecraft.item.ItemStack;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class ItemUBWallBlock extends ItemBlock {
+    private Block ubWall;
+    private NamedItem name;
+    protected String[] names;
+
+    private static String[] names(Block appearance, NamedItem name) {
+        String [] result = new String[BlockMetadataBase.metadatas];
+        for (int i = 0 ; i < BlockMetadataBase.metadatas; i++) {
+            BlockMetadataBase sourceBlock =((UBWall)appearance).baseBlock();
+            result[i] = sourceBlock.getBlockTypeName(i)+"."+ name.internal();
+        }
+        return result;
+    }
+    public ItemUBWallBlock(Block ubBlock) {
+        this(ubBlock, UBIDs.UBWallsItemName);
+    }
+
+    public ItemUBWallBlock(Block ubBlock, NamedItem name) {
+        //super(_structure, appearance,names(appearance,_name));
+        super(ubBlock);
+        //this(Blocks.cobblestone_wall, ubBlock,names(ubBlock,name));
+
+        this.names = names(ubBlock,name);
+        this.ubWall = ubBlock;
+        this.name = name;
+        this.setUnlocalizedName(name.internal());
+        this.setMaxDamage(0);
+        this.setHasSubtypes(true);
+        //this.setUnlocalizedName(_name.external());
+        //bFull3D = true;
+    }
+
+    public int getMetadata(int damage){
+        return damage;
+    }
+
+    @Override
+    public String getUnlocalizedName(ItemStack stack)
+    {
+        return  ((UBWall)ubWall).baseBlock().getUnlocalizedName()+"." + (String)this.names[stack.getItemDamage()];
+    }
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/util/ShamWorld.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/util/ShamWorld.java
index 422c601..731e65c 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/util/ShamWorld.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/util/ShamWorld.java
@@ -32,6 +31,11 @@ public class ShamWorld extends World {
     }
 
     @Override
+    protected int func_152379_p() {
+        return 256;
+    }
+
+    @Override
     protected IChunkProvider createChunkProvider() {
         throw new UnsupportedOperationException("Not supported yet.");
     }
@@ -41,11 +45,4 @@ public class ShamWorld extends World {
         throw new UnsupportedOperationException("Not supported yet.");
     }
 
-
-	@Override
-	protected int func_152379_p() {
-		// Render distance in chunks.
-		return 0;
-	}
-
 }
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/util/UBCodeLocations.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/util/UBCodeLocations.java
index 7ecec94..ba40b12 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/constructs/util/UBCodeLocations.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/constructs/util/UBCodeLocations.java
@@ -18,7 +18,7 @@ public class UBCodeLocations {
         BlockLocation location = BlockLocation.fetch(x,y,z);
         if (stored.containsKey(location)) {
             if (UndergroundBiomes.crashOnProblems()) {
-                throw new RuntimeException();
+                //throw new RuntimeException();
             }
         }
         stored.put(location, ubBlock);
@@ -45,7 +45,7 @@ public class UBCodeLocations {
         // for world loads. Crash under development if not empty.
         if (!stored.isEmpty()) {
             if (UndergroundBiomes.crashOnProblems()) {
-                throw new RuntimeException();
+                //throw new RuntimeException();
             } else {
                 stored.clear();
             }
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBBadlands.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBBadlands.java
new file mode 100644
index 0000000..2b0bf24
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBBadlands.java
@@ -0,0 +1,71 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import highlands.biome.BiomeDecoratorHighlands;
+import highlands.biome.BiomeGenBadlands;
+import highlands.biome.BiomeGenBaseHighlands;
+import java.util.Random;
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.BiomeGenBase;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class BiomeGenUBBadlands extends BiomeGenBadlands {
+    private WorldGenerator ubStoneGenerator = new WorldGenUndergroundUB(Blocks.stone, 72, Blocks.dirt);;
+    private static final Height biomeHeight = new Height(0.8F, 0.45F);
+
+    public BiomeGenUBBadlands(int biomeID) {
+        super(biomeID);
+	    int trees = 1;
+	    int grass = 6;
+	    int flowers = 0;
+	    int plants = 1;
+	    ((BiomeGenBase)this).theBiomeDecorator = new BiomeDecoratorHighlands(this, trees, grass, flowers, plants);
+
+        ((BiomeGenBase)this).setHeight(biomeHeight);
+        ((BiomeGenBase)this).temperature = 0.6F;
+        ((BiomeGenBase)this).rainfall = 0.1F;
+        ((BiomeGenBase)this).setBiomeName("Badlands");
+    }
+
+    @Override
+	public void decorate(World world, Random random, int x, int z) {
+    	BiomeGenBaseHighlands biome = this;
+    	((BiomeGenBase)this).theBiomeDecorator.decorateChunk(world, random, biome, x, z);
+        int var5 = 3 + random.nextInt(6);
+
+        for (int var6 = 0; var6 < var5; ++var6)
+        {
+            int var7 = x + random.nextInt(16);
+            int var8 = random.nextInt(28) + 4;
+            int var9 = z + random.nextInt(16);
+            Block var10 = world.getBlock(var7, var8, var9);
+
+            if (var10 == Blocks.stone)
+            {
+            	world.setBlock(var7, var8, var9, Blocks.emerald_ore, 0, 2);
+            }
+        }
+
+        genUBStoneHighlandsNoCheck(world, random, x, z, 6, ubStoneGenerator, 62, 120);
+        BiomeDecoratorHighlands decorator = (BiomeDecoratorHighlands) ((BiomeGenBase)this).theBiomeDecorator;
+        decorator.genOreHighlands(world, random, x, z, 2, ((BiomeGenBase)this).theBiomeDecorator.goldGen, 0, 32);
+    }
+
+    public void genUBStoneHighlandsNoCheck(World world, Random random, int locX, int locZ, int timesPerChunk, WorldGenerator oreGen, int minH, int maxH)
+    {
+        for (int var5 = 0; var5 < timesPerChunk; ++var5)
+        {
+            int var6 = locX + random.nextInt(16);
+            int var7 = random.nextInt(maxH - minH) + minH;
+            int var8 = locZ + random.nextInt(16);
+            oreGen.generate(world, random, var6, var7, var8);
+        }
+    }
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBCliffs.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBCliffs.java
new file mode 100644
index 0000000..f05c426
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBCliffs.java
@@ -0,0 +1,74 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import highlands.biome.BiomeDecoratorHighlands;
+import highlands.biome.BiomeGenBaseHighlands;
+import highlands.biome.BiomeGenCliffs;
+import java.util.Random;
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.BiomeDecorator;
+import net.minecraft.world.biome.BiomeGenBase;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class BiomeGenUBCliffs extends BiomeGenCliffs {
+
+    public BiomeGenUBCliffs(BiomeGenCliffs model, int biomeID) {
+        super(biomeID);
+	 	int trees = 2;
+	    int grass = 4;
+	    int flowers = 0;
+	    int plants = 1;
+	    ((BiomeGenBase)this).theBiomeDecorator = new BiomeDecoratorHighlands(this, trees, grass, flowers);
+        ((BiomeGenBase)this).setHeight(new Height(1.0F, 0.5F));
+        ((BiomeGenBase)this).temperature = 0.4F;
+        ((BiomeGenBase)this).rainfall = 0.4F;
+        ((BiomeGenBase)this).setBiomeName("Cliffs");
+    }
+
+    @Override
+    public WorldGenerator getRandomWorldGenForGrass(Random par1Random) {
+        return new WorldGenBoulders(Blocks.tallgrass,1);
+    }
+
+    @Override
+	public void decorate(World world, Random random, int x, int z) {
+		BiomeGenBaseHighlands biome = this;
+		((BiomeGenBase)this).theBiomeDecorator.decorateChunk(world, random, biome, x, z);
+        int var5 = 3 + random.nextInt(6);
+
+        for (int var6 = 0; var6 < var5; ++var6)
+        {
+            int var7 = x + random.nextInt(16);
+            int var8 = random.nextInt(28) + 4;
+            int var9 = z + random.nextInt(16);
+            Block var10 = world.getBlock(var7, var8, var9);
+
+            if (var10.isReplaceableOreGen(world, x, z, z, Blocks.stone))
+            {
+            	world.setBlock(var7, var8, var9, Blocks.emerald_ore, 0, 2);
+            }
+        }
+
+        BiomeDecorator theDecorator = ((BiomeGenBase)this).theBiomeDecorator;
+
+        BiomeDecoratorHighlands highlandsDecorator = (BiomeDecoratorHighlands)theDecorator;
+
+        highlandsDecorator.genOreHighlands(world, random, x, z, 20,
+                ((BiomeDecorator)((BiomeGenBase)this).theBiomeDecorator).ironGen, 64, 128);
+        highlandsDecorator.genOreHighlands(world, random, x, z, 8,
+                ((BiomeDecorator)((BiomeGenBase)this).theBiomeDecorator).redstoneGen, 16, 32);
+        highlandsDecorator.genOreHighlands(world, random, x, z, 1,
+                ((BiomeDecorator)((BiomeGenBase)this).theBiomeDecorator).lapisGen, 32, 64);
+        highlandsDecorator.genOreHighlands(world, random, x, z, 2,
+                ((BiomeDecorator)((BiomeGenBase)this).theBiomeDecorator).goldGen, 32, 64);
+        highlandsDecorator.genOreHighlands(world, random, x, z, 1,
+                ((BiomeDecorator)((BiomeGenBase)this).theBiomeDecorator).diamondGen, 16, 32);
+    }
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBDesertMountains.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBDesertMountains.java
new file mode 100644
index 0000000..a44b33c
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBDesertMountains.java
@@ -0,0 +1,64 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import highlands.biome.BiomeDecoratorHighlands;
+import highlands.biome.BiomeGenBaseHighlands;
+import highlands.biome.BiomeGenDesertMountains;
+import highlands.worldgen.WorldGenHighlandsShrub;
+import java.util.Random;
+import net.minecraft.init.Blocks;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.BiomeGenBase;
+import net.minecraft.world.biome.BiomeGenBase.Height;
+import net.minecraft.world.gen.feature.WorldGenAbstractTree;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class BiomeGenUBDesertMountains extends BiomeGenDesertMountains
+{
+    private static final Height biomeHeight = new Height(1.6F, 0.5F);
+
+	public BiomeGenUBDesertMountains(int par1)
+    {
+        super(par1);
+        int trees = -999;
+	    int grass = 0;
+	    int flowers = 0;
+	    ((BiomeGenBase)this).theBiomeDecorator = new BiomeDecoratorHighlands(this, trees, grass, flowers);
+
+        //((BiomeGenBase)this).spawnableCreatureList.clear();
+
+        ((BiomeGenBase)this).topBlock = Blocks.sand;
+        ((BiomeGenBase)this).fillerBlock = Blocks.sand;
+        ((BiomeGenBase)this).temperature = 0.9F;
+        ((BiomeGenBase)this).rainfall = 0.0F;
+
+        ((BiomeGenBase)this).setDisableRain();
+        ((BiomeGenBase)this).setBiomeName("Desert Mountains");
+    }
+
+    @Override
+    public WorldGenAbstractTree func_150567_a(Random par1Random)
+    {
+        return (WorldGenAbstractTree)(new WorldGenHighlandsShrub(1, 1));
+    }
+
+    @Override
+	public void decorate(World world, Random random, int x, int z) {
+
+    	if(random.nextInt(4) == 0)
+    		new WorldGenUBMountain(15, 20, false, 2).generate(world, random, x+random.nextInt(16), 128, z+random.nextInt(16));
+
+    	BiomeGenBaseHighlands biome = this;
+		((BiomeGenBase)this).theBiomeDecorator.decorateChunk(world, random, biome, x, z);
+
+		((BiomeDecoratorHighlands)((BiomeGenBase)this).theBiomeDecorator).genOreHighlands(world, random, x, z, 20, ((BiomeGenBase)this).theBiomeDecorator.ironGen, 64, 128);
+		((BiomeDecoratorHighlands)((BiomeGenBase)this).theBiomeDecorator).genOreHighlands(world, random, x, z, 8, ((BiomeGenBase)this).theBiomeDecorator.redstoneGen, 16, 32);
+		((BiomeDecoratorHighlands)((BiomeGenBase)this).theBiomeDecorator).genOreHighlands(world, random, x, z, 1, ((BiomeGenBase)this).theBiomeDecorator.lapisGen, 32, 64);
+		((BiomeDecoratorHighlands)((BiomeGenBase)this).theBiomeDecorator).genOreHighlands(world, random, x, z, 2, ((BiomeGenBase)this).theBiomeDecorator.goldGen, 32, 64);
+		((BiomeDecoratorHighlands)((BiomeGenBase)this).theBiomeDecorator).genOreHighlands(world, random, x, z, 4, ((BiomeGenBase)this).theBiomeDecorator.goldGen, 0, 64);
+		((BiomeDecoratorHighlands)((BiomeGenBase)this).theBiomeDecorator).genOreHighlands(world, random, x, z, 1, ((BiomeGenBase)this).theBiomeDecorator.diamondGen, 16, 32);
+    }
+}
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBRockMountains.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBRockMountains.java
new file mode 100644
index 0000000..18ee42a
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBRockMountains.java
@@ -0,0 +1,79 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import java.util.Random;
+
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenAbstractTree;
+import highlands.biome.BiomeDecoratorHighlands;
+import highlands.biome.BiomeGenBaseHighlands;
+import highlands.biome.BiomeGenRockMountains;
+import highlands.worldgen.WorldGenHighlandsShrub;
+import net.minecraft.world.biome.BiomeDecorator;
+import net.minecraft.world.biome.BiomeGenBase;
+
+public class BiomeGenUBRockMountains extends BiomeGenRockMountains
+{
+	private static final Height biomeHeight = new Height(1.8F, 0.5F);
+
+	public BiomeGenUBRockMountains(int par1)
+    {
+        super(par1);
+
+        int trees = -999;
+	    int grass = 2;
+	    int flowers = 0;
+	    ((BiomeGenBase)this).theBiomeDecorator = new BiomeDecoratorHighlands(this, trees, grass, flowers);
+
+        //this.spawnableCreatureList.clear();
+
+        ((BiomeGenBase)this).fillerBlock = Blocks.stone;
+        ((BiomeGenBase)this).setHeight(biomeHeight);
+        ((BiomeGenBase)this).temperature = 0.6F;
+        ((BiomeGenBase)this).rainfall = 0.5F;
+
+        //this.setEnableSnow();
+        ((BiomeGenBase)this).setBiomeName("Rock Mountains");
+    }
+
+    @Override
+    public WorldGenAbstractTree func_150567_a(Random par1Random)
+    {
+        return (WorldGenAbstractTree)(new WorldGenHighlandsShrub(1, 1));
+    }
+
+    @Override
+	public void decorate(World world, Random random, int x, int z) {
+		BiomeGenBaseHighlands biome = this;
+    	if(random.nextInt(2) == 0)
+    		new WorldGenUBMountain(15, 15, false, 1).generate(world, random, x+random.nextInt(16), 128, z+random.nextInt(16));
+
+    	((BiomeGenBase)this).theBiomeDecorator.decorateChunk(world, random, biome, x, z);
+        int var5 = 3 + random.nextInt(6);
+
+        for (int var6 = 0; var6 < var5; ++var6){
+            int var7 = x + random.nextInt(16);
+            int var8 = random.nextInt(28) + 4;
+            int var9 = z + random.nextInt(16);
+            Block var10 = world.getBlock(var7, var8, var9);
+
+            if (var10.isReplaceableOreGen(world, x, z, z, Blocks.stone)) {
+            	world.setBlock(var7, var8, var9, Blocks.emerald_ore, 0, 2);
+            }
+        }
+
+
+        BiomeDecorator theDecorator = ((BiomeGenBase)this).theBiomeDecorator;
+
+        BiomeDecoratorHighlands highlandsDecorator = (BiomeDecoratorHighlands)theDecorator;
+
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 20, ((BiomeGenBase)this).theBiomeDecorator.ironGen, 64, 128);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 40, ((BiomeGenBase)this).theBiomeDecorator.ironGen, 0, 128);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 8, ((BiomeGenBase)this).theBiomeDecorator.redstoneGen, 16, 32);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 1, ((BiomeGenBase)this).theBiomeDecorator.lapisGen, 32, 64);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 2, ((BiomeGenBase)this).theBiomeDecorator.goldGen, 32, 64);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 1, ((BiomeGenBase)this).theBiomeDecorator.diamondGen, 16, 32);
+    }
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBSnowMountains.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBSnowMountains.java
new file mode 100644
index 0000000..7ac7ea0
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/BiomeGenUBSnowMountains.java
@@ -0,0 +1,95 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import highlands.Highlands;
+import highlands.worldgen.WorldGenHighlandsShrub;
+import highlands.worldgen.WorldGenMountain;
+
+import java.util.Random;
+
+import net.minecraft.init.Blocks;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenAbstractTree;
+import net.minecraft.world.gen.feature.WorldGenerator;
+import cpw.mods.fml.relauncher.Side;
+import cpw.mods.fml.relauncher.SideOnly;
+import highlands.biome.BiomeDecoratorHighlands;
+import highlands.biome.BiomeGenBaseHighlands;
+import net.minecraft.block.Block;
+import net.minecraft.world.biome.BiomeDecorator;
+import net.minecraft.world.biome.BiomeGenBase;
+
+public class BiomeGenUBSnowMountains extends BiomeGenBaseHighlands
+{
+	private static final Height biomeHeight = new Height(2.0F, 1.0F);
+
+	public BiomeGenUBSnowMountains(int par1)
+    {
+        super(par1);
+
+        int trees = -999;
+	    int grass = 2;
+	    int flowers = 0;
+	    this.theBiomeDecorator = new BiomeDecoratorHighlands(this, trees, grass, flowers);
+
+        this.spawnableCreatureList.clear();
+
+        this.topBlock = Blocks.snow;
+        this.fillerBlock = Blocks.snow;
+        this.setHeight(biomeHeight);
+        this.temperature = 0.0F;
+        this.rainfall = 0.5F;
+
+        this.setEnableSnow();
+    }
+
+    @Override
+    public WorldGenAbstractTree func_150567_a(Random par1Random)
+    {
+        return (WorldGenAbstractTree)(new WorldGenHighlandsShrub(1, 1));
+    }
+
+    @Override
+    @SuppressWarnings("static-access")
+	public void decorate(World world, Random random, int x, int z) {
+		BiomeGenBaseHighlands biome = this;
+		// WorldType.getTranslateName() doesn't work in bukkit ?
+    	//if(random.nextInt(3) == 0 && !world.provider.terrainType.getTranslateName().equals("ATG - Alternate"))
+    	new WorldGenUBMountain(15, 25, false, 0).generate(world, random, x+random.nextInt(16), 128, z+random.nextInt(16));
+
+    	((BiomeGenBase)this).theBiomeDecorator.decorateChunk(world, random, biome, x, z);
+        int var5 = 3 + random.nextInt(6);
+
+        for (int var6 = 0; var6 < var5; ++var6){
+            int var7 = x + random.nextInt(16);
+            int var8 = random.nextInt(28) + 4;
+            int var9 = z + random.nextInt(16);
+            Block var10 = world.getBlock(var7, var8, var9);
+
+            if (var10.isReplaceableOreGen(world, x, z, z, Blocks.stone)){
+            	world.setBlock(var7, var8, var9, Blocks.emerald_ore, 0, 2);
+            }
+        }
+
+        BiomeDecorator theDecorator = ((BiomeGenBase)this).theBiomeDecorator;
+
+        BiomeDecoratorHighlands highlandsDecorator = (BiomeDecoratorHighlands)theDecorator;
+
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 20, ((BiomeDecoratorHighlands)this.theBiomeDecorator).HLice, 0, 128);
+
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 20, ((BiomeGenBase)this).theBiomeDecorator.ironGen, 64, 128);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 8, ((BiomeGenBase)this).theBiomeDecorator.redstoneGen, 16, 32);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 1, ((BiomeGenBase)this).theBiomeDecorator.lapisGen, 32, 64);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 2, ((BiomeGenBase)this).theBiomeDecorator.goldGen, 32, 64);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 1, ((BiomeGenBase)this).theBiomeDecorator.diamondGen, 16, 32);
+    	highlandsDecorator.genOreHighlands(world, random, x, z, 2, ((BiomeGenBase)this).theBiomeDecorator.diamondGen, 0, 32);
+    }
+
+    @SideOnly(Side.CLIENT)
+    public int getSkyColorByTemp(float par1)
+    {
+    	if(Highlands.skyColorFlag)return 0xC6E3FF;
+    	else return super.getSkyColorByTemp(par1);
+    }
+}
+
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/ModOreManager.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/ModOreManager.java
new file mode 100644
index 0000000..4fdf040
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/ModOreManager.java
@@ -0,0 +1,92 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import Zeno410Utils.Zeno410Logger;
+import exterminatorJeff.undergroundBiomes.api.UBAPIHook;
+import exterminatorJeff.undergroundBiomes.api.UBOreTexturizer;
+import java.util.logging.Logger;
+import net.minecraft.block.Block;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class ModOreManager {
+    public static Logger logger = new Zeno410Logger("ModOreManager").logger();
+
+    public void register() {
+        UBOreTexturizer texturizer = UBAPIHook.ubAPIHook.ubOreTexturizer;
+        {
+            // Thermal Foundation
+            Block thermalFoundationOreBlock = Block.getBlockFromName("ThermalFoundation:Ore");
+            if (thermalFoundationOreBlock != null) {
+                logger.info("Thermal Foundation found");
+                // install texturizers
+                texturizer.requestUBOreSetup(thermalFoundationOreBlock, 0, UBOreTexturizer.copper_overlay, "tile.thermalfoundation.ore.copper");
+                texturizer.requestUBOreSetup(thermalFoundationOreBlock, 1, UBOreTexturizer.tin_overlay, "tile.thermalfoundation.ore.tin");
+                texturizer.requestUBOreSetup(thermalFoundationOreBlock, 2, UBOreTexturizer.silver_overlay, "tile.thermalfoundation.ore.silver");
+                texturizer.requestUBOreSetup(thermalFoundationOreBlock, 3, UBOreTexturizer.lead_overlay, "tile.thermalfoundation.ore.lead");
+            }
+        }
+        {
+            // Thaumcraft
+            Block thaumcraftOreBlock = Block.getBlockFromName("Thaumcraft:blockCustomOre");
+            if (thaumcraftOreBlock != null) {
+                texturizer.requestUBOreSetup(thaumcraftOreBlock, 0, UBOreTexturizer.cinnabar_overlay, "tile.blockCustomOre.0");
+                texturizer.requestUBOreSetup(thaumcraftOreBlock, 7, UBOreTexturizer.amber_overlay, "tile.blockCustomOre.7");
+            }
+        }
+        {
+            //Mekanism
+            Block mekanismBlock = Block.getBlockFromName("Mekanism:OreBlock");
+            if (mekanismBlock != null) {
+                texturizer.requestUBOreSetup(mekanismBlock, 1, UBOreTexturizer.copper_overlay, "tile.OreBlock.CopperOre");
+                texturizer.requestUBOreSetup(mekanismBlock, 2, UBOreTexturizer.tin_overlay, "tile.OreBlock.TinOre");
+            }
+        }
+        {
+            //Project Red ProjRed|Exploration:projectred.exploration.ore
+            Block projectRedBlock = Block.getBlockFromName("ProjRed|Exploration:projectred.exploration.ore");
+
+            if (projectRedBlock == null) {
+                for (Object key: Block.blockRegistry.getKeys()) {
+                    String name = (String) key;
+                    Block named = Block.getBlockFromName(name);
+                    int id = Block.getIdFromBlock(named);
+                    logger.info(name + " "+id);
+                    if (name.contains("projectred.exploration.ore")) {
+                        projectRedBlock = named;
+                        break;
+                    }
+                }
+            }
+
+            if (projectRedBlock !=null) {
+                texturizer.requestUBOreSetup(projectRedBlock, 0, UBOreTexturizer.ruby_overlay, "tile.projectred.exploration.ore|0");
+                texturizer.requestUBOreSetup(projectRedBlock, 1, UBOreTexturizer.sapphire_overlay, "tile.projectred.exploration.ore|1");
+                texturizer.requestUBOreSetup(projectRedBlock, 2, UBOreTexturizer.olivine_peridot_overlay, "tile.projectred.exploration.ore|2");
+            }
+        }
+        {
+            //Biomes O' Plenty
+            Block bopOreBlock = Block.getBlockFromName("BiomesOPlenty:gemOre");
+            if (bopOreBlock !=null) {
+                texturizer.requestUBOreSetup(bopOreBlock, 2, UBOreTexturizer.ruby_overlay, "tile.gemOre.rubyore");
+                texturizer.requestUBOreSetup(bopOreBlock, 4, UBOreTexturizer.olivine_peridot_overlay, "tile.gemOre.peridotore");
+                texturizer.requestUBOreSetup(bopOreBlock, 6, UBOreTexturizer.olivine_peridot_overlay, "tile.gemOre.topazore");
+                texturizer.requestUBOreSetup(bopOreBlock, 8, UBOreTexturizer.olivine_peridot_overlay, "tile.gemOre.tanzaniteore");
+                texturizer.requestUBOreSetup(bopOreBlock, 10, UBOreTexturizer.emerald_overlay, "tile.gemOre.malachiteore");
+                texturizer.requestUBOreSetup(bopOreBlock, 12, UBOreTexturizer.sapphire_overlay, "tile.gemOre.sapphireore");
+                texturizer.requestUBOreSetup(bopOreBlock, 14, UBOreTexturizer.amber_overlay, "tile.gemOre.amberore");
+            }
+        }
+        {
+            //Enviromine
+            Block enviromineBlock = Block.getBlockFromName("enviromine:flammablecoal");
+            if (enviromineBlock != null) {
+                texturizer.requestUBOreSetup(enviromineBlock, UBOreTexturizer.coal_overlay);
+            }
+        }
+    }
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenBoulders.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenBoulders.java
new file mode 100644
index 0000000..0237ce9
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenBoulders.java
@@ -0,0 +1,70 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import exterminatorJeff.undergroundBiomes.api.BlockCodes;
+import exterminatorJeff.undergroundBiomes.api.UBAPIHook;
+import exterminatorJeff.undergroundBiomes.api.UBStrataColumn;
+import exterminatorJeff.undergroundBiomes.api.UBStrataColumnProvider;
+import net.minecraft.block.Block;
+import net.minecraft.block.BlockTallGrass;
+import net.minecraft.init.Blocks;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+import java.util.Random;
+
+public class WorldGenBoulders extends WorldGenerator
+{
+    /** Stores Block for WorldGenTallGrass */
+    private BlockTallGrass tallGrass;
+    private int tallGrassMetadata;
+
+
+    public WorldGenBoulders(BlockTallGrass tallgrass, int par2)
+    {
+        this.tallGrass = tallgrass;
+        this.tallGrassMetadata = par2;
+    }
+
+    public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)
+    {
+
+        for (boolean var6 = false; (par1World.getBlock(par3, par4, par5) == Blocks.leaves || par1World.isAirBlock(par3, par4, par5) ) && par4 > 0; --par4)
+        {
+            ;
+        }
+            int dimension = par1World.provider.dimensionId;
+            UBStrataColumnProvider columnProvider =
+                    UBAPIHook.ubAPIHook.dimensionalStrataColumnProvider.ubStrataColumnProvider(dimension);
+                    BlockCodes cobble = columnProvider.strataColumn(par3, par5).cobblestone(par4);
+        for (int var7 = 0; var7 < 128; ++var7)
+        {
+            int var8 = par3 + par2Random.nextInt(8) - par2Random.nextInt(8);
+            int var9 = par4 + par2Random.nextInt(4) - par2Random.nextInt(4);
+            int var10 = par5 + par2Random.nextInt(8) - par2Random.nextInt(8);
+
+
+            int columnX = Integer.MAX_VALUE;
+            int columnZ = Integer.MAX_VALUE;
+            BlockCodes mossyCobblestone = new BlockCodes(Blocks.mossy_cobblestone,0);
+            if (par1World.isAirBlock(var8, var9, var10) && this.tallGrass.canBlockStay(par1World, var8, var9, var10))
+            {
+                if(par2Random.nextInt(2) == 0){
+                    par1World.setBlock(var8, var9, var10, this.tallGrass, this.tallGrassMetadata, 2);
+                }
+                else{
+                    setBlockCodes(par1World,var8, var9, var10, (
+                            par2Random.nextInt(8) == 0 ? mossyCobblestone:cobble));
+                }
+            }
+        }
+
+        return true;
+
+
+    }
+
+    private void setBlockCodes(World world, int x, int y, int z, BlockCodes blockCodes) {
+        world.setBlock(x, y, z, blockCodes.block, blockCodes.metadata, 2);
+    }
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenUBMountain.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenUBMountain.java
new file mode 100644
index 0000000..d11e800
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenUBMountain.java
@@ -0,0 +1,98 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import exterminatorJeff.undergroundBiomes.api.BlockCodes;
+import exterminatorJeff.undergroundBiomes.api.UBAPIHook;
+import exterminatorJeff.undergroundBiomes.api.UBStrataColumn;
+import exterminatorJeff.undergroundBiomes.api.UBStrataColumnProvider;
+import highlands.worldgen.WorldGenMountain;
+import java.util.Random;
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class WorldGenUBMountain extends WorldGenerator
+{
+
+    private int minHeight;
+    private int maxHeight;
+
+    private int snowrocksand;
+    private boolean notifyFlag;
+
+    private World worldObj;
+    private Random random;
+
+    /** Constructor
+     * @param minH minimum height of tree trunk
+     * @param maxH max possible height above minH
+     * @param notify whether or not to notify blocks of the change
+     *  Generally false for world generation.
+     */
+    public WorldGenUBMountain(int minH, int maxH, boolean notify, int type)
+    {
+        this.minHeight = minH;
+        this.maxHeight = maxH;
+        this.notifyFlag = notify;
+        this.snowrocksand = type;
+    }
+
+    //public boolean generate(World world, Random random, int locX, int locY, int locZ)
+    //{
+    //	return true;
+    //}
+    public boolean generate(World world, Random random, int locX, int locY, int locZ)
+    {
+    	this.worldObj = world;
+    	this.random = random;
+
+    	int height = minHeight + random.nextInt(maxHeight);
+    	int radius = height;
+        BlockCodes snowBlock = new BlockCodes(Blocks.snow,0);
+        BlockCodes sandstoneBlock = new BlockCodes(Blocks.sandstone,0);
+    	//System.out.println("H:"+height+" X:"+locX+" Z:"+locZ);
+        UBStrataColumnProvider columnProvider =
+                    UBAPIHook.ubAPIHook.dimensionalStrataColumnProvider
+                    .ubStrataColumnProvider(world.provider.dimensionId);
+
+    	for(int x = (int)Math.ceil(locX - radius); x <= (int)Math.ceil(locX + radius); x++){
+			for(int z = (int)Math.ceil(locZ - radius); z <= (int)Math.ceil(locZ + radius); z++){
+				double xfr = z - locZ;
+				double zfr = x - locX;
+                UBStrataColumn column = columnProvider.strataColumn(x,z);
+				int dist = (int)Math.sqrt(xfr * xfr + zfr * zfr);
+
+				if(dist <= radius){
+					//overwrites trees rather than placing the mountain on top of them.
+					for(locY = world.getTopSolidOrLiquidBlock(x, z); locY > 0; locY--){
+						Block block = world.getBlock(x,  locY, z);
+						if(block != null && block.isOpaqueCube() && !block.isWood(world, x, locY, z) && !block.isLeaves(world, x, locY, z))break;
+					}
+
+					int h = locY + height - dist;
+					for(int i = locY; i < h; i++){
+						if(snowrocksand == 0 && h-i <4)setBlockInWorld(x, i, z, snowBlock);
+						else if(snowrocksand == 2 && h-i <4)setBlockInWorld(x, i, z, sandstoneBlock);
+						else if(random.nextInt(3)== 0) setBlockInWorld(x, i, z, column.cobblestone(i));
+						else setBlockInWorld(x, i, z,column.stone(i));
+					}
+					if(snowrocksand == 0 && h > 62)
+						setBlockInWorld(x, h, z, snowBlock);
+				}
+			}
+		}
+    	this.worldObj = null;
+    	return true;
+    }
+
+    private void setBlockInWorld(int x, int y, int z, BlockCodes blockCodes){
+			if(notifyFlag) worldObj.setBlock(x, y, z, blockCodes.block, blockCodes.metadata, 3);
+		    else worldObj.setBlock(x, y, z, blockCodes.block, blockCodes.metadata, 2);
+    }
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenUndergroundUB.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenUndergroundUB.java
new file mode 100644
index 0000000..7b1c621
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/intermod/WorldGenUndergroundUB.java
@@ -0,0 +1,98 @@
+
+package exterminatorJeff.undergroundBiomes.intermod;
+
+import exterminatorJeff.undergroundBiomes.api.BlockCodes;
+import exterminatorJeff.undergroundBiomes.api.UBAPIHook;
+import exterminatorJeff.undergroundBiomes.api.UBStrataColumnProvider;
+import java.util.Random;
+
+import net.minecraft.block.Block;
+import net.minecraft.init.Blocks;
+import net.minecraft.util.MathHelper;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+public class WorldGenUndergroundUB extends WorldGenerator
+{
+    /** The block ID of the ore to be placed using this generator. */
+    private Block minableBlockId;
+    private int minableBlockMeta = 0;
+
+    /** The number of blocks to generate. */
+    private int numberOfBlocks;
+
+    private Block IDtoReplace;
+
+    public WorldGenUndergroundUB(Block dirt, int par2, Block sand)
+    {
+        this.minableBlockId = dirt;
+        this.numberOfBlocks = par2;
+        this.IDtoReplace = sand;
+    }
+
+    public boolean generate(World par1World, Random par2Random, int par3, int par4, int par5)
+    {
+        float var6 = par2Random.nextFloat() * (float)Math.PI;
+        double var7 = (double)((float)(par3 + 8) + MathHelper.sin(var6) * (float)this.numberOfBlocks / 8.0F);
+        double var9 = (double)((float)(par3 + 8) - MathHelper.sin(var6) * (float)this.numberOfBlocks / 8.0F);
+        double var11 = (double)((float)(par5 + 8) + MathHelper.cos(var6) * (float)this.numberOfBlocks / 8.0F);
+        double var13 = (double)((float)(par5 + 8) - MathHelper.cos(var6) * (float)this.numberOfBlocks / 8.0F);
+        double var15 = (double)(par4 + par2Random.nextInt(3) - 2);
+        double var17 = (double)(par4 + par2Random.nextInt(3) - 2);
+
+        int dimension = par1World.provider.dimensionId;
+        UBStrataColumnProvider columnProvider =
+                UBAPIHook.ubAPIHook.dimensionalStrataColumnProvider.ubStrataColumnProvider(dimension);
+                //BlockCodes blockCodes = columnProvider.strataColumn(var38, var44).stone(var41);
+                BlockCodes blockCodes = columnProvider.strataColumn(par3, par5).stone(par4);
+        for (int var19 = 0; var19 <= this.numberOfBlocks; ++var19)
+        {
+            double var20 = var7 + (var9 - var7) * (double)var19 / (double)this.numberOfBlocks;
+            double var22 = var15 + (var17 - var15) * (double)var19 / (double)this.numberOfBlocks;
+            double var24 = var11 + (var13 - var11) * (double)var19 / (double)this.numberOfBlocks;
+            double var26 = par2Random.nextDouble() * (double)this.numberOfBlocks / 16.0D;
+            double var28 = (double)(MathHelper.sin((float)var19 * (float)Math.PI / (float)this.numberOfBlocks) + 1.0F) * var26 + 1.0D;
+            double var30 = (double)(MathHelper.sin((float)var19 * (float)Math.PI / (float)this.numberOfBlocks) + 1.0F) * var26 + 1.0D;
+            int var32 = MathHelper.floor_double(var20 - var28 / 2.0D);
+            int var33 = MathHelper.floor_double(var22 - var30 / 2.0D);
+            int var34 = MathHelper.floor_double(var24 - var28 / 2.0D);
+            int var35 = MathHelper.floor_double(var20 + var28 / 2.0D);
+            int var36 = MathHelper.floor_double(var22 + var30 / 2.0D);
+            int var37 = MathHelper.floor_double(var24 + var28 / 2.0D);
+
+            for (int var38 = var32; var38 <= var35; ++var38)
+            {
+                double var39 = ((double)var38 + 0.5D - var20) / (var28 / 2.0D);
+
+                if (var39 * var39 < 1.0D)
+                {
+                    for (int var41 = var33; var41 <= var36; ++var41)
+                    {
+                        double var42 = ((double)var41 + 0.5D - var22) / (var30 / 2.0D);
+
+                        if (var39 * var39 + var42 * var42 < 1.0D)
+                        {
+                            for (int var44 = var34; var44 <= var37; ++var44)
+                            {
+                                double var45 = ((double)var44 + 0.5D - var24) / (var28 / 2.0D);
+
+                                Block block = par1World.getBlock(var38, var41, var44);
+                                if (var39 * var39 + var42 * var42 + var45 * var45 < 1.0D && (block != null && (block == IDtoReplace ||
+                                		(IDtoReplace == Blocks.dirt && block == Blocks.grass))))
+                                {
+                                	if(par1World.isAirBlock(var38, var41+1, var44) && minableBlockId == Blocks.dirt)
+                                		par1World.setBlock(var38, var41, var44, Blocks.grass, minableBlockMeta, 3);
+                                	else {
+                                        par1World.setBlock(var38, var41, var44, blockCodes.block, blockCodes.metadata, 3);
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+}
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeGenStrataLayers.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeGenStrataLayers.java
index 89ebcf2..ef6f44f 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeGenStrataLayers.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeGenStrataLayers.java
@@ -1,15 +1,19 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.StrataLayer;
 import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 import exterminatorJeff.undergroundBiomes.api.UBIDs;
 import exterminatorJeff.undergroundBiomes.api.NamedBlock;
 import exterminatorJeff.undergroundBiomes.api.NamedVanillaBlock;
+import exterminatorJeff.undergroundBiomes.api.UndergroundBiomesSettings;
+import java.util.ArrayList;
 
 
 
 public class BiomeGenStrataLayers {
     
     public StrataLayer[][] layers;
+    private final UndergroundBiomesSettings settings;
     
     /*Sedimentary rock IDs:
      * 0 - limestone
@@ -26,8 +30,9 @@ public class BiomeGenStrataLayers {
      * 2 - marble
      */
     
-    public BiomeGenStrataLayers(){
+    public BiomeGenStrataLayers(UndergroundBiomesSettings settings){
         layers = new StrataLayer[30][];
+        this.settings = settings;
         if (UndergroundBiomes.harmoniousStrata()) {
             createHarmoniousLayers();
         } else {
@@ -39,20 +44,20 @@ public class BiomeGenStrataLayers {
         NamedBlock sedimentaryBlockID = UBIDs.sedimentaryStoneName;
         NamedBlock metamorphicBlockID = UBIDs.metamorphicStoneName;
         NamedBlock igneousBlockID = UBIDs.igneousStoneName;
-        layers[0] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 0, 30, 32), new StrataLayer(sedimentaryBlockID, 1, 38, 41), new StrataLayer(sedimentaryBlockID, 6, 65, 70)};
-        layers[1] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 33, 36), new StrataLayer(sedimentaryBlockID, 1, 38, 41), new StrataLayer(sedimentaryBlockID, 5, 60, 62), new StrataLayer(sedimentaryBlockID, 7, 75, 80)};
-        layers[2] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 3, 30, 35), new StrataLayer(sedimentaryBlockID, 4, 26, 29), new StrataLayer(metamorphicBlockID, 2, 70, 74)};
-        layers[3] = new StrataLayer[]{new StrataLayer(NamedVanillaBlock.sandstone, 0, 40, 43), new StrataLayer(NamedVanillaBlock.sand, 0, 44, 47), new StrataLayer(sedimentaryBlockID, 1, 55, 57)};
-        layers[4] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 7, 29, 33), new StrataLayer(sedimentaryBlockID, 5, 42, 44), new StrataLayer(sedimentaryBlockID, 4, 90, 105)};
-        layers[5] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 33, 35), new StrataLayer(sedimentaryBlockID, 3, 38, 41), new StrataLayer(sedimentaryBlockID, 6, 72, 79)};
-        layers[6] = new StrataLayer[]{new StrataLayer(metamorphicBlockID, 2, 30, 35), new StrataLayer(sedimentaryBlockID, 0, 39, 44), new StrataLayer(NamedVanillaBlock.sandstone, 0, 52, 54), new StrataLayer(NamedVanillaBlock.sand, 0, 55, 60)};
-        layers[7] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 0, 33, 35), new StrataLayer(sedimentaryBlockID, 3, 45, 49), new StrataLayer(sedimentaryBlockID, 6, 80, 85)};
-        layers[8] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 1, 30, 32), new StrataLayer(metamorphicBlockID, 2, 70, 74), new StrataLayer(sedimentaryBlockID, 4, 75, 79)};
-        layers[9] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 31, 35), new StrataLayer(sedimentaryBlockID, 5, 39, 42), new StrataLayer(sedimentaryBlockID, 7, 62, 65)};
+        layers[0] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 0, 30, 32), new StrataLayer(sedimentaryBlockID, 1, 38, 41), new StrataLayer(sedimentaryBlockID, 6, 65, 70)});
+        layers[1] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 33, 36), new StrataLayer(sedimentaryBlockID, 1, 38, 41), new StrataLayer(sedimentaryBlockID, 5, 60, 62), new StrataLayer(sedimentaryBlockID, 7, 75, 80)});
+        layers[2] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 3, 30, 35), new StrataLayer(sedimentaryBlockID, 4, 26, 29), new StrataLayer(metamorphicBlockID, 2, 70, 74)});
+        layers[3] = generatable(new StrataLayer[]{new StrataLayer(NamedVanillaBlock.sandstone, 0, 40, 43), new StrataLayer(NamedVanillaBlock.sand, 0, 44, 47), new StrataLayer(sedimentaryBlockID, 1, 55, 57)});
+        layers[4] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 7, 29, 33), new StrataLayer(sedimentaryBlockID, 5, 42, 44), new StrataLayer(sedimentaryBlockID, 4, 90, 105)});
+        layers[5] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 33, 35), new StrataLayer(sedimentaryBlockID, 3, 38, 41), new StrataLayer(sedimentaryBlockID, 6, 72, 79)});
+        layers[6] = generatable(new StrataLayer[]{new StrataLayer(metamorphicBlockID, 2, 30, 35), new StrataLayer(sedimentaryBlockID, 0, 39, 44), new StrataLayer(NamedVanillaBlock.sandstone, 0, 52, 54), new StrataLayer(NamedVanillaBlock.sand, 0, 55, 60)});
+        layers[7] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 0, 33, 35), new StrataLayer(sedimentaryBlockID, 3, 45, 49), new StrataLayer(sedimentaryBlockID, 6, 80, 85)});
+        layers[8] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 1, 30, 32), new StrataLayer(metamorphicBlockID, 2, 70, 74), new StrataLayer(sedimentaryBlockID, 4, 75, 79)});
+        layers[9] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 31, 35), new StrataLayer(sedimentaryBlockID, 5, 39, 42), new StrataLayer(sedimentaryBlockID, 7, 62, 65)});
         
         //Layers for vanilla stone biomes
-        layers[10] = new StrataLayer[]{new StrataLayer(igneousBlockID, 2, 12, 18), new StrataLayer(igneousBlockID, 6, 24, 29), new StrataLayer(metamorphicBlockID, 2, 80, 85)};
-        layers[11] = new StrataLayer[]{new StrataLayer(igneousBlockID, 5, 13, 22), new StrataLayer(metamorphicBlockID, 6, 29, 36), new StrataLayer(metamorphicBlockID, 3, 80, 128)};
+        layers[10] = generatable(new StrataLayer[]{new StrataLayer(igneousBlockID, 2, 12, 18), new StrataLayer(igneousBlockID, 6, 24, 29), new StrataLayer(metamorphicBlockID, 2, 80, 85)});
+        layers[11] = generatable(new StrataLayer[]{new StrataLayer(igneousBlockID, 5, 13, 22), new StrataLayer(metamorphicBlockID, 6, 29, 36), new StrataLayer(metamorphicBlockID, 3, 80, 128)});
         
     }
 
@@ -60,21 +65,31 @@ public class BiomeGenStrataLayers {
         NamedBlock sedimentaryBlockID = UBIDs.sedimentaryStoneName;
         NamedBlock metamorphicBlockID = UBIDs.metamorphicStoneName;
         NamedBlock igneousBlockID = UBIDs.igneousStoneName;
-        layers[0] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 0, 30, 32), new StrataLayer(sedimentaryBlockID, 1, 38, 41), new StrataLayer(sedimentaryBlockID, 6, 65, 70)};
-        layers[5] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 33, 36), new StrataLayer(sedimentaryBlockID, 1, 38, 41), new StrataLayer(sedimentaryBlockID, 5, 60, 62), new StrataLayer(sedimentaryBlockID, 7, 75, 80)};
-        layers[2] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 3, 30, 35), new StrataLayer(sedimentaryBlockID, 4, 26, 29), new StrataLayer(metamorphicBlockID, 2, 70, 74)};
-        layers[3] = new StrataLayer[]{new StrataLayer(NamedVanillaBlock.sandstone, 0, 40, 43), new StrataLayer(NamedVanillaBlock.sand, 0, 44, 47), new StrataLayer(sedimentaryBlockID, 1, 55, 57)};
-        layers[4] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 7, 29, 33), new StrataLayer(sedimentaryBlockID, 5, 42, 44), new StrataLayer(sedimentaryBlockID, 4, 90, 105)};
-        layers[1] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 33, 35), new StrataLayer(sedimentaryBlockID, 3, 38, 41), new StrataLayer(sedimentaryBlockID, 6, 72, 79)};
-        layers[6] = new StrataLayer[]{new StrataLayer(metamorphicBlockID, 2, 30, 35), new StrataLayer(sedimentaryBlockID, 0, 39, 44), new StrataLayer(NamedVanillaBlock.sandstone, 0, 52, 54), new StrataLayer(NamedVanillaBlock.sand, 0, 55, 60)};
-        layers[7] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 0, 33, 35), new StrataLayer(sedimentaryBlockID, 3, 45, 49), new StrataLayer(sedimentaryBlockID, 4, 80, 85)};
-        layers[8] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 1, 30, 32), new StrataLayer(metamorphicBlockID, 2, 70, 74), new StrataLayer(sedimentaryBlockID, 6, 75, 79)};
-        layers[9] = new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 31, 35), new StrataLayer(sedimentaryBlockID, 5, 39, 42), new StrataLayer(sedimentaryBlockID, 7, 62, 65)};
+        layers[0] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 0, 30, 32), new StrataLayer(sedimentaryBlockID, 1, 38, 41), new StrataLayer(sedimentaryBlockID, 6, 65, 70)});
+        layers[5] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 33, 36), new StrataLayer(sedimentaryBlockID, 1, 38, 41), new StrataLayer(sedimentaryBlockID, 5, 60, 62), new StrataLayer(sedimentaryBlockID, 7, 75, 80)});
+        layers[2] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 3, 30, 35), new StrataLayer(sedimentaryBlockID, 4, 26, 29), new StrataLayer(metamorphicBlockID, 2, 70, 74)});
+        layers[3] = generatable(new StrataLayer[]{new StrataLayer(NamedVanillaBlock.sandstone, 0, 40, 43), new StrataLayer(NamedVanillaBlock.sand, 0, 44, 47), new StrataLayer(sedimentaryBlockID, 1, 55, 57)});
+        layers[4] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 7, 29, 33), new StrataLayer(sedimentaryBlockID, 5, 42, 44), new StrataLayer(sedimentaryBlockID, 4, 90, 105)});
+        layers[1] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 33, 35), new StrataLayer(sedimentaryBlockID, 3, 38, 41), new StrataLayer(sedimentaryBlockID, 6, 72, 79)});
+        layers[6] = generatable(new StrataLayer[]{new StrataLayer(metamorphicBlockID, 2, 30, 35), new StrataLayer(sedimentaryBlockID, 0, 39, 44), new StrataLayer(NamedVanillaBlock.sandstone, 0, 52, 54), new StrataLayer(NamedVanillaBlock.sand, 0, 55, 60)});
+        layers[7] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 0, 33, 35), new StrataLayer(sedimentaryBlockID, 3, 45, 49), new StrataLayer(sedimentaryBlockID, 4, 80, 85)});
+        layers[8] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 1, 30, 32), new StrataLayer(metamorphicBlockID, 2, 70, 74), new StrataLayer(sedimentaryBlockID, 6, 75, 79)});
+        layers[9] = generatable(new StrataLayer[]{new StrataLayer(sedimentaryBlockID, 2, 31, 35), new StrataLayer(sedimentaryBlockID, 5, 39, 42), new StrataLayer(sedimentaryBlockID, 7, 62, 65)});
 
         //Layers for vanilla stone biomes
-        layers[10] = new StrataLayer[]{new StrataLayer(igneousBlockID, 2, 12, 18), new StrataLayer(igneousBlockID, 6, 24, 29), new StrataLayer(metamorphicBlockID, 2, 80, 85)};
-        layers[11] = new StrataLayer[]{new StrataLayer(igneousBlockID, 5, 13, 22), new StrataLayer(metamorphicBlockID, 6, 29, 36), new StrataLayer(metamorphicBlockID, 3, 80, 128)};
+        layers[10] = generatable(new StrataLayer[]{new StrataLayer(igneousBlockID, 2, 12, 18), new StrataLayer(igneousBlockID, 6, 24, 29), new StrataLayer(metamorphicBlockID, 2, 80, 85)});
+        layers[11] = generatable(new StrataLayer[]{new StrataLayer(igneousBlockID, 5, 13, 22), new StrataLayer(metamorphicBlockID, 6, 29, 36), new StrataLayer(metamorphicBlockID, 3, 80, 128)});
 
     }
 
+    public StrataLayer [] generatable(StrataLayer[] possible) {
+        ArrayList<StrataLayer> accepted = new ArrayList<StrataLayer>();
+        for (int i = 0; i < possible.length; i++) {
+            NamedBlock block = possible[i].layerBlock;
+            int metadata = possible[i].layerMetadataID;
+            if (settings.generationAllowed(block, metadata)) accepted.add(possible[i]);
+        }
+        StrataLayer[] result = new StrataLayer[accepted.size()];
+        return accepted.toArray(result);
+    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeGenUndergroundBase.java E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeGenUndergroundBase.java
deleted file mode 100644
index 658f330..0000000
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeGenUndergroundBase.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package exterminatorJeff.undergroundBiomes.worldGen;
-
-import exterminatorJeff.undergroundBiomes.common.PerlinNoiseGenerator;
-import exterminatorJeff.undergroundBiomes.api.NamedBlock;
-
-public class BiomeGenUndergroundBase {
-	
-	public String biomeName;
-	
-	public final int biomeID;
-	
-	public boolean hasStrata = false;
-	
-	public StrataLayer[] strata;
-	
-	public final PerlinNoiseGenerator strataNoise;
-	
-	public final UBStoneCodes fillerBlockCodes;
-	
-	protected BiomeGenUndergroundBase(int ID, NamedBlock filler, int metadataValue, BiomeGenUndergroundBase[] biomeList) {
-		this.biomeID = ID;
-		this.fillerBlockCodes = new UBStoneCodes(filler, metadataValue);
-		strataNoise = new PerlinNoiseGenerator(1);
-		biomeList[ID] = this;
-	}
-	
-	protected BiomeGenUndergroundBase AddStrataLayers(StrataLayer[] parStrata) {
-		hasStrata = true;
-		this.strata = parStrata;
-		return this;
-	}
-	
-	public UBStoneCodes getStrataBlockAtLayer(int y) {
-		for (int i = 0; i < strata.length; i++) {
-			if (strata[i].valueIsInLayer(y) == true) {
-				return strata[i].codes;
-			}
-		}
-		return fillerBlockCodes;
-	}
-	
-	protected BiomeGenUndergroundBase setName(String name) {
-		this.biomeName = name;
-		return this;
-	}
-}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeUndergroundCacheBlock.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeUndergroundCacheBlock.java
index c83d218..5fda0a7 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeUndergroundCacheBlock.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeUndergroundCacheBlock.java
@@ -1,5 +1,6 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.BiomeGenUndergroundBase;
 import exterminatorJeff.undergroundBiomes.common.UBiomeCache;
 
 public class BiomeUndergroundCacheBlock {
@@ -25,7 +26,7 @@ public class BiomeUndergroundCacheBlock {
         this.biomes = new BiomeGenUndergroundBase[256];
         this.xPosition = par2;
         this.zPosition = par3;
-        theBiomeCache.worldGen.getUndergroundBiomeGenAt(this.biomes, par2 << 4, par3 << 4, 16, 16, false);
+        theBiomeCache.worldGen.cacheUndergroundBiomeGenAt(this.biomes, par2, par3, 16, 16);
     }
 
     /**
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeUndergroundDecorator.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeUndergroundDecorator.java
index afc4fdf..1916e58 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeUndergroundDecorator.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/BiomeUndergroundDecorator.java
@@ -1,5 +1,8 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.UBStoneCodes;
+import exterminatorJeff.undergroundBiomes.api.BiomeGenUndergroundBase;
+import Zeno410Utils.Accessor;
 import Zeno410Utils.BlockLocation;
 import Zeno410Utils.BlockLocationProbe;
 import Zeno410Utils.BlockState;
@@ -19,11 +22,21 @@ import exterminatorJeff.undergroundBiomes.common.WorldGenManager;
 
 import exterminatorJeff.undergroundBiomes.api.NamedVanillaBlock;
 import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
+import exterminatorJeff.undergroundBiomes.intermod.BiomeGenUBBadlands;
+import exterminatorJeff.undergroundBiomes.intermod.BiomeGenUBCliffs;
+import exterminatorJeff.undergroundBiomes.intermod.BiomeGenUBDesertMountains;
+import exterminatorJeff.undergroundBiomes.intermod.BiomeGenUBRockMountains;
+import highlands.biome.BiomeDecoratorHighlands;
+import highlands.biome.BiomeGenBadlands;
+import highlands.biome.BiomeGenCliffs;
+import highlands.biome.BiomeGenDesertMountains;
+import highlands.biome.BiomeGenRockMountains;
 import java.util.ArrayList;
 import java.util.logging.Logger;
 import net.minecraft.world.biome.BiomeDecorator;
 import net.minecraft.world.chunk.IChunkProvider;
 import net.minecraft.world.chunk.storage.ExtendedBlockStorage;
+import biomesoplenty.api.biome.BOPInheritedBiome;
 
 public class BiomeUndergroundDecorator {
 
@@ -69,7 +82,7 @@ public class BiomeUndergroundDecorator {
     public BiomeUndergroundDecorator(WorldGenManager worldGen,OreUBifier oreUBifier) {
         this.worldGen = worldGen;
         this.oreUBifier = oreUBifier;
-        //arrangeHighlandsCompatibility();
+        arrangeHighlandsCompatibility();
         setupCorrectors();
         correctBiomeDecorators();
     }
@@ -79,7 +92,7 @@ public class BiomeUndergroundDecorator {
     }
 
     public void replaceBlocksForUndergroundBiome(int par_x, int par_z, World currentWorld) {
-        if (worldGen.ubOn() == false) return;
+        if (worldGen.ubOn() == false ) return;
         this.eraseBogusCurrentWorlds();
         BlockLocation chunkLocation = new BlockLocation(par_x,par_z, currentWorld.provider.dimensionId);
         // abort if this chunk is already being generated
@@ -101,15 +114,16 @@ public class BiomeUndergroundDecorator {
                 UBStoneCodes defaultColumnStone = currentBiome.fillerBlockCodes;
 
                 Chunk chunk = currentWorld.getChunkFromBlockCoords(x, z);
-                ExtendedBlockStorage[] ebsa = chunk.getBlockStorageArray();
+                ExtendedBlockStorage[] ebsArray = chunk.getBlockStorageArray();
                 ExtendedBlockStorage ebs = null;
 
                 for(int y = 1; y < generationHeight; y++) {
-                    ebs = ebsa[y >> 4];
-                    UBStoneCodes strata = currentBiome.getStrataBlockAtLayer(y + variation);
-                    Block currentBlock = currentWorld.getBlock(x, y, z);
+                    ebs = ebsArray[y >> 4];
+                    if (ebs == null) continue;
+                    Block currentBlock = ebs.getBlockByExtId(x & 15, y & 15, z & 15);
 
                     if(NamedVanillaBlock.stone.matches(currentBlock)){
+                        UBStoneCodes strata = currentBiome.getStrataBlockAtLayer(y + variation);
                         ebs.func_150818_a(x & 15, y & 15, z & 15, strata.block);
                         ebs.setExtBlockMetadata(x & 15, y & 15, z & 15, strata.metadata);
                         chunk.isModified = true;
@@ -148,6 +161,7 @@ public class BiomeUndergroundDecorator {
     public void replaceOresForUndergroundBiome(int par_x, int par_z, World currentWorld) {
         // currently not used
         if (worldGen.ubOn() == false ) return;
+        if (this.oreUBifier.replacementActive()==false) return;
         BlockLocation chunkLocation = new BlockLocation(par_x,par_z, currentWorld.provider.dimensionId);
         // abort if this chunk is already being generated
         if (this.beingGenerated.contains(chunkLocation)) return;
@@ -155,8 +169,6 @@ public class BiomeUndergroundDecorator {
         int generationHeight = UndergroundBiomes.generateHeight();
         BiomeGenUndergroundBase[] undergroundBiomesForGeneration= new BiomeGenUndergroundBase[256];
         undergroundBiomesForGeneration = worldGen.loadUndergroundBlockGeneratorData(undergroundBiomesForGeneration, par_x, par_z, 16, 16);
-
-        //logger.info("redo ores chunk "+par_x+ " " + par_z);
         for(int x = par_x; x < par_x + 16; x++)
         {
             for(int z = par_z; z < par_z + 16; z++)
@@ -209,7 +221,7 @@ public class BiomeUndergroundDecorator {
         BlockLocation chunkLocation = new BlockLocation(par_x,par_z, currentWorld.provider.dimensionId);
         // abort if this chunk is already being generated
         if (this.beingGenerated.contains(chunkLocation)) {
-            //if (UndergroundBiomes.crashOnProblems()) throw new RuntimeException();
+            if (UndergroundBiomes.crashOnProblems()) throw new RuntimeException();
         }
         CurrentWorldMemento memento = this.currentWorldManager.memento();
         beingGenerated.add(chunkLocation);
@@ -378,13 +390,13 @@ public class BiomeUndergroundDecorator {
         for (int i = 0 ;i < biomes.length; i++) {
             BiomeGenBase biome = biomes[i];
             if (biome != null) {
-                // logger.info(biome.biomeName + " " + biome.toString());
+                logger.info(biome.biomeName + " " + biome.toString());
                 BiomeDecorator currentDecorator = biome.theBiomeDecorator;
                 for (BiomeDecoratorCorrector corrector: this.correctors) {
                     BiomeDecorator newDecorator = corrector.corrected(biome,currentDecorator);
                     if (newDecorator != currentDecorator) {
                         // the corrector wants a change
-                        // logger.info("changing");
+                        logger.info("changing");
                         biome.theBiomeDecorator = newDecorator;
                         // we're done
                         break;
@@ -396,26 +408,41 @@ public class BiomeUndergroundDecorator {
 
     private void setupCorrectors() {
         this.correctors.add(new VanillaDecoratorCorrector());
-        /*try {
+        try {
             this.correctors.add(new HighlandsDecoratorCorrector());
         } catch (java.lang.NoClassDefFoundError e) {
             // no Highlands; nothing to do;
-        }*/
+        }
+        try {
+            this.correctors.add(new BoPDecoratorCorrector());
+        } catch (java.lang.NoClassDefFoundError e) {
+            // no BoP; nothing to do;
+        }
 
     }
 
     private class VanillaDecoratorCorrector implements BiomeDecoratorCorrector {
         Class standardDecoratorClass = BiomeDecorator.class;
 
-        @Override
-		public BiomeDecorator corrected(BiomeGenBase biome, BiomeDecorator currentDecorator) {
+        public BiomeDecorator corrected(BiomeGenBase biome, BiomeDecorator currentDecorator) {
             if ((currentDecorator.getClass().equals(standardDecoratorClass))) {
                 return new CorrectedBiomeDecorator(currentDecorator);
             }
             return currentDecorator;
         }
     }
-/*
+
+    private class BoPDecoratorCorrector implements BiomeDecoratorCorrector {
+        Class standardDecoratorClass = BiomeDecorator.class;
+
+        public BiomeDecorator corrected(BiomeGenBase biome, BiomeDecorator currentDecorator) {
+            if ((currentDecorator.getClass().getName().contains("BoP"))&&!(currentDecorator instanceof CorrectedBiomeDecorator))  {
+                return new CorrectedBiomeDecorator(currentDecorator);
+            }
+            return currentDecorator;
+        }
+    }
+
     private class HighlandsDecoratorCorrector implements BiomeDecoratorCorrector {
         Class standardDecoratorClass = BiomeDecoratorHighlands.class;
 
@@ -453,7 +480,7 @@ public class BiomeUndergroundDecorator {
         } catch (java.lang.NoClassDefFoundError e) {
         }
 
-    }*/
+    }
 }
 
 
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/ChunkProviderWrapper.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/ChunkProviderWrapper.java
index 7ad07c5..8f84bcf 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/ChunkProviderWrapper.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/ChunkProviderWrapper.java
@@ -1,6 +1,10 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import Zeno410Utils.PlaneLocation;
+import Zeno410Utils.Zeno410Logger;
 import java.util.List;
+import java.util.WeakHashMap;
+import java.util.logging.Logger;
 import net.minecraft.entity.EnumCreatureType;
 import net.minecraft.util.IProgressUpdate;
 import net.minecraft.world.chunk.Chunk;
@@ -11,38 +15,54 @@ import net.minecraft.world.World;
 public class ChunkProviderWrapper implements IChunkProvider {
     private IChunkProvider wrappee;
     private final CurrentWorldMemento.Manager currentWorldManager = new CurrentWorldMemento.Manager();
+    private WeakHashMap<PlaneLocation,Chunk> providedChunks = new WeakHashMap<PlaneLocation,Chunk>();
+    public static Logger logger = new Zeno410Logger("ChunkProviderWrapper").logger();
     public ChunkProviderWrapper(IChunkProvider toWrap) {
         wrappee = toWrap;
     }
+
+    public IChunkProvider wrappee() {return wrappee;}
     /**
      * Checks to see if a chunk exists at x, y
      */
-    @Override
-	public boolean chunkExists(int i, int j) {return wrappee.chunkExists(i,j);}
+    public boolean chunkExists(int i, int j) {return wrappee.chunkExists(i,j);}
 
     /**
      * Will return back a chunk, if it doesn't exist and its not a MP client it will generates all the blocks for the
      * specified chunk from the map seed and chunk seed
      */
-    @Override
-	public Chunk provideChunk(int i, int j) {
+    public Chunk provideChunk(int i, int j) {
+        /*PlaneLocation location = new PlaneLocation(i,j);
+        Chunk alreadyProvided = providedChunks.get(location);
+        if (alreadyProvided != null) {
+            throw new RuntimeException();
+            //return alreadyProvided;
+        }*/
         Chunk result = wrappee.provideChunk(i,j);
+        //providedChunks.put(location, result);
         return result;
     }
 
     /**
      * loads or generates the chunk at the chunk location specified
      */
-    @Override
-	public Chunk loadChunk(int i, int j) {
+    public Chunk loadChunk(int i, int j) {
         return wrappee.loadChunk(i,j);
+        /*PlaneLocation location = new PlaneLocation(i,j);
+        Chunk alreadyProvided = providedChunks.get(location);
+        if (alreadyProvided != null) {
+            //throw new RuntimeException();
+            return alreadyProvided;
+        }
+        Chunk result = wrappee.loadChunk(i,j);
+        //providedChunks.put(location, result);
+        return result;*/
     }
 
     /**
      * Populates chunk with ores etc etc
      */
-    @Override
-	public void populate(IChunkProvider ichunkprovider, int i, int j) {
+    public void populate(IChunkProvider ichunkprovider, int i, int j) {
 
         try {
             wrappee.populate(ichunkprovider,i,j);
@@ -62,63 +82,54 @@ public class ChunkProviderWrapper implements IChunkProvider {
      * Two modes of operation: if passed true, save all Chunks in one go.  If passed false, save up to two chunks.
      * Return true if all chunks have been saved.
      */
-    @Override
-	public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
+    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate) {
         return this.wrappee.saveChunks(flag, iprogressupdate);
     }
 
     /**
      * Unloads chunks that are marked to be unloaded. This is not guaranteed to unload every such chunk.
      */
-    @Override
-	public boolean unloadQueuedChunks(){
+    public boolean unloadQueuedChunks(){
         return wrappee.unloadQueuedChunks();
     }
 
     /**
      * Returns if the IChunkProvider supports saving.
      */
-    @Override
-	public boolean canSave() {
+    public boolean canSave() {
         return wrappee.canSave();
     }
 
     /**
      * Converts the instance data to a readable string.
      */
-    @Override
-	public String makeString() {
+    public String makeString() {
         return wrappee.makeString();
     }
 
     /**
      * Returns a list of creatures of the specified type that can spawn at the given location.
      */
-    @Override
-	public List getPossibleCreatures(EnumCreatureType enumcreaturetype, int i, int j, int k) {
+    public List getPossibleCreatures(EnumCreatureType enumcreaturetype, int i, int j, int k) {
         return wrappee.getPossibleCreatures(enumcreaturetype, i, j, k);
     }
 
     /**
      * Returns the location of the closest structure of the specified type. If not found returns null.
      */
-    @Override
-	public ChunkPosition func_147416_a(World world, String s, int i, int j, int k) {
+    public ChunkPosition func_147416_a(World world, String s, int i, int j, int k) {
         return wrappee.func_147416_a(world, s, i, j, k);
     }
 
-    @Override
-	public int getLoadedChunkCount() {
+    public int getLoadedChunkCount() {
         return this.wrappee.getLoadedChunkCount();
     }
 
-    @Override
-	public void recreateStructures(int i, int j){
+    public void recreateStructures(int i, int j){
         this.wrappee.recreateStructures(i, j);
     }
 
-    @Override
-	public void saveExtraData() {
+    public void saveExtraData() {
         this.wrappee.saveExtraData();
     }
 }
\ No newline at end of file
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CorrectedBiomeDecorator.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CorrectedBiomeDecorator.java
index 80f2e85..c1a0538 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CorrectedBiomeDecorator.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CorrectedBiomeDecorator.java
@@ -2,9 +2,11 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
 import java.util.Random;
+import net.minecraft.init.Blocks;
 import net.minecraft.world.World;
 import net.minecraft.world.biome.BiomeDecorator;
 import net.minecraft.world.biome.BiomeGenBase;
+import net.minecraft.world.gen.feature.WorldGenFlowers;
 
 /**
  *
@@ -44,13 +46,21 @@ public class CorrectedBiomeDecorator extends BiomeDecorator {
         this.treesPerChunk = toCorrect.treesPerChunk;
         this.waterlilyGen = toCorrect.waterlilyGen;
         this.waterlilyPerChunk = toCorrect.waterlilyPerChunk;
-        this.yellowFlowerGen = toCorrect.yellowFlowerGen;
+        if (toCorrect.yellowFlowerGen != null) {
+            this.yellowFlowerGen = toCorrect.yellowFlowerGen;
+        }
     }
     @Override
     public void decorateChunk(World p_150512_1_, Random p_150512_2_, BiomeGenBase p_150512_3_, int p_150512_4_, int p_150512_5_) {
         World wasDecorating = currentWorld;
         Random randomizer= this.randomGenerator;
         currentWorld = null;
+        if (this.yellowFlowerGen == null) {
+            this.yellowFlowerGen = new WorldGenFlowers(Blocks.yellow_flower);
+        }
+        if (super.yellowFlowerGen == null) {
+            super.yellowFlowerGen = new WorldGenFlowers(Blocks.yellow_flower);
+        }
         super.decorateChunk(p_150512_1_, p_150512_2_, p_150512_3_, p_150512_4_, p_150512_5_);
         currentWorld = wasDecorating;
         randomGenerator = randomizer;
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CorrectedBiomeDecoratorHighlands.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CorrectedBiomeDecoratorHighlands.java
new file mode 100644
index 0000000..0760709
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CorrectedBiomeDecoratorHighlands.java
@@ -0,0 +1,327 @@
+
+package exterminatorJeff.undergroundBiomes.worldGen;
+
+import Zeno410Utils.AccessInt;
+import Zeno410Utils.MethodAccessor;
+import highlands.biome.BiomeDecoratorHighlands;
+import java.util.Random;
+import net.minecraft.world.World;
+import net.minecraft.world.biome.BiomeDecorator;
+import net.minecraft.world.biome.BiomeGenBase;
+import net.minecraftforge.event.terraingen.TerrainGen;
+
+
+import java.util.Random;
+import net.minecraft.block.BlockFlower;
+import net.minecraft.block.material.Material;
+import net.minecraft.init.Blocks;
+import net.minecraft.world.World;
+import net.minecraft.world.gen.feature.WorldGenAbstractTree;
+import net.minecraft.world.gen.feature.WorldGenBigMushroom;
+import net.minecraft.world.gen.feature.WorldGenCactus;
+import net.minecraft.world.gen.feature.WorldGenClay;
+import net.minecraft.world.gen.feature.WorldGenDeadBush;
+import net.minecraft.world.gen.feature.WorldGenFlowers;
+import net.minecraft.world.gen.feature.WorldGenLiquids;
+import net.minecraft.world.gen.feature.WorldGenMinable;
+import net.minecraft.world.gen.feature.WorldGenPumpkin;
+import net.minecraft.world.gen.feature.WorldGenReed;
+import net.minecraft.world.gen.feature.WorldGenSand;
+import net.minecraft.world.gen.feature.WorldGenWaterlily;
+import net.minecraft.world.gen.feature.WorldGenerator;
+
+
+import net.minecraftforge.common.MinecraftForge;
+import net.minecraftforge.event.terraingen.DecorateBiomeEvent;
+import static net.minecraftforge.event.terraingen.DecorateBiomeEvent.Decorate.EventType.*;
+/**
+ *
+ * @author Zeno410
+ */
+public class CorrectedBiomeDecoratorHighlands extends BiomeDecoratorHighlands{
+    public static AccessInt<BiomeDecoratorHighlands> highlandsPl = new AccessInt("highlandsPlantsPerChunk");
+    private BiomeDecorator mcthis;
+    private MethodAccessor<BiomeDecorator> genOreAccess = new MethodAccessor<BiomeDecorator>("func_76797_b");
+    private static int trees(BiomeDecorator source) {
+        return source.treesPerChunk;
+    }
+    private static int grass(BiomeDecorator source) {
+        return source.grassPerChunk;
+    }
+
+    private static int flowers(BiomeDecorator source) {
+        return source.flowersPerChunk;
+    }
+
+    public CorrectedBiomeDecoratorHighlands(BiomeGenBase biome, BiomeDecoratorHighlands toCorrect) {
+        super(biome,trees(toCorrect),grass(toCorrect),flowers(toCorrect),
+                highlandsPl.get(toCorrect));
+        mcthis = this;
+    }
+
+    // Why the two different functions that do the same thing? The former one wouldn't be called anyway...
+    /* @Override
+    public void func_150512_a(World world, Random random, BiomeGenBase biome, int x, int z) {
+        World previous = ((BiomeDecorator)this).currentWorld;
+        Random randomizer = ((BiomeDecorator)this).randomGenerator;
+        ((BiomeDecorator)this).currentWorld  = null;
+        World targetWorld = (world == null) ? previous : world;
+        if (targetWorld == null) throw new RuntimeException();
+        if (random == null) throw new RuntimeException();
+        if (biome == null) throw new RuntimeException();
+        try {
+             super.decorateChunk(targetWorld, random, biome, x, z);
+        } catch (RuntimeException e) {
+            //((BiomeDecorator)this).currentWorld = targetWorld;
+              int j;
+               boolean doGen = TerrainGen.decorate(((BiomeDecorator)this).currentWorld,
+                       ((BiomeDecorator)this).randomGenerator, ((BiomeDecorator)this).chunk_X,
+                       ((BiomeDecorator)this).chunk_Z, FLOWERS);
+                for (j = 0; doGen && j < ((BiomeDecorator)this).flowersPerChunk; ++j)
+                {
+                    int k = ((BiomeDecorator)this).chunk_X + ((BiomeDecorator)this).randomGenerator.nextInt(16) + 8;
+                    int l = ((BiomeDecorator)this).chunk_Z + ((BiomeDecorator)this).randomGenerator.nextInt(16) + 8;
+                    int i1 = ((BiomeDecorator)this).randomGenerator.nextInt(((BiomeDecorator)this).currentWorld.getHeightValue(k, l) + 32);
+                    String s = biome.func_150572_a(((BiomeDecorator)this).randomGenerator, k, i1, l);
+                    BlockFlower blockflower = BlockFlower.func_149857_e(s);
+
+                    if (blockflower.getMaterial() != Material.air)
+                    {
+                        ((BiomeDecorator)this).yellowFlowerGen.func_150550_a(blockflower, BlockFlower.func_149856_f(s));
+                        ((BiomeDecorator)this).yellowFlowerGen.generate(((BiomeDecorator)this).currentWorld,
+                                ((BiomeDecorator)this).randomGenerator, k, i1, l);
+                    }
+                }
+               throw e;
+        }
+        ((BiomeDecorator)this).currentWorld  = previous;
+        ((BiomeDecorator)this).randomGenerator = randomizer;
+    } */
+    
+    @Override
+    public void decorateChunk(World world, Random p_150512_2_, BiomeGenBase p_150512_3_, int p_150512_4_, int p_150512_5_) {
+        World previous =this.currentWorld;
+        Random randomizer= this.randomGenerator;
+        currentWorld  = null;
+        World targetWorld = (world == null) ? previous : world;
+        super.decorateChunk(targetWorld, p_150512_2_, p_150512_3_, p_150512_4_, p_150512_5_);
+        this.currentWorld  = previous;
+        randomGenerator = randomizer;
+    }
+
+   public void func_150513_ab(BiomeGenBase p_150513_1_) {
+       Random randomizer = mcthis.randomGenerator;
+       World world = mcthis.currentWorld;
+       int x = mcthis.chunk_X;
+       int z = mcthis.chunk_Z;
+        MinecraftForge.EVENT_BUS.post(new DecorateBiomeEvent.Pre(world, randomizer, x, z));
+        this.genOreAccess.run(mcthis);
+        int i;
+        int j;
+        int k;
+
+        boolean doGen = TerrainGen.decorate(world, randomizer, x, z, SAND);
+        for (i = 0; doGen && i < mcthis.sandPerChunk2; ++i)
+        {
+            j = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            k = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            mcthis.sandGen.generate(world, randomizer, j, world.getTopSolidOrLiquidBlock(j, k), k);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, CLAY);
+        for (i = 0; doGen && i < mcthis.clayPerChunk; ++i)
+        {
+            j = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            k = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            mcthis.clayGen.generate(world, randomizer, j, world.getTopSolidOrLiquidBlock(j, k), k);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, SAND_PASS2);
+        for (i = 0; doGen && i < mcthis.sandPerChunk; ++i)
+        {
+            j = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            k = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            mcthis.gravelAsSandGen.generate(world, randomizer, j, world.getTopSolidOrLiquidBlock(j, k), k);
+        }
+
+        i = mcthis.treesPerChunk;
+
+        if (randomizer == null) throw new RuntimeException("already missing randomizer");
+        if (randomizer.nextInt(10) == 0)
+        {
+            ++i;
+        }
+
+        int l;
+        int i1;
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, TREE);
+        for (j = 0; doGen && j < i; ++j)
+
+        {
+            if (randomizer == null) throw new RuntimeException("no randomizer");
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            i1 = world.getHeightValue(k, l);
+            WorldGenAbstractTree worldgenabstracttree = p_150513_1_.func_150567_a(randomizer);
+            worldgenabstracttree.setScale(1.0D, 1.0D, 1.0D);
+
+            if (worldgenabstracttree.generate(world, randomizer, k, i1, l))
+            {
+                worldgenabstracttree.func_150524_b(world, randomizer, k, i1, l);
+            }
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, BIG_SHROOM);
+        for (j = 0; doGen && j < mcthis.bigMushroomsPerChunk; ++j)
+        {
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            mcthis.bigMushroomGen.generate(world, randomizer, k, world.getHeightValue(k, l), l);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, FLOWERS);
+        for (j = 0; doGen && j < mcthis.flowersPerChunk; ++j)
+        {
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            i1 = randomizer.nextInt(world.getHeightValue(k, l) + 32);
+            String s = p_150513_1_.func_150572_a(randomizer, k, i1, l);
+            BlockFlower blockflower = BlockFlower.func_149857_e(s);
+
+            if (blockflower.getMaterial() != Material.air)
+            {
+                mcthis.yellowFlowerGen.func_150550_a(blockflower, BlockFlower.func_149856_f(s));
+                mcthis.yellowFlowerGen.generate(world, randomizer, k, i1, l);
+            }
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, GRASS);
+        for (j = 0; doGen && j < mcthis.grassPerChunk; ++j)
+        {
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            i1 = randomizer.nextInt(world.getHeightValue(k, l) * 2);
+            WorldGenerator worldgenerator = p_150513_1_.getRandomWorldGenForGrass(randomizer);
+            worldgenerator.generate(world, randomizer, k, i1, l);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, DEAD_BUSH);
+        for (j = 0; doGen && j < mcthis.deadBushPerChunk; ++j)
+        {
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            i1 = randomizer.nextInt(world.getHeightValue(k, l) * 2);
+            (new WorldGenDeadBush(Blocks.deadbush)).generate(world, randomizer, k, i1, l);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, LILYPAD);
+        for (j = 0; doGen && j < mcthis.waterlilyPerChunk; ++j)
+        {
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+
+            for (i1 = randomizer.nextInt(world.getHeightValue(k, l) * 2); i1 > 0 && world.isAirBlock(k, i1 - 1, l); --i1)
+            {
+                ;
+            }
+
+            mcthis.waterlilyGen.generate(world, randomizer, k, i1, l);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, SHROOM);
+        for (j = 0; doGen && j < mcthis.mushroomsPerChunk; ++j)
+        {
+            if (randomizer.nextInt(4) == 0)
+            {
+                k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+                l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+                i1 = world.getHeightValue(k, l);
+                mcthis.mushroomBrownGen.generate(world, randomizer, k, i1, l);
+            }
+
+            if (randomizer.nextInt(8) == 0)
+            {
+                k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+                l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+                i1 = randomizer.nextInt(world.getHeightValue(k, l) * 2);
+                mcthis.mushroomRedGen.generate(world, randomizer, k, i1, l);
+            }
+        }
+
+        if (doGen && randomizer.nextInt(4) == 0)
+        {
+            j = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            k = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            l = randomizer.nextInt(world.getHeightValue(j, k) * 2);
+            mcthis.mushroomBrownGen.generate(world, randomizer, j, l, k);
+        }
+
+        if (doGen && randomizer.nextInt(8) == 0)
+        {
+            j = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            k = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            l = randomizer.nextInt(world.getHeightValue(j, k) * 2);
+            mcthis.mushroomRedGen.generate(world, randomizer, j, l, k);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, REED);
+        for (j = 0; doGen && j < mcthis.reedsPerChunk; ++j)
+        {
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            i1 = randomizer.nextInt(world.getHeightValue(k, l) * 2);
+            mcthis.reedGen.generate(world, randomizer, k, i1, l);
+        }
+
+        for (j = 0; doGen && j < 10; ++j)
+        {
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            i1 = randomizer.nextInt(world.getHeightValue(k, l) * 2);
+            mcthis.reedGen.generate(world, randomizer, k, i1, l);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, PUMPKIN);
+        if (doGen && randomizer.nextInt(32) == 0)
+        {
+            j = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            k = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            l = randomizer.nextInt(world.getHeightValue(j, k) * 2);
+            (new WorldGenPumpkin()).generate(world, randomizer, j, l, k);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, CACTUS);
+        for (j = 0; doGen && j < mcthis.cactiPerChunk; ++j)
+        {
+            k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+            l = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+            i1 = randomizer.nextInt(world.getHeightValue(k, l) * 2);
+            mcthis.cactusGen.generate(world, randomizer, k, i1, l);
+        }
+
+        doGen = TerrainGen.decorate(world, randomizer, x, z, LAKE);
+        if (doGen && mcthis.generateLakes)
+        {
+            for (j = 0; j < 50; ++j)
+            {
+                k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+                l = randomizer.nextInt(randomizer.nextInt(248) + 8);
+                i1 = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+                (new WorldGenLiquids(Blocks.flowing_water)).generate(world, randomizer, k, l, i1);
+            }
+
+            for (j = 0; j < 20; ++j)
+            {
+                k = mcthis.chunk_X + randomizer.nextInt(16) + 8;
+                l = randomizer.nextInt(randomizer.nextInt(randomizer.nextInt(240) + 8) + 8);
+                i1 = mcthis.chunk_Z + randomizer.nextInt(16) + 8;
+                (new WorldGenLiquids(Blocks.flowing_lava)).generate(world, randomizer, k, l, i1);
+            }
+        }
+
+        MinecraftForge.EVENT_BUS.post(new DecorateBiomeEvent.Post(world, randomizer, x, z));
+    }
+
+
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CurrentWorldMemento.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CurrentWorldMemento.java
index 1033996..26856e6 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CurrentWorldMemento.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/CurrentWorldMemento.java
@@ -1,8 +1,10 @@
 
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import Zeno410Utils.Accessor;
+import biomesoplenty.api.biome.BOPBiome;
+import biomesoplenty.api.biome.BOPInheritedBiome;
 import java.util.HashSet;
-
 import net.minecraft.world.World;
 import net.minecraft.world.biome.BiomeGenBase;
 
@@ -25,6 +27,9 @@ public class CurrentWorldMemento {
         for (int i = 0 ;i < biomes.length; i++) {
             BiomeGenBase biome = biomes[i];
             if (biome != null) {
+                if (manager.bopHot()) {
+                    biome= manager.bopAdjustedBiome(biome);
+                }
                 World currentWorld = biome.theBiomeDecorator.currentWorld;
                 if (currentWorld != null) {
                     worlds[remembered] = currentWorld;
@@ -39,6 +44,9 @@ public class CurrentWorldMemento {
         BiomeGenBase [] biomes = BiomeGenBase.getBiomeGenArray();
         for (int i = 0;  i < remembered; i++) {
             BiomeGenBase biome = biomes[indices[i]];
+            if (manager.bopHot()) {
+                biome= manager.bopAdjustedBiome(biome);
+            }
             biome.theBiomeDecorator.currentWorld = worlds[i];
         }
         remembered = 0;
@@ -47,10 +55,29 @@ public class CurrentWorldMemento {
 
     static class Manager {
         private HashSet<CurrentWorldMemento> available = new HashSet<CurrentWorldMemento>();
+        private boolean bopHot;
+        private Accessor<BOPInheritedBiome,BiomeGenBase> inheritedBiomeAccess;
 
         public Manager() {
+            try {
+                Class bopBiomeclass = BOPBiome.class;// to make sure it's there
+                bopHot = true;
+                inheritedBiomeAccess = new Accessor<BOPInheritedBiome,BiomeGenBase>(BiomeGenBase.class);
+            } catch (java.lang.NoClassDefFoundError e) {
+                bopHot = false;
+            }
         }
 
+        public BiomeGenBase bopAdjustedBiome(BiomeGenBase source) {
+            if (source == null) return source;
+            if (source instanceof BOPInheritedBiome) {
+                return inheritedBiomeAccess.get((BOPInheritedBiome)source);
+            }
+            return source;
+        }
+
+        public boolean bopHot() {return bopHot;}
+
         private void release(CurrentWorldMemento freed) {
             available.add(freed);
         }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerStrataColumn.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerStrataColumn.java
index db662ad..a45972e 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerStrataColumn.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerStrataColumn.java
@@ -1,5 +1,6 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.BiomeGenUndergroundBase;
 import net.minecraft.world.gen.layer.*;
 
 /**
@@ -25,8 +26,7 @@ public class GenLayerStrataColumn  extends GenLayer{
      * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
      * amounts, or biomeList[] indices based on the particular GenLayer subclass.
      */
-    @Override
-	public int[] getInts(int par1, int par2, int par3, int par4)
+    public int[] getInts(int par1, int par2, int par3, int par4)
     {
         int[] aint = IntCache.getIntCache(par3 * par4);
 
@@ -34,7 +34,7 @@ public class GenLayerStrataColumn  extends GenLayer{
         {
             for (int j1 = 0; j1 < par3; ++j1)
             {
-                this.initChunkSeed(par1 + j1, par2 + i1);
+                this.initChunkSeed((long)(par1 + j1), (long)(par2 + i1));
                 aint[j1 + i1 * par3] = this.nextInt(biomeCount);
             }
         }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerUnderground.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerUnderground.java
index 8444d54..da62e76 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerUnderground.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerUnderground.java
@@ -1,90 +1,95 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.UndergroundBiomeSet;
 import net.minecraft.world.gen.layer.*;
-import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+
+import exterminatorJeff.undergroundBiomes.common.WorldGenManager;
+
 
 public abstract class GenLayerUnderground extends GenLayer {
-	private static int biomeSize = 3;
-	public static int biomeSizeOfEntireMinecraftWorld = 22;
-	public static int biomeSizeUsedForEarlierVersions = 3;
-	public static boolean testing;
-	
-	/**
-	 * the first array item is a linked list of the bioms, the second is the zoom function, the third is the same as the first.
-	 */
-	public static GenLayer[] initializeAllBiomeGenerators(long par0, int size, UndergroundBiomeSet biomeSet) {
-		
-		GenLayerIsland var3 = new GenLayerIsland(1L);
-		GenLayerFuzzyZoom var9 = new GenLayerFuzzyZoom(2000L, var3);
-		GenLayerAddIsland var10 = new GenLayerAddIsland(1L, var9);
-		
-		GenLayerZoom var11 = new GenLayerZoom(2001L, var10);
-		var10 = new GenLayerAddIsland(2L, var11);
-		
-		var11 = new GenLayerZoom(2002L, var10);
-		var10 = new GenLayerAddIsland(3L, var11);
-		var11 = new GenLayerZoom(2003L, var10);
-		var10 = new GenLayerAddIsland(4L, var11);
-		int var4 = biomeSize;
-		
-		GenLayer var5 = GenLayerZoom.magnify(1000L, var11, 0);
-		var5 = GenLayerZoom.magnify(1000L, var5, var4 + 2);
-		
-		GenLayerUndergroundBiomes var17 = new GenLayerUndergroundBiomes(200L, var5, biomeSet);
-		
-		if (size >= biomeSizeOfEntireMinecraftWorld) {
-			size = biomeSizeUsedForEarlierVersions;
-		}
-		
-		GenLayerSmooth var15 = new GenLayerSmooth(1000L, var17);
-		GenLayer var6 = GenLayerZoom.magnify(1000L, var15, size);
-		var6 = GenLayerZoom.magnify(1000L, var6, 2);
-		
-		GenLayerSmooth var19 = new GenLayerSmooth(1000L, var6);
-		
-		GenLayerVoronoiZoom var8 = new GenLayerVoronoiZoom(10L, var19);
-		var8.initWorldGenSeed(par0);
-		//testGenerator(var8, size);
-		//testBiomeSize(var8);
-		// WorldGenManager.logger.info("initializing underground biome generators");
-		
-		return new GenLayer[] { var19, var8, var19 };
-	}
-	
-	public GenLayerUnderground(long par1) {
-		super(par1);
-	}
-	
-	public static void testGenerator(GenLayer generator, int biomeSize) {
-		int numberBiomes = 40;
-		int[] hits = new int[numberBiomes];
-		int multiplier = 16 << biomeSize;
-		testing = true;
-		for (int i = 0; i < 30; i++) {
-			for (int j = 0; j < 30; j++) {
-				int biome = generator.getInts(i * multiplier, j * multiplier, 16, 16)[0];
-				UndergroundBiomes.logger.info("biome " + biome + " from " + i * multiplier + " " + j * multiplier);
-				hits[biome]++;
-			}
-		}
-		for (int biomeType = 0; biomeType < numberBiomes; biomeType++) {
-			UndergroundBiomes.logger.info("biome " + biomeType + " hits " + hits[biomeType]);
-		}
-		
-		testing = false;
-	}
-	
-	public static void testBiomeSize(GenLayer generator) {
-		int length = 10000;
-		int currentBiome = generator.getInts(0, 0, 16, 16)[0];
-		int currentStart = 0;
-		for (int i = 10; i < length; i += 10) {
-			int newBiome = generator.getInts(i, 0, 16, 16)[0];
-			if (newBiome != currentBiome) {
-				UndergroundBiomes.logger.info("biome " + currentBiome + " length " + (i - currentStart));
-				currentStart = i;
-				currentBiome = newBiome;
-			}
-		}
-	}
+    private static int biomeSize = 3;
+    public static int biomeSizeOfEntireMinecraftWorld = 22;
+    public static int biomeSizeUsedForEarlierVersions = 3;
+    public static boolean testing;
+
+    /**
+     * the first array item is a linked list of the bioms, the second is the zoom function, the third is the same as the
+     * first.
+     */
+    public static GenLayer[] initializeAllBiomeGenerators(long par0, int size, UndergroundBiomeSet biomeSet) {
+        
+        GenLayerIsland var3 = new GenLayerIsland(1L);   
+        GenLayerFuzzyZoom var9 = new GenLayerFuzzyZoom(2000L, var3);
+        GenLayerAddIsland var10 = new GenLayerAddIsland(1L, var9);
+        
+        GenLayerZoom var11 = new GenLayerZoom(2001L, var10);
+        var10 = new GenLayerAddIsland(2L, var11);
+        
+        var11 = new GenLayerZoom(2002L, var10);
+        var10 = new GenLayerAddIsland(3L, var11);
+        var11 = new GenLayerZoom(2003L, var10);
+        var10 = new GenLayerAddIsland(4L, var11);
+        int var4 = biomeSize;
+
+        GenLayer var5 = GenLayerZoom.magnify(1000L, var11, 0);
+        var5 = GenLayerZoom.magnify(1000L, var5, var4 + 2);
+        
+        GenLayerUndergroundBiomes var17 = new GenLayerUndergroundBiomes(200L, var5,biomeSet);
+
+        if (size >= biomeSizeOfEntireMinecraftWorld) size = biomeSizeUsedForEarlierVersions;
+        
+        GenLayerSmooth var15 = new GenLayerSmooth(1000L, var17);
+        GenLayer var6 = GenLayerZoom.magnify(1000L, var15, size);
+        var6 = GenLayerZoom.magnify(1000L, var6, 2);
+        
+        
+
+        GenLayerSmooth var19 = new GenLayerSmooth(1000L, var6);
+        
+        GenLayerVoronoiZoom var8 = new GenLayerVoronoiZoom(10L, var19);
+        var8.initWorldGenSeed(par0);
+        //testGenerator(var8, size);
+        //testBiomeSize(var8);
+        WorldGenManager.logger.info("initializing underground biome generators");
+
+        return new GenLayer[] {var19, var8, var19};
+    }
+
+    public GenLayerUnderground(long par1){
+        super(par1);
+    }
+
+    public static void testGenerator(GenLayer generator, int biomeSize) {
+        int numberBiomes = 40;
+        int [] hits = new int [numberBiomes];
+        int multiplier = 16 << biomeSize;
+        testing = true;
+        for (int i = 0; i < 30; i ++) {
+            for (int j  = 0; j < 30; j++) {
+                int biome = generator.getInts(i*multiplier,j*multiplier,16,16)[0];
+                WorldGenManager.logger.info("biome "+ biome  + " from "+ i*multiplier + " "+j*multiplier);
+                hits[biome]++;
+            }
+        }
+        for (int biomeType = 0; biomeType < numberBiomes; biomeType++) {
+            WorldGenManager.logger.info("biome "+ biomeType + " hits "+ hits[biomeType]);
+        }
+
+        testing = false;
+
+    }
+
+    public static void testBiomeSize(GenLayer generator) {
+        int length = 10000;
+        int currentBiome = generator.getInts(0,0,16,16)[0];
+        int currentStart =0;
+        for (int i = 10; i < length; i+= 10) {
+            int newBiome = generator.getInts(i,0,16,16)[0];
+            if (newBiome != currentBiome) {
+                WorldGenManager.logger.info("biome "+ currentBiome + " length "+ (i - currentStart));
+                currentStart = i;
+                currentBiome = newBiome;
+            }
+        }
+    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerUndergroundBiomes.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerUndergroundBiomes.java
index cec9a42..b8f4c09 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerUndergroundBiomes.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/GenLayerUndergroundBiomes.java
@@ -1,45 +1,16 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.BiomeGenUndergroundBase;
+import exterminatorJeff.undergroundBiomes.api.UndergroundBiomeSet;
 import net.minecraft.world.gen.layer.*;
 
-import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
-
 public class GenLayerUndergroundBiomes extends GenLayer{
     /** this sets all the biomes that are allowed to appear in the overworld */
     private BiomeGenUndergroundBase[] allowedBiomes;
 
     public GenLayerUndergroundBiomes(long par1, GenLayer par3GenLayer, UndergroundBiomeSet biomeSet) {
         super(par1);
-        if (!UndergroundBiomes.vanillaStoneBiomes()) {
-            this.allowedBiomes = new BiomeGenUndergroundBase[] {biomeSet.igneous1, biomeSet.igneous2,
-                    biomeSet.igneous3, biomeSet.igneous4,
-                    biomeSet.igneous5, biomeSet.igneous6, biomeSet.igneous7,
-                    biomeSet.igneous8, biomeSet.igneous9, biomeSet.igneous10,
-                    biomeSet.igneous11, biomeSet.igneous12, biomeSet.igneous13,
-                    biomeSet.igneous14, biomeSet.igneous15, biomeSet.igneous16,
-                    biomeSet.metamorphic1, biomeSet.metamorphic2, biomeSet.metamorphic3,
-                    biomeSet.metamorphic4, biomeSet.metamorphic5, biomeSet.metamorphic6,
-                    biomeSet.metamorphic7, biomeSet.metamorphic8, biomeSet.metamorphic9,
-                    biomeSet.metamorphic10, biomeSet.metamorphic11, biomeSet.metamorphic12,
-                    biomeSet.metamorphic13, biomeSet.metamorphic14, biomeSet.metamorphic15,
-                    biomeSet.metamorphic16};
-        } else {
-            this.allowedBiomes = new BiomeGenUndergroundBase[] {biomeSet.igneous1, biomeSet.igneous2,
-                    biomeSet.igneous3, biomeSet.igneous4,
-                    biomeSet.igneous5, biomeSet.igneous6, biomeSet.igneous7,
-                    biomeSet.igneous8, biomeSet.igneous9, biomeSet.igneous10,
-                    biomeSet.igneous11, biomeSet.igneous12, biomeSet.igneous13,
-                    biomeSet.igneous14, biomeSet.igneous15, biomeSet.igneous16,
-                    biomeSet.metamorphic1, biomeSet.metamorphic2, biomeSet.metamorphic3,
-                    biomeSet.metamorphic4, biomeSet.metamorphic5, biomeSet.metamorphic6,
-                    biomeSet.metamorphic7, biomeSet.metamorphic8, biomeSet.metamorphic9,
-                    biomeSet.metamorphic10, biomeSet.metamorphic11, biomeSet.metamorphic12,
-                    biomeSet.metamorphic13, biomeSet.metamorphic14, biomeSet.metamorphic15,
-                    biomeSet.metamorphic16,
-                    biomeSet.vanillaStone1, biomeSet.vanillaStone2,
-                    biomeSet.vanillaStone3, biomeSet.vanillaStone4
-                    };
-        }
+        allowedBiomes = biomeSet.allowedBiomes();
         this.parent = par3GenLayer;
 
     }
@@ -48,15 +19,14 @@ public class GenLayerUndergroundBiomes extends GenLayer{
      * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
      * amounts, or biomeList[] indices based on the particular GenLayer subclass.
      */
-    @Override
-	public int[] getInts(int par1, int par2, int par3, int par4)
+    public int[] getInts(int par1, int par2, int par3, int par4)
     {
         //int[] var5 = this.parent.getInts(par1, par2, par3, par4);
         int[] var6 = IntCache.getIntCache(par3 * par4);
 
         for (int var7 = 0; var7 < par4; ++var7) {
             for (int var8 = 0; var8 < par3; ++var8){
-                this.initChunkSeed(var8 + par1, var7 + par2);
+                this.initChunkSeed((long)(var8 + par1), (long)(var7 + par2));
                 var6[var8 + var7 * par3] =this.allowedBiomes[this.nextInt(this.allowedBiomes.length)].biomeID;
             }
         }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/OreUBifier.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/OreUBifier.java
index d325f41..f618b6d 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/OreUBifier.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/OreUBifier.java
@@ -1,5 +1,7 @@
+
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.UBStoneCodes;
 import cpw.mods.fml.common.event.FMLPreInitializationEvent;
 import cpw.mods.fml.common.registry.GameRegistry;
 import Zeno410Utils.BlockState;
@@ -8,392 +10,399 @@ import exterminatorJeff.undergroundBiomes.client.RenderUBOre;
 import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
 import exterminatorJeff.undergroundBiomes.common.block.BlockMetadataBase;
 import exterminatorJeff.undergroundBiomes.common.block.BlockOverlay;
-import exterminatorJeff.undergroundBiomes.common.block.BlockUBHidden;
 import exterminatorJeff.undergroundBiomes.common.block.BlockUBOre;
-import exterminatorJeff.undergroundBiomes.common.item.ItemUBHiddenBlock;
 import exterminatorJeff.undergroundBiomes.common.item.ItemUBOreBlock;
 import Zeno410Utils.Acceptor;
 import Zeno410Utils.ConcreteMutable;
 import Zeno410Utils.Function;
 import Zeno410Utils.KeyedRegistry;
+import Zeno410Utils.MinecraftName;
 import Zeno410Utils.Mutable;
 import Zeno410Utils.Zeno410Logger;
+import exterminatorJeff.undergroundBiomes.common.block.BlockUBHidden;
 import exterminatorJeff.undergroundBiomes.common.block.BlockUBMetadataOre;
-
+import exterminatorJeff.undergroundBiomes.common.block.BlockUBReplaceable;
+import exterminatorJeff.undergroundBiomes.common.item.ItemUBHiddenBlock;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.logging.Logger;
-
 import net.minecraft.block.Block;
 import net.minecraft.init.Blocks;
+import net.minecraft.item.Item;
 import net.minecraft.item.ItemStack;
 import net.minecraftforge.oredict.OreDictionary;
 
 /**
  * This class registers blocks and prepares the decorator for converting ores to a UB base stone
- * 
  * @author Zeno410
  */
 public final class OreUBifier {
 
-	public static Logger logger = new Zeno410Logger("OreUBifier").logger();
-	
-	private boolean replacementActive;
-	private UBVersionsDictionary blockReplacer = new UBVersionsDictionary();
-	private ReplacedOres replacedOres = new ReplacedOres();
-	private HashMap<Block, Block> oreFor = new HashMap<Block, Block>();
-	private HashMap<Block, Block> overlayFor = new HashMap<Block, Block>();
-	private HashMap<Block, Block> stoneFor = new HashMap<Block, Block>();
-	private HashSet<Class> replacedBlockClasses = new HashSet<Class>();
-	private BlockReplacer[] blockReplacers;
-	
-	private ConcreteMutable<Integer> renderID = new ConcreteMutable<Integer>();
-	private Acceptor<Boolean> updateReplacement = new Acceptor<Boolean>() {
-		@Override
-		public void accept(Boolean accepted) {
-			replacementActive = accepted;
-		}
-	};
-	
-	public OreUBifier(Mutable<Boolean> replacementFlag) {
-		this.replacementActive = replacementFlag.value();
-		// send callback so replacement gets updated if setting change;
-		replacementFlag.informOnChange(updateReplacement);
-	}
-	
-	public void setupUBHidden(Block oreBlock, FMLPreInitializationEvent event) {
-		assert (event != null);
-		registerHiddenBlock(oreBlock, UndergroundBiomes.igneousStone, "igneous");
-		registerHiddenBlock(oreBlock, UndergroundBiomes.metamorphicStone, "metamorphic");
-		registerHiddenBlock(oreBlock, UndergroundBiomes.sedimentaryStone, "sedimentary");
-		replacedOres.setAll(oreBlock);
-		this.replacedBlockClasses.add(oreBlock.getClass());
-	}
-	
-	public void setupUBOre(Block oreBlock, String overlayName, FMLPreInitializationEvent event) {
-		assert (event != null);
-		registerBlock(oreBlock, UndergroundBiomes.igneousStone, "igneous", overlayName);
-		registerBlock(oreBlock, UndergroundBiomes.metamorphicStone, "metamorphic", overlayName);
-		registerBlock(oreBlock, UndergroundBiomes.sedimentaryStone, "sedimentary", overlayName);
-		replacedOres.setAll(oreBlock);
-		this.replacedBlockClasses.add(oreBlock.getClass());
-	}
-	
-	public void setupUBOre(String blockName, int metadata, String overlayName) {
-		Block blockOre = Block.getBlockFromName(blockName);
-		if (blockOre == null) {
-			return;
-		}
-		String unlocalizedName = blockOre.getUnlocalizedName();
-		UndergroundBiomes.logger.info("Adding ores: " + unlocalizedName);
-		setupUBOre(blockOre, overlayName, metadata);
-	}
-	
-	public void setupUBOre(Block oreBlock, String overlayName, int metadata) {
-		replacedOres.set(oreBlock, metadata);
-		this.replacedBlockClasses.add(oreBlock.getClass());
-		registerBlockWithMetadata(oreBlock, UndergroundBiomes.igneousStone, "igneous", overlayName, metadata);
-		registerBlockWithMetadata(oreBlock, UndergroundBiomes.metamorphicStone, "metamorphic", overlayName, metadata);
-		registerBlockWithMetadata(oreBlock, UndergroundBiomes.sedimentaryStone, "sedimentary", overlayName, metadata);
-	}
-	
-	private void registerHiddenBlock(Block oreBlock, BlockMetadataBase ubStone, String rockName) {
-		BlockUBHidden ubOre = new BlockUBHidden(ubStone, oreBlock);
-		NamedBlock namer = new NamedBlock(rockName + "_" + oreBlock.getUnlocalizedName().substring(5));
-		BlockOverlay.logger.info("block " + oreBlock + " no metadata ");
-		GameRegistry.registerBlock(ubOre, ItemUBHiddenBlock.class, namer.internal());
-		//BlockOverlay.logger.info(namer.internal());
-		// all the metadatas get replaced
-		for (int i = 0; i < 16; i++) {
-			blockReplacer.item(oreBlock).ubversions[i].set(ubStone, ubOre);
-		}
-		oreFor.put(ubOre, oreBlock);
-		stoneFor.put(ubOre, ubStone);
-	}
-	
-	private void registerBlock(Block oreBlock, BlockMetadataBase ubStone, String rockName, String overlayName) {
-		BlockOverlay overlay = new BlockOverlay(overlayName);
-		BlockUBOre ubOre = new BlockUBOre(ubStone, oreBlock, overlay, renderID);
-		NamedBlock namer = new NamedBlock(rockName + "_" + oreBlock.getUnlocalizedName().substring(5));
-		BlockOverlay.logger.info("block " + oreBlock + " no metadata ");
-		GameRegistry.registerBlock(ubOre, ItemUBOreBlock.class, namer.internal());
-		// all the metadatas get replaced
-		for (int i = 0; i < 16; i++) {
-			blockReplacer.item(oreBlock).ubversions[i].set(ubStone, ubOre);
-		}
-		oreFor.put(ubOre, oreBlock);
-		overlayFor.put(ubOre, overlay);
-		stoneFor.put(ubOre, ubStone);
-	}
-	
-	private void registerBlockWithMetadata(Block oreBlock, BlockMetadataBase ubStone, String rockName, String overlayName, int metadata) {
-		BlockOverlay overlay = new BlockOverlay(overlayName);
-		
-		BlockState oreBlockState = new BlockState(oreBlock, metadata);
-		BlockUBOre ubOre = new BlockUBMetadataOre(ubStone, oreBlockState, overlay, renderID);
-		NamedBlock namer = null;
-		BlockOverlay.logger.info("block " + oreBlock + " metadata " + metadata + " " + overlayName);
-		if (metadata == 0) {
-			namer = new NamedBlock(rockName + "_" + oreBlock.getUnlocalizedName().substring(5));
-		} else {
-			namer = new NamedBlock(rockName + "_" + oreBlock.getUnlocalizedName().substring(5) + "." + metadata);
-		}
-		GameRegistry.registerBlock(ubOre, ItemUBOreBlock.class, namer.internal());
-		blockReplacer.item(oreBlock).ubversions[metadata].set(ubStone, ubOre);
-		oreFor.put(ubOre, oreBlock);
-		overlayFor.put(ubOre, overlay);
-		stoneFor.put(ubOre, ubStone);
-		
-		// test replacement process
-		UBStoneCodes testUBStone = new UBStoneCodes(ubStone.namer, 4);
-		BlockState replacement = this.replacement(oreBlock, metadata, testUBStone, testUBStone);
-		if ((!(replaces(oreBlock, metadata))) && replacementActive) {
-			if (UndergroundBiomes.crashOnProblems()) {
-				BlockOverlay.logger.info("blueschist instanceof BlockMetadataBase " + (testUBStone.block instanceof BlockMetadataBase));
-				MetadataUBVersions versions = blockReplacer.item(oreBlock);
-				for (int i = 0; i < 16; i++) {
-					Block ore = versions.ubversions[i].ore((BlockMetadataBase) (testUBStone.block));
-					if (ore == null) {
-						BlockOverlay.logger.info("null in " + i);
-					} else {
-						BlockOverlay.logger.info(ore.getLocalizedName() + " " + ore.toString() + i);
-					}
-				}
-				throw new RuntimeException();
-			}
-		}
-		if (!Block.isEqualTo(replacement.block, ubOre)) {
-			if (UndergroundBiomes.crashOnProblems()) {
-				throw new RuntimeException();
-			} else {
-				
-			}
-		}
-		if (replacement.metadata != 4) {
-			if (UndergroundBiomes.crashOnProblems())
-				throw new RuntimeException();
-		}
-	}
-	
-	public int getRenderID() {
-		return renderID.value();
-	}
-	
-	public void setRenderer(RenderUBOre renderer) {
-		renderID.set(renderer.getRenderId());
-	}
-	
-	public Block baseOre(Block ubVersion) {
-		Block result = oreFor.get(ubVersion);
-		if (result == null) {
-			if (UndergroundBiomes.crashOnProblems()) {
-				throw new RuntimeException("no ore for " + ubVersion.getUnlocalizedName());
-			}
-			return Blocks.coal_ore;
-		}
-		return result;
-	}
-	
-	public BlockMetadataBase baseStone(Block ubVersion) {
-		Block result = stoneFor.get(ubVersion);
-		if (result == null) {
-			if (UndergroundBiomes.crashOnProblems()) {
-				throw new RuntimeException("no ore for " + ubVersion.getUnlocalizedName());
-			}
-			return UndergroundBiomes.igneousStone;
-		}
-		return (BlockMetadataBase) result;
-		
-	}
-	
-	public Block overlayBlock(Block ubVersion) {
-		Block result = overlayFor.get(ubVersion);
-		if (result == null) {
-			UndergroundBiomes.throwIfTesting("no overlay for " + ubVersion.getUnlocalizedName());
-		}
-		return result;
-		
-	}
-	
-	public void registerOres() {
-		for (Block block : this.oreFor.keySet()) {
-			Block ore = oreFor.get(block);
-			try {
-				int oreID = OreDictionary.getOreID(new ItemStack(ore));
-				OreDictionary.registerOre(oreID, block);
-			} catch (NullPointerException e) {
-				if (UndergroundBiomes.crashOnProblems())
-					throw e;
-			}
-		}
-		// no action needed at present since the ore dictionary handles mined ore
-		// and we mine ores as whatever block they come from.
-	}
-	
-	private class UBVersions {
-		private final HashMap<BlockMetadataBase, Block> converter = new HashMap<BlockMetadataBase, Block>();
-		private final HashMap<BlockMetadataBase, ArrayList<BlockState>> convertedBlockStates = new HashMap<BlockMetadataBase, ArrayList<BlockState>>();
-		
-		public void set(BlockMetadataBase ubStone, Block ubOre) {
-			converter.put(ubStone, ubOre);
-			ArrayList<BlockState> blockStates = new ArrayList<BlockState>();
-			for (int i = 0; i < BlockMetadataBase.metadatas; i++) {
-				blockStates.add(new BlockState(ubOre, i));
-			}
-			convertedBlockStates.put(ubStone, blockStates);
-		}
-		
-		public boolean active() {
-			return converter.size() > 0;
-		}
-		
-		public Block ore(BlockMetadataBase stone) {
-			return converter.get(stone);
-		}
-		
-		public BlockState convertedore(BlockMetadataBase stone, int metadata) {
-			return convertedBlockStates.get(stone).get(metadata);
-		}
-	}
-	
-	private class MetadataUBVersions {
-		private UBVersions ubversions[] = new UBVersions[16];
-		
-		MetadataUBVersions() {
-			for (int i = 0; i < 16; i++) {
-				ubversions[i] = new UBVersions();
-			}
-		}
-	}
-	
-	private class UBVersionsDictionary extends KeyedRegistry<Block, MetadataUBVersions> {
-		UBVersionsDictionary() {
-			super(new Function<Block, MetadataUBVersions>() {
-				@Override
-				public MetadataUBVersions result(Block baseOre) {
-					return new MetadataUBVersions();
-				}
-			});
-		}
-	}
-	
-	public boolean replacementActive() {
-		return replacementActive;
-	}
-	
-	public boolean replaces(Block possibleOre, int metadata) {
-		if (replacementActive) {
-			boolean result = replacedOres.has(possibleOre, metadata);
-			if (result == false) {
-				if (this.replacedBlockClasses.contains(possibleOre.getClass())) {
-					BlockOverlay.logger.info(possibleOre.toString() + " " + metadata + " " + possibleOre.getClass().toString());
-				}
-			}
-			return result;
-		}
-		return false;
-	}
-	
-	public BlockState replacement(Block ore, int metadata, UBStoneCodes stone, UBStoneCodes defaultStone) {
-		BlockMetadataBase baseStone;
-		// we look for a UB stone to use for the ore
-		if (stone.block instanceof BlockMetadataBase) {
-			baseStone = (BlockMetadataBase) stone.block;
-		} else {
-			if (defaultStone.block instanceof BlockMetadataBase) {
-				baseStone = (BlockMetadataBase) defaultStone.block;
-			} else {
-				// no UB stone available; stay with the default ore;
-				//return new BlockState(ore,metadata);
-				throw new RuntimeException();
-			}
-		}
-		return this.blockReplacer.item(ore).ubversions[metadata].convertedore(baseStone, stone.metadata);
-	}
-	
-	private class ReplacedOres {
-		private HashMap<Block, boolean[]> flags = new HashMap<Block, boolean[]>();
-		
-		private boolean[] assuredFlags(Block block) {
-			boolean[] result = flags.get(block);
-			if (result == null) {
-				result = new boolean[16];
-				flags.put(block, result);
-			}
-			return result;
-		}
-		
-		void set(Block block, int metadata) {
-			assuredFlags(block)[metadata] = true;
-		}
-		
-		boolean has(Block block, int metadata) {
-			boolean[] has = flags.get(block);
-			if (has == null)
-				return false;
-			return has[metadata];
-		}
-		
-		void setAll(Block block) {
-			for (int i = 0; i < 16; i++) {
-				set(block, i);
-			}
-		}
-	}
-	
-	public interface BlockStateReplacer {
-		public BlockState replacement(UBStoneCodes stone, UBStoneCodes defaultStone);
-	}
-	
-	public BlockReplacer blockReplacer(int blockID) {
-		return blockReplacers[blockID];
-	}
-	
-	public interface BlockReplacer {
-		public BlockStateReplacer replacer(int metadata);
-	}
-	
-	private class ConcreteBlockStateReplacer implements BlockStateReplacer {
-		private final UBVersions versions;
-		
-		ConcreteBlockStateReplacer(UBVersions versions) {
-			this.versions = versions;
-		}
-		
-		@Override
-		public BlockState replacement(UBStoneCodes stone, UBStoneCodes defaultStone) {
-			if (stone.block instanceof BlockMetadataBase) {
-				return versions.convertedore((BlockMetadataBase) stone.block, stone.metadata);
-			}
-			if (defaultStone.block instanceof BlockMetadataBase) {
-				return versions.convertedore((BlockMetadataBase) defaultStone.block, stone.metadata);
-			}
-			return null;
-		}
-	}
-	
-	private class ConcreteBlockReplacer implements BlockReplacer {
-		ConcreteBlockStateReplacer[] replacers = new ConcreteBlockStateReplacer[16];
-		
-		public ConcreteBlockReplacer(MetadataUBVersions metadataVersions) {
-			for (int i = 0; i < 16; i++) {
-				if (metadataVersions.ubversions[i].active()) {
-					replacers[i] = new ConcreteBlockStateReplacer(metadataVersions.ubversions[i]);
-				}
-			}
-		}
-		
-		@Override
-		public BlockStateReplacer replacer(int metadata) {
-			return replacers[metadata];
-		}
-	}
-	
-	public void renewBlockReplacers() {
-		this.blockReplacers = new ConcreteBlockReplacer[4096];
-		for (Block block : this.blockReplacer.keys()) {
-			blockReplacers[Block.getIdFromBlock(block)] = new ConcreteBlockReplacer(blockReplacer.item(block));
-		}
-	}
+    public static Logger logger = new Zeno410Logger("OreUBifier").logger();
+
+    private boolean replacementActive;
+    private UBVersionsDictionary blockReplacer = new UBVersionsDictionary();
+    private ReplacedOres replacedOres = new ReplacedOres();
+    private HashMap<Block,ItemStack> oreFor = new HashMap<Block,ItemStack>();
+    private HashMap<Block,Block> overlayFor = new HashMap<Block,Block>();
+    private HashMap<Block,Block> stoneFor = new HashMap<Block,Block>();
+    private HashSet<Class> replacedBlockClasses = new HashSet<Class>();
+    private BlockReplacer [] blockReplacers;
+
+    private ConcreteMutable<Integer> renderID = new ConcreteMutable<Integer>();
+    private Acceptor<Boolean> updateReplacement = new Acceptor<Boolean>() {
+        public void accept(Boolean accepted) {
+            replacementActive = accepted;
+        }
+    };
+
+
+    public OreUBifier(Mutable<Boolean> replacementFlag) {
+        this.replacementActive = replacementFlag.value();
+        // send callback so replacement gets updated if setting change;
+        replacementFlag.informOnChange(updateReplacement);
+    }
+
+    public void setupUBHidden(Block oreBlock,FMLPreInitializationEvent event){
+        assert(event != null);
+        registerHiddenBlock(oreBlock,UndergroundBiomes.igneousStone,"igneous");
+        registerHiddenBlock(oreBlock,UndergroundBiomes.metamorphicStone,"metamorphic");
+        registerHiddenBlock(oreBlock,UndergroundBiomes.sedimentaryStone,"sedimentary");
+        replacedOres.setAll(oreBlock);
+        this.replacedBlockClasses.add(oreBlock.getClass());
+    }
+    
+    public void setupUBOre(Block oreBlock, String overlayName, FMLPreInitializationEvent event){
+        assert(event != null);
+        registerBlock(oreBlock,UndergroundBiomes.igneousStone,"igneous",overlayName);
+        registerBlock(oreBlock,UndergroundBiomes.metamorphicStone,"metamorphic",overlayName);
+        registerBlock(oreBlock,UndergroundBiomes.sedimentaryStone,"sedimentary",overlayName);
+        replacedOres.setAll(oreBlock);
+        this.replacedBlockClasses.add(oreBlock.getClass());
+    }
+
+    public void setupUBOre(Block oreBlock, String overlayName, int metadata, MinecraftName blockName,
+            FMLPreInitializationEvent event){
+        assert(event != null);
+        replacedOres.set(oreBlock, metadata);
+        this.replacedBlockClasses.add(oreBlock.getClass());
+        registerBlockWithMetadata(oreBlock,UndergroundBiomes.igneousStone,"igneous",overlayName, metadata,blockName);
+        registerBlockWithMetadata(oreBlock,UndergroundBiomes.metamorphicStone,"metamorphic",overlayName, metadata,blockName);
+        registerBlockWithMetadata(oreBlock,UndergroundBiomes.sedimentaryStone,"sedimentary",overlayName, metadata,blockName);
+    }
+
+
+    private void registerBlock(Block oreBlock, BlockMetadataBase ubStone, String rockName, String overlayName) {
+        BlockOverlay overlay = new BlockOverlay(overlayName);
+        BlockUBOre ubOre = new BlockUBOre(ubStone,oreBlock,overlay,renderID);
+        NamedBlock namer = new NamedBlock(rockName+"_"+oreBlock.getUnlocalizedName().substring(5));
+        BlockOverlay.logger.info("block "+oreBlock+ " no metadata ");
+        GameRegistry.registerBlock(ubOre, ItemUBOreBlock.class, namer.internal());
+        //BlockOverlay.logger.info(namer.internal());
+        // all the metadatas get replaced
+        for (int i = 0; i < 16; i ++) {
+            blockReplacer.item(oreBlock).ubversions[i].set(ubStone, ubOre);
+        }
+        oreFor.put(ubOre, new ItemStack(oreBlock,1,1));
+        overlayFor.put(ubOre, overlay);
+        stoneFor.put(ubOre, ubStone);
+        int blockID = Block.getIdFromBlock(ubOre);
+        Item matchedItem = Item.getItemById(blockID);
+        Block matchedBlock = Block.getBlockFromItem(matchedItem);
+        //BlockOverlay.logger.info("block "+blockID+" matched to "+matchedItem.toString()+" for "+matchedBlock.getUnlocalizedName());
+    }
+
+    private void registerHiddenBlock(Block oreBlock, BlockMetadataBase ubStone, String rockName) {
+        BlockUBHidden ubOre = new BlockUBHidden(ubStone,oreBlock);
+        NamedBlock namer = new NamedBlock(rockName+"_"+oreBlock.getUnlocalizedName().substring(5));
+        BlockOverlay.logger.info("block "+oreBlock+ " no metadata ");
+        GameRegistry.registerBlock(ubOre, ItemUBHiddenBlock.class, namer.internal());
+        //BlockOverlay.logger.info(namer.internal());
+        // all the metadatas get replaced
+        for (int i = 0; i < 16; i ++) {
+            blockReplacer.item(oreBlock).ubversions[i].set(ubStone, ubOre);
+        }
+        oreFor.put(ubOre, new ItemStack(oreBlock,1,1));
+        stoneFor.put(ubOre, ubStone);
+        int blockID = Block.getIdFromBlock(ubOre);
+        Item matchedItem = Item.getItemById(blockID);
+    }
+
+    private void registerBlockWithMetadata(Block oreBlock, BlockMetadataBase ubStone, String rockName, String overlayName, 
+            int metadata, MinecraftName metadataBlockName) {
+        //overlayName.replace("metallurgy:/", "metallurgy:");
+        //overlayName = "Metallurgy:"+overlayName.substring("metallurgy:/".length());
+        BlockOverlay overlay = new BlockOverlay(overlayName);
+        logger.info(metadataBlockName.localized() + " " + metadataBlockName.unlocalized());
+
+        BlockState oreBlockState = new BlockState(oreBlock,metadata);
+        BlockUBOre ubOre = new BlockUBMetadataOre(ubStone,oreBlockState,overlay,renderID,metadataBlockName);
+        NamedBlock namer = null;
+        BlockOverlay.logger.info("block "+oreBlock+ " metadata "+metadata + " " +overlayName);
+        if (metadata == 0) {
+            namer = new NamedBlock(rockName+"_"+oreBlock.getUnlocalizedName().substring(5));
+        } else {
+            namer = new NamedBlock(rockName+"_"+oreBlock.getUnlocalizedName().substring(5)+"."+metadata);
+        }
+        GameRegistry.registerBlock(ubOre, ItemUBOreBlock.class, namer.internal());
+        //BlockOverlay.logger.info(namer.internal());
+        blockReplacer.item(oreBlock).ubversions[metadata].set(ubStone, ubOre);
+        oreFor.put(ubOre, new ItemStack(oreBlock,1,metadata));
+        overlayFor.put(ubOre, overlay);
+        stoneFor.put(ubOre, ubStone);
+        int blockID = Block.getIdFromBlock(ubOre);
+        Item matchedItem = Item.getItemById(blockID);
+        Block matchedBlock = Block.getBlockFromItem(matchedItem);
+
+        // test replacement process
+        UBStoneCodes testUBStone = new UBStoneCodes(ubStone.namer,4);
+        BlockState replacement = this.replacement(oreBlock, metadata, testUBStone, testUBStone);
+        if ((!(replaces(oreBlock,metadata)))&&replacementActive) {
+            if (UndergroundBiomes.crashOnProblems()) {
+                BlockOverlay.logger.info("blueschist instanceof BlockMetadataBase " +(testUBStone.block instanceof BlockMetadataBase));
+                MetadataUBVersions versions = blockReplacer.item(oreBlock);
+                for (int i = 0; i < 16;i++) {
+                    Block ore = versions.ubversions[i].ore((BlockMetadataBase)(testUBStone.block)).block();
+                    if (ore == null) {
+                        BlockOverlay.logger.info("null in "+i);
+                    } else{
+                        BlockOverlay.logger.info(ore.getLocalizedName()+ " " + ore.toString()+i);
+                    }
+                }
+                throw new RuntimeException();
+            }
+        }
+        if (!Block.isEqualTo(replacement.block,ubOre)) {
+            if (UndergroundBiomes.crashOnProblems()) {
+                throw new RuntimeException();
+            } else {
+
+            }
+        }
+        if (replacement.metadata != 4) {
+            if (UndergroundBiomes.crashOnProblems()) throw new RuntimeException();
+        }
+
+        //BlockOverlay.logger.info("block "+blockID+" matched to "+matchedItem.toString()+" for "+matchedBlock.getUnlocalizedName());
+    }
+
+    public int getRenderID() {return renderID.value();}
+
+    public void setRenderer(RenderUBOre renderer) {
+        renderID.set(renderer.getRenderId());
+    }
+
+    public BlockMetadataBase baseStone(Block ubVersion) {
+        Block result = stoneFor.get(ubVersion);
+        if (result == null) {
+            if (UndergroundBiomes.crashOnProblems()) {
+                throw new RuntimeException("no ore for "+ubVersion.getUnlocalizedName());
+            }
+            return UndergroundBiomes.igneousStone;
+        }
+        return (BlockMetadataBase)result;
+
+    }
+
+    public Block overlayBlock(Block ubVersion) {
+        Block result = overlayFor.get(ubVersion);
+        if (result == null) {
+            UndergroundBiomes.throwIfTesting("no overlay for "+ubVersion.getUnlocalizedName());
+            return UndergroundBiomes.igneousStone;
+        }
+        return result;
+
+    }
+
+    public void registerOres() {
+        for (Block block: this.oreFor.keySet()){
+            ItemStack ore = oreFor.get(block);
+            try{
+                int oreID  = OreDictionary.getOreID(ore);
+                //OreDictionary.registerOre(oreID, block);
+                for (int metadata = 0; metadata<8; metadata++) {
+                    ItemStack metadataBlock = new ItemStack(block,1,metadata);
+                    OreDictionary.registerOre(oreID, metadataBlock);
+                }
+            } catch (NullPointerException e) {
+                if (UndergroundBiomes.crashOnProblems()) throw e;
+            }
+        }
+            // no action needed at present since the ore dictionary handles mined ore
+            // and we mine ores as whatever block they come from.
+
+    }
+
+    private class UBVersions {
+        private final HashMap<BlockMetadataBase,BlockUBReplaceable> converter =
+                new HashMap<BlockMetadataBase,BlockUBReplaceable>();
+        private final HashMap<BlockMetadataBase,ArrayList<BlockState>> convertedBlockStates =
+                new HashMap<BlockMetadataBase,ArrayList<BlockState>>();
+
+        public void set(BlockMetadataBase ubStone, BlockUBReplaceable ubOre) {
+            converter.put(ubStone, ubOre);
+            ArrayList<BlockState> blockStates = new ArrayList<BlockState>();
+            for (int i = 0; i < BlockMetadataBase.metadatas; i++) {
+                blockStates.add(new BlockState(ubOre.block(),i));
+            }
+            convertedBlockStates.put(ubStone, blockStates);
+        }
+
+        public boolean active() {return converter.size()>0;}
+
+        public BlockUBReplaceable ore(BlockMetadataBase stone) {
+            return converter.get(stone);
+        }
+
+        public BlockState convertedore(BlockMetadataBase stone, int metadata) {
+            return convertedBlockStates.get(stone).get(metadata);
+        }
+    }
+
+    private class MetadataUBVersions {
+        private UBVersions ubversions [] = new UBVersions[16];
+        MetadataUBVersions() {
+            for (int i = 0; i < 16;i++) {
+                ubversions[i] = new UBVersions();
+            }
+        }
+    }
+
+    private class UBVersionsDictionary extends KeyedRegistry<Block,MetadataUBVersions>{
+        UBVersionsDictionary() {
+            super(new Function<Block,MetadataUBVersions>() {
+                @Override
+                public MetadataUBVersions result(Block baseOre) {
+                    return new MetadataUBVersions();
+                }
+            });
+        }
+    }
+
+    public boolean replacementActive() {return replacementActive;}
+
+    public boolean replaces(Block possibleOre, int metadata) {
+        if (replacementActive) {
+            boolean result = replacedOres.has(possibleOre, metadata);
+            /* Code to test for missed ores
+            if (result == false) {
+                if (this.replacedBlockClasses.contains(possibleOre.getClass())) {
+                    BlockOverlay.logger.info(possibleOre.toString() + " " + metadata + " " +
+                            possibleOre.getClass().toString());
+                }
+            }*/
+            return result;
+        }
+        return false;
+    }
+
+    public BlockState replacement(Block ore, int metadata, UBStoneCodes stone, UBStoneCodes defaultStone) {
+        BlockMetadataBase baseStone;
+        // we look for a UB stone to use for the ore
+        if (stone.block instanceof BlockMetadataBase) {
+            baseStone = (BlockMetadataBase)stone.block;
+        } else {
+            if (defaultStone.block instanceof BlockMetadataBase) {
+                baseStone = (BlockMetadataBase)defaultStone.block;
+            } else {
+                // no UB stone available; stay with the default ore;
+                return new BlockState(ore,metadata);
+                //throw new RuntimeException();
+            }
+        }
+        return this.blockReplacer.item(ore).ubversions[metadata].convertedore(baseStone,stone.metadata);
+    }
+
+    private class MetadataIndexedBlock {
+        private Block [] blocks = new Block[16];
+        public void set(Block block, int index) {
+            blocks[index] = block;
+        }
+
+        public Block get(int index) {return blocks[index];}
+    }
+
+    private class ReplacedOres {
+        private HashMap<Block,boolean []> flags = new HashMap<Block,boolean []>();
+
+        private boolean [] assuredFlags(Block block) {
+            boolean [] result = flags.get(block);
+            if (result == null) {
+                result = new boolean[16];
+                flags.put(block, result);
+            }
+            return result;
+        }
+
+        void set(Block block, int metadata) {
+            assuredFlags(block)[metadata] = true;
+        }
+
+        boolean has(Block block, int metadata) {
+            boolean [] has = flags.get(block);
+            if (has == null) return false;
+            return has[metadata];
+        }
+
+        void setAll(Block block) {
+            for (int i = 0; i < 16; i++) {
+                set(block,i);
+            }
+        }
+    }
+    
+    public interface BlockStateReplacer {
+        public BlockState replacement(UBStoneCodes stone, UBStoneCodes defaultStone);
+    }
+
+    public BlockReplacer blockReplacer(int blockID) {
+        return blockReplacers[blockID];
+    }
+    public interface BlockReplacer {
+        public BlockStateReplacer replacer(int metadata);
+    }
+
+    private class ConcreteBlockStateReplacer implements BlockStateReplacer {
+        private final UBVersions versions;
+        ConcreteBlockStateReplacer(UBVersions versions) {
+            this.versions = versions;
+        }
+
+        public BlockState replacement(UBStoneCodes stone, UBStoneCodes defaultStone) {
+            if (stone.block instanceof BlockMetadataBase) {
+                return versions.convertedore((BlockMetadataBase)stone.block, stone.metadata);
+            }
+            if (defaultStone.block instanceof BlockMetadataBase) {
+                return versions.convertedore((BlockMetadataBase)defaultStone.block, stone.metadata);
+            }
+            return null;
+        }
+    }
+
+    private class ConcreteBlockReplacer implements BlockReplacer {
+        ConcreteBlockStateReplacer [] replacers = new ConcreteBlockStateReplacer[16];
+
+        public ConcreteBlockReplacer(MetadataUBVersions metadataVersions){
+            for (int i = 0 ; i < 16; i ++) {
+                if (metadataVersions.ubversions[i].active()) {
+                    replacers[i]= new ConcreteBlockStateReplacer(metadataVersions.ubversions[i]);
+                }
+            }
+        }
+
+        public BlockStateReplacer replacer(int metadata) {
+            return replacers[metadata];
+        }
+    }
+
+    public void renewBlockReplacers() {
+        this.blockReplacers = new ConcreteBlockReplacer [4096];
+        for (Block block: this.blockReplacer.keys()) {
+            blockReplacers[Block.getIdFromBlock(block)] =
+                    new ConcreteBlockReplacer(blockReplacer.item(block));
+        }
+    }
+
 }
+
diff --git E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/StandardUndergroundBiomeSet.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/StandardUndergroundBiomeSet.java
new file mode 100644
index 0000000..762637c
--- /dev/null
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/StandardUndergroundBiomeSet.java
@@ -0,0 +1,151 @@
+
+package exterminatorJeff.undergroundBiomes.worldGen;
+
+import exterminatorJeff.undergroundBiomes.api.BiomeGenUndergroundBase;
+import exterminatorJeff.undergroundBiomes.api.UndergroundBiomeSet;
+import exterminatorJeff.undergroundBiomes.api.NamedBlock;
+import exterminatorJeff.undergroundBiomes.api.NamedVanillaBlock;
+import exterminatorJeff.undergroundBiomes.api.UBIDs;
+import exterminatorJeff.undergroundBiomes.api.UndergroundBiomesSettings;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import java.util.ArrayList;
+
+/**
+ *
+ * @author Zeno410
+ */
+public class StandardUndergroundBiomeSet extends UndergroundBiomeSet {
+
+    private final UndergroundBiomesSettings settings;
+    public StandardUndergroundBiomeSet(UndergroundBiomesSettings settings) {
+        super(new BiomeGenStrataLayers(settings).layers);
+        this.settings = settings;
+    }
+
+    NamedBlock igneousID = UBIDs.igneousStoneName;
+
+    public final BiomeGenUndergroundBase igneous1 = (new BiomeGenUndergroundBase(0, igneousID, 0, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[0]);
+    public final BiomeGenUndergroundBase igneous2 = (new BiomeGenUndergroundBase(1, igneousID, 1, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[1]);
+    public final BiomeGenUndergroundBase igneous3 = (new BiomeGenUndergroundBase(2, igneousID, 2, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[2]);
+    public final BiomeGenUndergroundBase igneous4 = (new BiomeGenUndergroundBase(3, igneousID, 3, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[3]);
+    public final BiomeGenUndergroundBase igneous5 = (new BiomeGenUndergroundBase(4, igneousID, 4, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[4]);
+    public final BiomeGenUndergroundBase igneous6 = (new BiomeGenUndergroundBase(5, igneousID, 5, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[5]);
+    public final BiomeGenUndergroundBase igneous7 = (new BiomeGenUndergroundBase(6, igneousID, 6, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[6]);
+    public final BiomeGenUndergroundBase igneous8 = (new BiomeGenUndergroundBase(7, igneousID, 7, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[7]);
+
+    public final BiomeGenUndergroundBase igneous9 = (new BiomeGenUndergroundBase(8, igneousID, 0, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[8]);
+    public final BiomeGenUndergroundBase igneous10 = (new BiomeGenUndergroundBase(9, igneousID, 1, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[9]);
+    public final BiomeGenUndergroundBase igneous11 = (new BiomeGenUndergroundBase(10, igneousID, 2, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[0]);
+    public final BiomeGenUndergroundBase igneous12 = (new BiomeGenUndergroundBase(11, igneousID, 3, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[1]);
+    public final BiomeGenUndergroundBase igneous13 = (new BiomeGenUndergroundBase(12, igneousID, 4, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[2]);
+    public final BiomeGenUndergroundBase igneous14 = (new BiomeGenUndergroundBase(13, igneousID, 5, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[3]);
+    public final BiomeGenUndergroundBase igneous15 = (new BiomeGenUndergroundBase(14, igneousID, 6, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[4]);
+    public final BiomeGenUndergroundBase igneous16 = (new BiomeGenUndergroundBase(15, igneousID, 7, biomeList))
+            .setName("Igneous").AddStrataLayers(strataLayers[5]);
+
+    static NamedBlock metamorphicID = UBIDs.metamorphicStoneName;
+
+    public final BiomeGenUndergroundBase metamorphic1 = (new BiomeGenUndergroundBase(16, metamorphicID, 0, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[6]);
+    public final BiomeGenUndergroundBase metamorphic2 = (new BiomeGenUndergroundBase(17, metamorphicID, 1, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[7]);
+    public final BiomeGenUndergroundBase metamorphic3 = (new BiomeGenUndergroundBase(18, metamorphicID, 1, biomeList))//to stop marble from being a base rock
+            .setName("Metamorphic").AddStrataLayers(strataLayers[8]);
+    public final BiomeGenUndergroundBase metamorphic4 = (new BiomeGenUndergroundBase(19, metamorphicID, 3, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[9]);
+    public final BiomeGenUndergroundBase metamorphic5 = (new BiomeGenUndergroundBase(20, metamorphicID, 4, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[0]);
+    public final BiomeGenUndergroundBase metamorphic6 = (new BiomeGenUndergroundBase(21, metamorphicID, 5, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[1]);
+    public final BiomeGenUndergroundBase metamorphic7 = (new BiomeGenUndergroundBase(22, metamorphicID, 6, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[2]);
+    public final BiomeGenUndergroundBase metamorphic8 = (new BiomeGenUndergroundBase(23, metamorphicID, 7, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[3]);
+
+    public final BiomeGenUndergroundBase metamorphic9 = (new BiomeGenUndergroundBase(24, metamorphicID, 0, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[4]);
+    public final BiomeGenUndergroundBase metamorphic10 = (new BiomeGenUndergroundBase(25, metamorphicID, 1, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[5]);
+    public final BiomeGenUndergroundBase metamorphic11 = (new BiomeGenUndergroundBase(26, metamorphicID, 1, biomeList))//to stop marble from being a base rock
+            .setName("Metamorphic").AddStrataLayers(strataLayers[6]);
+    public final BiomeGenUndergroundBase metamorphic12 = (new BiomeGenUndergroundBase(27, metamorphicID, 3, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[7]);
+    public final BiomeGenUndergroundBase metamorphic13 = (new BiomeGenUndergroundBase(28, metamorphicID, 4, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[8]);
+    public final BiomeGenUndergroundBase metamorphic14 = (new BiomeGenUndergroundBase(29, metamorphicID, 5, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[9]);
+    public final BiomeGenUndergroundBase metamorphic15 = (new BiomeGenUndergroundBase(30, metamorphicID, 6, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[0]);
+    public final BiomeGenUndergroundBase metamorphic16 = (new BiomeGenUndergroundBase(31, metamorphicID, 7, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[1]);
+
+    public final BiomeGenUndergroundBase vanillaStone1 = (new BiomeGenUndergroundBase(32, NamedVanillaBlock.stone, 0, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[0]);
+    public final BiomeGenUndergroundBase vanillaStone2 = (new BiomeGenUndergroundBase(33, NamedVanillaBlock.stone, 0, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[1]);
+    public final BiomeGenUndergroundBase vanillaStone3 = (new BiomeGenUndergroundBase(34, NamedVanillaBlock.stone, 0, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[2]);
+    public final BiomeGenUndergroundBase vanillaStone4 = (new BiomeGenUndergroundBase(35, NamedVanillaBlock.stone, 0, biomeList))
+            .setName("Metamorphic").AddStrataLayers(strataLayers[3]);
+
+    @Override
+    public BiomeGenUndergroundBase[] allowedBiomes() {
+        BiomeGenUndergroundBase[] allowedBiomes = null;
+         if (!UndergroundBiomes.vanillaStoneBiomes()) {
+            allowedBiomes = new BiomeGenUndergroundBase[] {igneous1, igneous2,
+                    igneous3, igneous4,
+                    igneous5, igneous6, igneous7,
+                    igneous8, igneous9, igneous10,
+                    igneous11, igneous12, igneous13,
+                    igneous14, igneous15, igneous16,
+                    metamorphic1, metamorphic2, metamorphic3,
+                    metamorphic4, metamorphic5, metamorphic6,
+                    metamorphic7, metamorphic8, metamorphic9,
+                    metamorphic10, metamorphic11, metamorphic12,
+                    metamorphic13, metamorphic14, metamorphic15,
+                    metamorphic16};
+        } else {
+            allowedBiomes = new BiomeGenUndergroundBase[] {igneous1, igneous2,
+                    igneous3, igneous4,
+                    igneous5, igneous6, igneous7,
+                    igneous8, igneous9, igneous10,
+                    igneous11, igneous12, igneous13,
+                    igneous14, igneous15, igneous16,
+                    metamorphic1, metamorphic2, metamorphic3,
+                    metamorphic4, metamorphic5, metamorphic6,
+                    metamorphic7, metamorphic8, metamorphic9,
+                    metamorphic10, metamorphic11, metamorphic12,
+                    metamorphic13, metamorphic14, metamorphic15,
+                    metamorphic16,
+                    vanillaStone1, vanillaStone2,
+                    vanillaStone3, vanillaStone4
+                    };
+        }
+        return generatable(allowedBiomes);
+    }
+    public BiomeGenUndergroundBase [] generatable(BiomeGenUndergroundBase[] possible) {
+        ArrayList<BiomeGenUndergroundBase> accepted = new ArrayList<BiomeGenUndergroundBase>();
+        for (int i = 0; i < possible.length; i++) {
+            NamedBlock block = possible[i].fillerBlockCodes.name;
+            int metadata = possible[i].fillerBlockCodes.metadata;
+            if (settings.generationAllowed(block, metadata)) accepted.add(possible[i]);
+        }
+        BiomeGenUndergroundBase[] result = new BiomeGenUndergroundBase[accepted.size()];
+        return accepted.toArray(result);
+    }
+}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/StrataLayer.java E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/StrataLayer.java
deleted file mode 100644
index 2e4154f..0000000
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/StrataLayer.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package exterminatorJeff.undergroundBiomes.worldGen;
-
-import exterminatorJeff.undergroundBiomes.api.NamedBlock;
-
-public class StrataLayer {
-	public final NamedBlock layerBlock;
-	public final int layerMetadataID, layerMin, layerMax;
-	public final UBStoneCodes codes;
-	
-	public StrataLayer(NamedBlock layerBlock, int layerMetadataID, int layerMin, int layerMax) {
-		this.layerBlock = layerBlock;
-		this.layerMetadataID = layerMetadataID;
-		this.layerMin = layerMin;
-		this.layerMax = layerMax;
-		this.codes = new UBStoneCodes(layerBlock, layerMetadataID);
-	}
-	
-	public boolean valueIsInLayer(int y) {
-		if (y >= layerMin && y <= layerMax) {
-			return true;
-		} else {
-			return false;
-		}
-	}
-	
-}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBBlockProvider.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBBlockProvider.java
index 1b8958b..2e2fa96 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBBlockProvider.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBBlockProvider.java
@@ -1,5 +1,8 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.UBStoneCodes;
+import exterminatorJeff.undergroundBiomes.api.BiomeGenUndergroundBase;
+import exterminatorJeff.undergroundBiomes.api.StrataLayer;
 import exterminatorJeff.undergroundBiomes.common.WorldGenManager;
 import exterminatorJeff.undergroundBiomes.api.UBStrataColumn;
 import exterminatorJeff.undergroundBiomes.api.UBStrataColumnProvider;
@@ -13,62 +15,57 @@ import net.minecraft.world.chunk.IChunkProvider;
  */
 public class UBBlockProvider implements UBStrataColumnProvider {
 
-	private BiomeUndergroundCacheBlock chunkBiomeArray; // one chunk cached for speed
-	private final WorldGenManager worldGen;
+    private BiomeUndergroundCacheBlock chunkBiomeArray; // one chunk cached for speed
+    private final WorldGenManager worldGen;
+
+    public UBBlockProvider(WorldGenManager _worldGen) {
+        worldGen = _worldGen;
+        chunkBiomeArray = worldGen.chunkBiomeCache(0, 0);//preset so presence is an invariant;
+    }
     
-	public UBBlockProvider(WorldGenManager _worldGen) {
-		worldGen = _worldGen;
-		chunkBiomeArray = worldGen.chunkBiomeCache(0, 0);//preset so presence is an invariant;
-	}
+        private UBStrataColumn strataColumn(
+            final StrataLayer[] strata,
+            final UBStoneCodes fillerBlockCodes,
+            final int variation) {
+        return new UBStrataColumn() {
 
-	private UBStrataColumn strataColumn(final StrataLayer[] strata, final UBStoneCodes fillerBlockCodes, final int variation) {
-		return new UBStrataColumn() {
 
-			@Override
-			public UBStoneCodes stone(int y) {
-				for (int i = 0; i < strata.length; i++) {
-					if (strata[i].valueIsInLayer(y + variation) == true) {
-						return strata[i].codes;
-					}
-				}
-				return fillerBlockCodes;
-			}
+            public UBStoneCodes stone(int y){
+                for(int i = 0; i < strata.length; i++){
+                    if(strata[i].valueIsInLayer(y+variation) == true){
+                        return strata[i].codes;
+                    }
+                }
+                return fillerBlockCodes;
+            }
 
-			@Override
-			public BlockCodes cobblestone(int height) {
-				return stone(height).onDrop;
-			}
+            public BlockCodes cobblestone(int height){
+                return stone(height).onDrop;
+            }
 
-			@Override
-			public BlockCodes cobblestone() {
-				return stone().onDrop;
-			}
+            public BlockCodes cobblestone(){
+                return stone().onDrop;
+            }
 
-			@Override
-			public BlockCodes stone() {
-				return fillerBlockCodes;
-			}
-		};
-	}
+            public BlockCodes stone(){
+                return fillerBlockCodes;
+            }
+        };
+    }
 
-	@Override
-	public UBStrataColumn strataColumn(int x, int z) {
-		// make sure we have the right chunk
-		if (!chunkBiomeArray.contains(x, z)) {
-			chunkBiomeArray = worldGen.chunkBiomeCache(x, z);
-		}
-		BiomeGenUndergroundBase biome = chunkBiomeArray.getBiomeGenAt(x, z);
-		int variation = (int) (biome.strataNoise.noise(x / 55.533, z / 55.533, 3, 1, 0.5) * 10 - 5);
-		return strataColumn(biome.strata, biome.fillerBlockCodes, variation);
-	}
+    public UBStrataColumn strataColumn(int x, int z) {
+        // make sure we have the right chunk
+        if (!chunkBiomeArray.contains(x, z)) {
+            chunkBiomeArray = worldGen.chunkBiomeCache(x, z);
+        }
+        BiomeGenUndergroundBase biome = chunkBiomeArray.getBiomeGenAt(x, z);
+        int variation = (int) (biome.strataNoise.noise(x/55.533, z/55.533, 3, 1, 0.5) * 10 - 5);
+        return strataColumn(biome.strata, biome.fillerBlockCodes, variation);
+    }
 
-	@Override
-	public boolean inChunkGenerationAllowed() {
-		return this.worldGen.inChunkGenerationAllowed();
-	}
+    public boolean inChunkGenerationAllowed() {return this.worldGen.inChunkGenerationAllowed();}
 
-	@Override
-	public IChunkProvider UBChunkProvider(IChunkProvider wrapped) {
-		return worldGen.UBChunkProvider(wrapped);
-	}
+    public IChunkProvider UBChunkProvider(IChunkProvider wrapped) {
+        return worldGen.UBChunkProvider(wrapped);
+    }
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBChunkProvider.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBChunkProvider.java
index 458b0cf..31006b0 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBChunkProvider.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBChunkProvider.java
@@ -1,9 +1,14 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import Zeno410Utils.Bomb;
+import Zeno410Utils.PlaneLocation;
 import net.minecraft.world.chunk.Chunk;
 import net.minecraft.world.chunk.IChunkProvider;
 
+
 import Zeno410Utils.Zeno410Logger;
+import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
+import java.util.WeakHashMap;
 import java.util.logging.Logger;
 
 /**
@@ -11,30 +16,52 @@ import java.util.logging.Logger;
  * @author Zeno410
  */
 public class UBChunkProvider extends ChunkProviderWrapper {
-	BiomeUndergroundDecorator decorator;
-	static Logger logger = new Zeno410Logger("UBChunkProvider").logger();
-	int level = 0;
-	public final int dimension;
-	
-	public UBChunkProvider(IChunkProvider toWrap, BiomeUndergroundDecorator _decorator, int dimension) {
-		super(toWrap);
-		
-		logger.info("UB generation wrapping " + toWrap.toString());
-		decorator = _decorator;
-		this.dimension = dimension;
-	}
-	
-	@Override
-	public Chunk provideChunk(int i, int j) {
-		Chunk result = super.provideChunk(i, j);
-		decorator.replaceChunkBlocks(result, i, j, dimension);
-		return result;
-	}
-	
-	@Override
-	public void populate(IChunkProvider ichunkprovider, int i, int j) {
-		super.populate(ichunkprovider, i, j);
-		decorator.replaceChunkOres(ichunkprovider, i, j);
-	}
+    BiomeUndergroundDecorator decorator;
+    static Logger logger = new Zeno410Logger("UBChunkProvider").logger();
+    WeakHashMap<PlaneLocation,Chunk> generatingChunks = new WeakHashMap<PlaneLocation,Chunk>();
+    int level = 0;
+    public final int dimension;
+    public UBChunkProvider(IChunkProvider toWrap, BiomeUndergroundDecorator _decorator, int dimension){
+        super(toWrap);
+
+        logger.info("UB generation wrapping " + toWrap.toString());
+        decorator = _decorator;
+        this.dimension = dimension;
+    }
+
+    @Override
+    public Chunk provideChunk(int i, int j) {
+        PlaneLocation place = new PlaneLocation(i,j);
+        if (UndergroundBiomes.instance().settings().newGeneration.value()){
+            Chunk result = generatingChunks.get(place);
+            if (result != null) return result;
+        }
+        Chunk result = super.provideChunk(i,j);
+        if (UndergroundBiomes.instance().settings().newGeneration.value()) {
+            // we're storing to improve speed and reduce insanity
+            generatingChunks.put(place, result);
+            //decorator.replaceChunkBlocks(result, i, j, dimension);
+        } else {
+            // we replace early for speed
+            decorator.replaceChunkBlocks(result, i, j, dimension);
+        }
+
+        return result;
+    }
+
+    @Override
+    public void populate(IChunkProvider ichunkprovider, int i, int j) {
+        super.populate(ichunkprovider, i, j);
+        if (UndergroundBiomes.instance().settings().newGeneration.value()) {
+            Chunk target = ichunkprovider.provideChunk(i, j);
+            if (target.isTerrainPopulated) {
+                decorator.replaceChunkBlocks(target, i, j, dimension);
+                decorator.replaceChunkOres(ichunkprovider,i, j);
+            } 
+        } else {
+            // replace ores anyway
+            decorator.replaceChunkOres(ichunkprovider, i, j);
+        }
+    }
 
 }
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBStoneCodes.java E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBStoneCodes.java
deleted file mode 100644
index 81aed9c..0000000
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UBStoneCodes.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package exterminatorJeff.undergroundBiomes.worldGen;
-
-import exterminatorJeff.undergroundBiomes.api.BlockCodes;
-import exterminatorJeff.undergroundBiomes.api.UBIDs;
-import exterminatorJeff.undergroundBiomes.api.NamedBlock;
-import exterminatorJeff.undergroundBiomes.api.NamedVanillaBlock;
-import exterminatorJeff.undergroundBiomes.common.UndergroundBiomes;
-
-/**
- *
- * @author Zeno410
- */
-public class UBStoneCodes extends BlockCodes {
-	// constructor is protected as it's intended to make master blocks to be passed by reference
-	// not fully implemented yet
-	
-	UBStoneCodes(NamedBlock name, int _metadata) {
-		super(name, _metadata, cobbleVersion(name, _metadata));
-	}
-	
-	public final UBStoneCodes slabVersionEquivalent() {
-		return new UBStoneCodes(UBIDs.slabVersionID(name), metadata);
-	};
-	
-	public final UBStoneCodes brickVersionEquivalent() {
-		return new UBStoneCodes(UBIDs.brickVersionID(name), metadata);
-	};
-	
-	public static BlockCodes cobbleVersion(NamedBlock name, int metadata) {
-		
-		if (name == UBIDs.igneousStoneName) {
-			return new BlockCodes(UBIDs.igneousCobblestoneName, metadata);
-		}
-		if (name == UBIDs.metamorphicStoneName) {
-			return new BlockCodes(UBIDs.metamorphicCobblestoneName, metadata);
-		}
-		if (name == UBIDs.sedimentaryStoneName) {
-			return new BlockCodes(UBIDs.sedimentaryStoneName, metadata);
-		}
-		
-		if (name == NamedVanillaBlock.stone) {
-			if (metadata == 0) {
-				return new BlockCodes(NamedVanillaBlock.cobblestone, metadata);
-			}
-		}
-		
-		if (name == NamedVanillaBlock.sandstone) {
-			if (metadata == 0) {
-				return new BlockCodes(NamedVanillaBlock.sandstone, metadata);
-			}
-		}
-		if (name == NamedVanillaBlock.sand) {
-			if (metadata == 0) {
-				return new BlockCodes(NamedVanillaBlock.sandstone, metadata);
-			}
-		}
-		
-		if (name == UBIDs.igneousCobblestoneName) {
-			return new BlockCodes(UBIDs.igneousCobblestoneName, metadata);
-		}
-		if (name == UBIDs.metamorphicCobblestoneName) {
-			return new BlockCodes(UBIDs.metamorphicCobblestoneName, metadata);
-		}
-		
-		if (name == UBIDs.igneousStoneBrickName) {
-			return new BlockCodes(UBIDs.igneousStoneBrickName, metadata);
-		}
-		if (name == UBIDs.metamorphicStoneBrickName) {
-			return new BlockCodes(UBIDs.metamorphicStoneBrickName, metadata);
-		}
-		
-		if (name == UBIDs.igneousStoneSlabName.half) {
-			return new BlockCodes(UBIDs.igneousCobblestoneSlabName.half, metadata);
-		}
-		if (name == UBIDs.metamorphicStoneSlabName.half) {
-			return new BlockCodes(UBIDs.metamorphicCobblestoneSlabName.half, metadata);
-		}
-		if (name == UBIDs.sedimentaryStoneSlabName.half) {
-			return new BlockCodes(UBIDs.sedimentaryStoneSlabName.half, metadata);
-		}
-		
-		if (name == UBIDs.igneousCobblestoneSlabName.half) {
-			return new BlockCodes(UBIDs.igneousCobblestoneSlabName.half, metadata);
-		}
-		if (name == UBIDs.metamorphicCobblestoneSlabName.half) {
-			return new BlockCodes(UBIDs.metamorphicCobblestoneSlabName.half, metadata);
-		}
-		
-		if (name == UBIDs.igneousBrickSlabName.half) {
-			return new BlockCodes(UBIDs.igneousBrickSlabName.half, metadata);
-		}
-		if (name == UBIDs.metamorphicBrickSlabName.half) {
-			return new BlockCodes(UBIDs.metamorphicBrickSlabName.half, metadata);
-		}
-		
-		if (name == NamedVanillaBlock.stoneBrick) {
-			return new BlockCodes(NamedVanillaBlock.stoneBrick, metadata);
-		}
-		
-		if (UndergroundBiomes.crashOnProblems()) {
-			throw new RuntimeException("no cobble for " + name.external() + " metadata " + metadata);
-		}
-		
-		return new BlockCodes(NamedVanillaBlock.cobblestone, metadata);
-	}
-	
-	public final BlockCodes cobblestoneEquivalent() {
-		return this.onDrop;
-	}
-}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UndergroundBiomeSet.java E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UndergroundBiomeSet.java
deleted file mode 100644
index 6912dc3..0000000
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/UndergroundBiomeSet.java
+++ /dev/null
@@ -1,98 +0,0 @@
-
-package exterminatorJeff.undergroundBiomes.worldGen;
-
-import exterminatorJeff.undergroundBiomes.api.NamedBlock;
-import exterminatorJeff.undergroundBiomes.api.NamedVanillaBlock;
-import exterminatorJeff.undergroundBiomes.api.UBIDs;
-
-/**
- *
- * @author Zeno410
- */
-public class UndergroundBiomeSet {
-    final BiomeGenStrataLayers strataLayers = new BiomeGenStrataLayers();
-
-    public final BiomeGenUndergroundBase[] biomeList = new BiomeGenUndergroundBase[256];
-
-    NamedBlock igneousID = UBIDs.igneousStoneName;
- 
-    public final BiomeGenUndergroundBase igneous1 = (new BiomeGenUndergroundBase(0, igneousID, 0, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[0]);
-    public final BiomeGenUndergroundBase igneous2 = (new BiomeGenUndergroundBase(1, igneousID, 1, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[1]);
-    public final BiomeGenUndergroundBase igneous3 = (new BiomeGenUndergroundBase(2, igneousID, 2, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[2]);
-    public final BiomeGenUndergroundBase igneous4 = (new BiomeGenUndergroundBase(3, igneousID, 3, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[3]);
-    public final BiomeGenUndergroundBase igneous5 = (new BiomeGenUndergroundBase(4, igneousID, 4, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[4]);
-    public final BiomeGenUndergroundBase igneous6 = (new BiomeGenUndergroundBase(5, igneousID, 5, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[5]);
-    public final BiomeGenUndergroundBase igneous7 = (new BiomeGenUndergroundBase(6, igneousID, 6, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[6]);
-    public final BiomeGenUndergroundBase igneous8 = (new BiomeGenUndergroundBase(7, igneousID, 7, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[7]);
-
-    public final BiomeGenUndergroundBase igneous9 = (new BiomeGenUndergroundBase(8, igneousID, 0, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[8]);
-    public final BiomeGenUndergroundBase igneous10 = (new BiomeGenUndergroundBase(9, igneousID, 1, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[9]);
-    public final BiomeGenUndergroundBase igneous11 = (new BiomeGenUndergroundBase(10, igneousID, 2, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[0]);
-    public final BiomeGenUndergroundBase igneous12 = (new BiomeGenUndergroundBase(11, igneousID, 3, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[1]);
-    public final BiomeGenUndergroundBase igneous13 = (new BiomeGenUndergroundBase(12, igneousID, 4, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[2]);
-    public final BiomeGenUndergroundBase igneous14 = (new BiomeGenUndergroundBase(13, igneousID, 5, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[3]);
-    public final BiomeGenUndergroundBase igneous15 = (new BiomeGenUndergroundBase(14, igneousID, 6, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[4]);
-    public final BiomeGenUndergroundBase igneous16 = (new BiomeGenUndergroundBase(15, igneousID, 7, biomeList))
-            .setName("Igneous").AddStrataLayers(strataLayers.layers[5]);
-
-    static NamedBlock metamorphicID = UBIDs.metamorphicStoneName;
-
-    public final BiomeGenUndergroundBase metamorphic1 = (new BiomeGenUndergroundBase(16, metamorphicID, 0, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[6]);
-    public final BiomeGenUndergroundBase metamorphic2 = (new BiomeGenUndergroundBase(17, metamorphicID, 1, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[7]);
-    public final BiomeGenUndergroundBase metamorphic3 = (new BiomeGenUndergroundBase(18, metamorphicID, 1, biomeList))//to stop marble from being a base rock
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[8]);
-    public final BiomeGenUndergroundBase metamorphic4 = (new BiomeGenUndergroundBase(19, metamorphicID, 3, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[9]);
-    public final BiomeGenUndergroundBase metamorphic5 = (new BiomeGenUndergroundBase(20, metamorphicID, 4, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[0]);
-    public final BiomeGenUndergroundBase metamorphic6 = (new BiomeGenUndergroundBase(21, metamorphicID, 5, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[1]);
-    public final BiomeGenUndergroundBase metamorphic7 = (new BiomeGenUndergroundBase(22, metamorphicID, 6, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[2]);
-    public final BiomeGenUndergroundBase metamorphic8 = (new BiomeGenUndergroundBase(23, metamorphicID, 7, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[3]);
-
-    public final BiomeGenUndergroundBase metamorphic9 = (new BiomeGenUndergroundBase(24, metamorphicID, 0, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[4]);
-    public final BiomeGenUndergroundBase metamorphic10 = (new BiomeGenUndergroundBase(25, metamorphicID, 1, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[5]);
-    public final BiomeGenUndergroundBase metamorphic11 = (new BiomeGenUndergroundBase(26, metamorphicID, 1, biomeList))//to stop marble from being a base rock
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[6]);
-    public final BiomeGenUndergroundBase metamorphic12 = (new BiomeGenUndergroundBase(27, metamorphicID, 3, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[7]);
-    public final BiomeGenUndergroundBase metamorphic13 = (new BiomeGenUndergroundBase(28, metamorphicID, 4, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[8]);
-    public final BiomeGenUndergroundBase metamorphic14 = (new BiomeGenUndergroundBase(29, metamorphicID, 5, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[9]);
-    public final BiomeGenUndergroundBase metamorphic15 = (new BiomeGenUndergroundBase(30, metamorphicID, 6, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[0]);
-    public final BiomeGenUndergroundBase metamorphic16 = (new BiomeGenUndergroundBase(31, metamorphicID, 7, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[1]);
-
-    public final BiomeGenUndergroundBase vanillaStone1 = (new BiomeGenUndergroundBase(32, NamedVanillaBlock.stone, 0, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[0]);
-    public final BiomeGenUndergroundBase vanillaStone2 = (new BiomeGenUndergroundBase(33, NamedVanillaBlock.stone, 0, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[1]);
-    public final BiomeGenUndergroundBase vanillaStone3 = (new BiomeGenUndergroundBase(34, NamedVanillaBlock.stone, 0, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[2]);
-    public final BiomeGenUndergroundBase vanillaStone4 = (new BiomeGenUndergroundBase(35, NamedVanillaBlock.stone, 0, biomeList))
-            .setName("Metamorphic").AddStrataLayers(strataLayers.layers[3]);
-
-}
diff --git E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/VillageStoneChanger.java E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/VillageStoneChanger.java
index 3f34750..cad0719 100644
--- E:/dsgit/UndergroundBiomesConstructs-LemADEC/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/VillageStoneChanger.java
+++ E:/dsgit/UndergroundBiomesConstructs-fork/src/main/java/exterminatorJeff/undergroundBiomes/worldGen/VillageStoneChanger.java
@@ -1,5 +1,6 @@
 package exterminatorJeff.undergroundBiomes.worldGen;
 
+import exterminatorJeff.undergroundBiomes.api.UBStoneCodes;
 import net.minecraft.init.Blocks;
 import net.minecraftforge.event.terraingen.BiomeEvent.GetVillageBlockID;
 import net.minecraftforge.event.terraingen.BiomeEvent.GetVillageBlockMeta;
@@ -14,58 +15,50 @@ import cpw.mods.fml.common.eventhandler.Event.Result;
 
 public class VillageStoneChanger {
 
-	private UBStoneCodes preferredStone;
-	boolean replacing;
+    private UBStoneCodes preferredStone;
+    boolean replacing;
 
-	public void setStoneCode(UBStoneCodes newCode) {
-		preferredStone = newCode;
-	}
+    public void setStoneCode (UBStoneCodes newCode) {
+        preferredStone = newCode;
+    }
 
-	public void onVillageSelectBlock(GetVillageBlockID event) {
-		if (preferredStone == null) {
-			return;
-		}
-		if (event.original == Blocks.log) {
-			event.replacement = event.original;
-		}
-		if (event.original == Blocks.cobblestone) {
-			event.replacement = preferredStone.onDrop.block;
-			replacing = true;
-			event.setResult(Result.DENY);
-		}
-		if (event.original == Blocks.planks) {
-			event.replacement = event.original;
-		}
-		if (event.original == Blocks.oak_stairs) {
-			event.replacement = event.original;
-		}
-		if (event.original == Blocks.stone_stairs) {
-			if (UndergroundBiomes.stairsOn()) {
-				event.replacement = Blocks.oak_stairs;
-				event.setResult(Result.DENY);
-			}
-		}
-		if (event.original == Blocks.gravel) {
-			if (UndergroundBiomes.replaceVillageGravel()) {
-				event.replacement = preferredStone.brickVersionEquivalent().block;
-				replacing = true;
-				event.setResult(Result.DENY);
-			}
-		}
-		if (event.original == Blocks.stone_slab) {
-			event.replacement = preferredStone.slabVersionEquivalent().block;
-			event.setResult(Result.DENY);
-		}
-	}
+    public void onVillageSelectBlock(GetVillageBlockID e){
+        if (preferredStone == null) return;
+        if (e.original == Blocks.log)e.replacement = e.original;
+        if (e.original == Blocks.cobblestone) {
+            e.replacement = preferredStone.onDrop.block;
+            replacing = true;
+            e.setResult(Result.DENY);
+        }
+        if (e.original == Blocks.planks)e.replacement = e.original;
+        if (e.original == Blocks.oak_stairs)e.replacement = e.original;
+        if (e.original == Blocks.stone_stairs){
+            if (UndergroundBiomes.stairsOn()) {
+                  e.replacement = Blocks.oak_stairs;
+                  e.setResult(Result.DENY);
+            }
+        }
+        if (e.original == Blocks.gravel){
+                if (UndergroundBiomes.replaceVillageGravel()) {
+                e.replacement = preferredStone.brickVersionEquivalent().block;
+                replacing = true;
+                e.setResult(Result.DENY);
+            }
             
-	public void onVillageSelectMeta(GetVillageBlockMeta event) {
-		if (preferredStone == null) {
-			return;
-		}
-		if (replacing == true) {
-			event.replacement = preferredStone.onDrop.metadata;
-			event.setResult(Result.DENY);
-			replacing = false;
-		}
-	}
+        }
+        if (e.original == Blocks.stone_slab) {
+            e.replacement = preferredStone.slabVersionEquivalent().block;
+            replacing = true;
+            e.setResult(Result.DENY);
+        }
+    }
+
+    public void onVillageSelectMeta(GetVillageBlockMeta e){
+        if (preferredStone == null) return;
+        if (replacing == true) {
+            e.replacement = preferredStone.onDrop.metadata;
+            e.setResult(Result.DENY);
+            replacing = false;
+        }
+    }
 }
